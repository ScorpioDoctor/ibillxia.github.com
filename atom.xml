<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-10-19T22:04:43+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(5.2) 算法之数值算法]]></title>
    <link href="http://ibillxia.github.io/blog/2014/10/19/insight-into-stl-5-algorithm-2-numeric-algorithms/"/>
    <updated>2014-10-19T20:28:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/10/19/insight-into-stl-5-algorithm-2-numeric-algorithms</id>
    <content type="html"><![CDATA[<p>本文主要介绍STL中的数值算法，主要涉及到的源码文件有 <code>stl_numberic.h</code>、<code>numeric</code>、<code>stl_relops.h</code> 等。</p>

<p>STL 数值算法主要包含以下几个算法（来自<a href="http://www.cplusplus.com/reference/numeric/">C++文档</a>）：</p>

<ul>
<li>accumulate: Accumulate values in range</li>
<li>adjacent_difference: Compute adjacent difference of range</li>
<li>inner_product: Compute cumulative inner product of range</li>
<li>partial_sum: Compute partial sums of range</li>
<li>iota: Store increasing sequence</li>
<li>power: power(x,n) 1 multiply by x n times (not in C++ standard)</li>
</ul>


<p>下面一一介绍每个算法的实现。</p>

<h3>1. accumulate</h3>

<p>该算法计算 init 和区间 [first, last) 内所有元素的总和。注意，必须提供 init 的初始值，这样即使 first=last 区间为空，仍能得到一个明确定义的值。当 init=0 时，即为计算 [first, last) 区间内所有元素的总和。具体实现有两个版本，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _InputIterator, class _Tp&gt;
</span><span class='line'>_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init){
</span><span class='line'>  __STL_REQUIRES(_InputIterator, _InputIterator); // concept check
</span><span class='line'>  for ( ; __first != __last; ++__first)
</span><span class='line'>    __init = __init + *__first; // 求和
</span><span class='line'>  return __init;
</span><span class='line'>}
</span><span class='line'>template &lt;class _InputIterator, class _Tp, class _BinaryOperation&gt;
</span><span class='line'>_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op){
</span><span class='line'>  __STL_REQUIRES(_InputIterator, _InputIterator); // concept check
</span><span class='line'>  for ( ; __first != __last; ++__first)
</span><span class='line'>    __init = __binary_op(__init, *__first); // 指定二元操作
</span><span class='line'>  return __init;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第二个版本通过仿函数参数 <em>binary_op 指定操作类型，可以实现其他方式的累计，例如累乘等（令init=1，</em>binary_op=multiply）。</p>

<h3>2. adjacent_difference</h3>

<p>该算法用来计算区间 [first, last) 中相邻元素的差（或其他指定运算，结果[i]=当前元素[i]的值-前驱元素[i-1]的值），该算法也有两个版本，一个是指定运算为差，另一个传入仿函数(参数 _binary_op)指定具体运算，这里贴出第二个版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOperation&gt;
</span><span class='line'>_OutputIterator
</span><span class='line'>__adjacent_difference(_InputIterator __first, _InputIterator __last, 
</span><span class='line'>                      _OutputIterator __result, _Tp*, _BinaryOperation __binary_op) {
</span><span class='line'>  _Tp __value = *__first;
</span><span class='line'>  while (++__first != __last) { // 先 ++ ，再比较
</span><span class='line'>    _Tp __tmp = *__first; // 取第i+1个元素的值
</span><span class='line'>    *++__result = __binary_op(__tmp, __value);
</span><span class='line'>    __value = __tmp; // 保存第i个元素的值
</span><span class='line'>  }
</span><span class='line'>  return ++__result;
</span><span class='line'>}
</span><span class='line'>template &lt;class _InputIterator, class _OutputIterator, class _BinaryOperation&gt;
</span><span class='line'>_OutputIterator adjacent_difference(_InputIterator __first, _InputIterator __last,
</span><span class='line'>                    _OutputIterator __result, _BinaryOperation __binary_op) {
</span><span class='line'>  if (__first == __last) return __result; // 区间为空，直接返回
</span><span class='line'>  *__result = *__first; // 第一个元素没有前驱，直接将当前值赋给结果
</span><span class='line'>  return __adjacent_difference(__first, __last, __result,
</span><span class='line'>                               __VALUE_TYPE(__first), __binary_op);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3. inner_product</h3>

<p>该算法实现区间 [first1, last1) 和区间 [first2, first2+(last1-first1) ) 的一般内积（generalized inner product），公式为$init = init+(<em>i) * (</em>(first2+(i-first1)))$同样需要提供 init 的值（理由同accumulate）。另外还有一个版本，提供两个仿函数，分别指定上面公式中的加法和乘法。第一个版本的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _InputIterator1, class _InputIterator2, class _Tp&gt;
</span><span class='line'>_Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
</span><span class='line'>                  _InputIterator2 __first2, _Tp __init) {
</span><span class='line'>  for ( ; __first1 != __last1; ++__first1, ++__first2)
</span><span class='line'>    __init = __init + (*__first1 * *__first2);
</span><span class='line'>  return __init;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，这里其实没有判断第二个区间是否越界，所以在调用时需要我们自己注意，但一般来说计算内积的两个区间都是相同长度的。</p>

<h3>4. partial_sum</h3>

<p>该算法用来计算局部总和，将 <code>*first</code> 赋值给 <code>*result</code>，将 <code>*frist+*(first+1)</code> 赋值给 <code>*(result+1)</code>，依次类推，即有 <code>result[i]=sum(*first..*(first+i))</code>，这是默认的操作为加法的版本，还有一个版本可以通过仿函数指定操作，以下是默认版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _InputIterator, class _OutputIterator, class _Tp&gt;
</span><span class='line'>_OutputIterator __partial_sum(_InputIterator __first, _InputIterator __last,
</span><span class='line'>              _OutputIterator __result, _Tp*) {
</span><span class='line'>  _Tp __value = *__first;
</span><span class='line'>  while (++__first != __last) {
</span><span class='line'>    __value = __value + *__first;
</span><span class='line'>    *++__result = __value; // result 先++，再提领、赋值
</span><span class='line'>  }
</span><span class='line'>  return ++__result;
</span><span class='line'>}
</span><span class='line'>template &lt;class _InputIterator, class _OutputIterator&gt;
</span><span class='line'>_OutputIterator partial_sum(_InputIterator __first, _InputIterator __last,
</span><span class='line'>            _OutputIterator __result){
</span><span class='line'>  if (__first == __last) return __result;
</span><span class='line'>  *__result = *__first; // 第一项直接赋值
</span><span class='line'>  return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>5. itoa</h3>

<p>该算法不是C++/STL标准，主要作用是将区间 [first, last) 的值赋值为 value,value+1,value+2,&#8230; 如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _ForwardIter, class _Tp&gt;
</span><span class='line'>void iota(_ForwardIter __first, _ForwardIter __last, _Tp __value){
</span><span class='line'>  while (__first != __last)
</span><span class='line'>    *__first++ = __value++;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>6. power</h3>

<p>该算法也不是C++/STL标准，作用在于实现 x 的 n 次方的计算，通过将n分解为2的幂来计算。还有一个版本是用户可以指定运算，而不一定是乘法。默认版本如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Integer, class _MonoidOperation&gt;
</span><span class='line'>_Tp __power(_Tp __x, _Integer __n, _MonoidOperation __opr){ // func1：幂方的具体实现
</span><span class='line'>  if (__n == 0)
</span><span class='line'>    return identity_element(__opr);
</span><span class='line'>  else {
</span><span class='line'>    while ((__n & 1) == 0) { // 二进制末尾为0
</span><span class='line'>      __n &gt;&gt;= 1; // n/2
</span><span class='line'>      __x = __opr(__x, __x); // 乘方
</span><span class='line'>    }
</span><span class='line'>    _Tp __result = __x;
</span><span class='line'>    __n &gt;&gt;= 1;
</span><span class='line'>    while (__n != 0) {
</span><span class='line'>      __x = __opr(__x, __x); // 乘方
</span><span class='line'>      if ((__n & 1) != 0) // 二进制末尾为1
</span><span class='line'>        __result = __opr(__result, __x); // 乘入结果
</span><span class='line'>      __n &gt;&gt;= 1;
</span><span class='line'>    }
</span><span class='line'>    return __result;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Integer&gt;
</span><span class='line'>inline _Tp __power(_Tp __x, _Integer __n){ // func2
</span><span class='line'>  return __power(__x, __n, multiplies&lt;_Tp&gt;()); // 调用func3
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Integer, class _MonoidOperation&gt;
</span><span class='line'>inline _Tp power(_Tp __x, _Integer __n, _MonoidOperation __opr){ // func3
</span><span class='line'>  return __power(__x, __n, __opr); // 调用func1
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Integer&gt;
</span><span class='line'>inline _Tp power(_Tp __x, _Integer __n){
</span><span class='line'>  return __power(__x, __n); // 调用func2
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>饶了几道弯，主要看 func1实现即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(5.1) 算法]]></title>
    <link href="http://ibillxia.github.io/blog/2014/10/12/insight-into-stl-5-algorithm-1-overview/"/>
    <updated>2014-10-12T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/10/12/insight-into-stl-5-algorithm-1-overview</id>
    <content type="html"><![CDATA[<h2>1. 算法概述</h2>

<p>算法（Algorithm）是一个计算的具体步骤，常用于计算、数据处理和自动推理。Donald Knuth 在他的著作 The Art of Computer Programming 里对算法的特征归纳（来自wiki）：</p>

<ul>
<li>输入：一个算法必须有零个或以上输入量。</li>
<li>输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。</li>
<li>明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地符合要求或期望，通常要求实际运行结果是确定的。</li>
<li>有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。</li>
<li>有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</li>
</ul>


<p>算法的核心是创建问题抽象的模型和明确求解目标，常见的算法有分治法、贪婪算法、动态规划、平摊分析等。再好的编程技巧，也无法让一个笨拙的算法起死回生，选择了错误的算法，便注定了失败的命运。</p>

<p>算法的<strong>时间复杂度</strong>是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模$n$的函数$f(n)$，算法的时间复杂度也因此记做：<br/>
$T(n) = O(f(n))$<br/>
算法执行时间的增长率与$f(n)$的增长率正相关，称作渐近时间复杂度（Asymptotic Time Complexity），简称时间复杂度。
常见的时间复杂度有：常数阶$O(1)$,对数阶$O(log<em>{2}n)$,线性阶$O(n)$, 线性对数阶$O(nlog</em>{2}n)$,平方阶$O(n<sup>{2})$，立方阶$O(n<sup>{3})$</sup></sup> ，&#8230;， k次方阶$O(n<sup>{k})$,指数阶$O(2<sup>{n})$。随着问题规模$n$的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</sup></sup></p>

<p>算法的<strong>空间复杂度</strong>是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</p>

<!-- more -->


<h2>2. STL 算法概览</h2>

<p>很多算法能用来解决特定问题（如排序、查找、复制、比较、组合等），并获得数学上的性能分析与证明，这样的算法非常具有复用性，STL 的算法组件就总结了70+ 个极具复用价值的算法，包括排序（sorting）、查找（searching）、排列组合（permutation）等，以及用于数据移动、复制、删除、比较、组合、运算等算法。</p>

<p>某些特定的算法与特定的数据结构相关，例如二叉查找树和红黑树便是为了解决查找问题而发展出来的特殊数据结构，hashtable 拥有快速查找能力，又例如 max-heap 可以协助完成 heap sort，几乎可以说，特定的数据结构是为了实现某种特定的算法。这类与特定数据结构相关的算法，在前几篇介绍容器的文章中都有提到，而接下来几篇文章所要介绍的算法则是无特殊条件限制的空间中的某一段元素区间的算法，即泛型算法。</p>

<h4>2.1 STL 算法的一般形式</h4>

<p>所有泛型算法的前两个参数都是一对迭代器（iterators），通常称为 first 和 last，用以标识算法的操作区间，STL 习惯采用前闭后开区间表示法，写成 <code>[first, last)</code> ，当 <code>frist==last</code> 时，表示的是空区间。这个 <code>[first, last)</code> 的必要条件是，必须能够进过 increment （累加）操作的反复运用，从 first 到 last，编译器本身无法强求这一点，如果这个条件不成立，会导致无法预料的结果。</p>

<p>前面讲<a href="http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits/">迭代器</a>时我们知道，STL有5类迭代器，他们是input、output、forward、bidirectional、random_access。_每个 STL 算法的声明，都表现出它所需要的最低程度的迭代器类型，例如 <code>find()</code> 需要一个 inputIterators 是最低要求，但也可以接受更高类型的，如 forwardIterators、bidirectionalIterators、randomAccessIterators，但如果传给它一个outputIterators，则会导致错误。将无效的迭代器传给某个算法，虽然是一种错误，却不能保证在编译时期就被捕捉出来，因为所谓的迭代器型别并不是真实的型别，他们只是 function template 的一种型别参数（type parameters）。</p>

<p>许多 STL 算法都有很多个版本，除了默认的只包含迭代器参数的实现之外，还有一个可以传入仿函数（functor）参数的版本，例如 <code>unique()</code> 缺省情况下使用 <code>equality</code> 操作符来比较两个相邻的元素，但如果这些元素的型别并未提供 <code>equality</code> 操作符，或如果用户希望定义自己的 <code>equality</code> 操作符，便可以传一个仿函数给另一个版本的 <code>unique()</code> ，有些算法干脆将这样的两个版本分为两个不同名的实体，如 <code>find_if()</code>、<code>replace_if()</code> 等。</p>

<h4>2.2 质变算法与非质变算法</h4>

<p>所谓<strong>质变算法</strong>（mutating algorithms），是指算法运算过程中，会更改区间<code>[first, last)</code>内（迭代器所指）的元素内容，诸如复制（copy）、互换（swap）、替换（replace）、填充（fill）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）等，都属于此类。通常质变算法提供两个版本，一个是就地（in-place）进行，另一个是copy（另地进行）版本，将操作对象复制一份副本，然后在副本上进行修改并返回该副本。copy版一般以 <code>_copy</code> 作为函数名后缀，例如 <code>replace_copy()</code> 等。但并不是所有的质变算法都提供copy版，例如 sort 就没有。如果我们一定要使用 copy 版，需要我们自己先 copy 一份副本，然后再将副本传给相应的算法。</p>

<p>所谓<strong>非质变算法</strong>（nonmutating algorithms），是指算法运算过程中不会更改区间<code>[first, last)</code>内的元素内容，诸如查找（find）、匹配（search）、计数（count）、巡访（for_each）_、比较（equal，mismatch）、寻找极值（max、min）等。</p>

<h4>2.3 STL 算法的分类</h4>

<p>STL 算法的实现主要在 <code>stl_algobase.h</code>、<code>stl_algo.h</code>、<code>stl_numeric.h</code> 这3个文件中，其中 <code>stl_numeric.h</code> 主要是数值（numeric）算法，包括 <code>adjecent_difference()</code>、<code>accumulate()</code>、<code>inner_product()</code>、<code>partial_sum()</code> 等，相关接口封装在 <code>&lt;numeric&gt;</code> 中。而其他算法如复制、填充、交换、求极值、排列、排序、分割等等算法则在剩下的那两个文件中，相关接口则封装在 <code>&lt;algorithm&gt;</code> 中。C++ 的 <a href="http://www.cplusplus.com/reference/algorithm/">官方文档</a> 将 STL 算法分为以下几类：</p>

<ul>
<li>Non-modifying sequence operations  非质变操作，查找、计数等</li>
<li>Modifying sequence operations  质变操作，复制、交换、替换、填充、删除、逆转、旋转等</li>
<li>Partitions 分割</li>
<li>Sorting 排序</li>
<li>Binary search (operating on partitioned/sorted ranges) 二分查找</li>
<li>Merge (operating on sorted ranges) 合并</li>
<li>Heap、Min/max、Other 堆算法、极值、其他等</li>
</ul>


<p>后续文章将分别介绍这些算法的具体实现。</p>

<h2>3. 算法的泛化</h2>

<p>上文提到过，很多算法是与底层的数据结构相关的，如何将算法独立于其所处理的数据结构之外，使它能够处理任何数据结构，或者在未知的数据结构（也许是 array，也许是vector，也许是list，也许是deque）上正确地实现操作，并不那么简单。其关键在于，需要把操作对象的型别加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化。如此，整个算法也就在一个抽象层面了，这个过程称为算法的泛型化（generalized），简称泛化。</p>

<p>下面以查找算法的泛化过程为例详细介绍算法泛化的奇妙。对于查找算法，我们首先想到的是在一个整型数组中查找指定元素，一个基本的实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int* find(int* arrayHead, int arraySize, int value){
</span><span class='line'>  for(int i=0; i &lt; arraySize; i++){
</span><span class='line'>      if(arrayHead[i] == value) break;
</span><span class='line'>  }
</span><span class='line'>  return &(arrayHead[i]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该函数在数组中查找指定值的元素，返回找到的第一个符合条件的元素的地址，如果没有找到就返回最后一个元素的下一个位置（称为end）。当没有找到时，这里为什么要返回地址值（end）而不返回null呢？这是为了方便调用后续的泛型算法，但实际上该算法本身还是与容器相关的，而且暴露了很多容器的实现细节（如arraySize等）。为了让该算法适用于所有类型的容器，其操作应该更抽象化，可以让 find 接受两个指针作为参数，标识出一个操作区间，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int* find(int* begin, int* end, int value){
</span><span class='line'>  while(begin != end && *begin != value) ++begin;
</span><span class='line'>  return begin;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该函数在区间 <code>[begin, end)</code> 内查找 value，并返回一个指针。这样做之后，已经隐藏了容器内部特性了，但不足的是，要求元素的数据类型为整型，我们可以通过模板参数来解决这个问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template&lt;typename T&gt;
</span><span class='line'>T* find(T* begin, T* end, const T& value){
</span><span class='line'>  // 用到了operator !=,*,++
</span><span class='line'>  while(begin != end && *begin != value) ++begin;
</span><span class='line'>  return begin; // 会引发copy行为
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>除了参数模板化之外，值得注意的是其中待查找的对象是以常引用的方式传递，这样对于大对象非常有利。于是，现在的find函数几乎适用于任何容器——只要该容器允许指针，而指针又都支持inequality（判断不相等）操作符、dereference（取值）操作符、（prefix）increment（前置式递增）操作符、copy（复制）行为这四种操作。</p>

<p>但这个版本还不够泛化，因为参数被限制为指针，而那些支持以上四种操作、行为很像指针的某些对象就无法使用 find 了。在STL中有迭代器，它是一种行为类似指针的对象，是一种smart pointers，使用迭代器实现 find 如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template&lt;class Iterator, class T&gt;
</span><span class='line'>Iterator find(Iterator begin, Iterator end, const T& value){
</span><span class='line'>  while(begin != end && *begin != value) ++begin;
</span><span class='line'>  return begin;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这便是一个完全泛化的find 函数，它与STL中的find函数几乎一模一样（不同之处可自行查看STL源码）。了解和理解了STL算法的泛化过程，就很容易看懂STL中很多其他的算法了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.5) 关联式容器之hashset和hashmap]]></title>
    <link href="http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap/"/>
    <updated>2014-09-27T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hash_set.h</code>、<code>stl_hash_map.h</code> 等文件。</p>

<h2>1. hashset 和 hash_multi_set</h2>

<p>需要说明的是，STL 标准只规范了复杂度与接口，并没有规范实现方法，但 STL 实现的版本中 set 大多以 RB-tree 为底层机制，SGI STL 在实现了以 RB-tree 为底层机制的 set 外，还实现了以 hashtable 为底层机制的 hashset。<br/>
和 set 一样，hashset 的键值（key）和实值（value）是同一个字段，不同的是 set 默认是自动排序的，而 hashset 则是无序的。除此之外，hashset 与 set 的对外接口完全相同。<br/>
这里还有一种称为 hash_multi_set 的集合，它同 multiset 类似，允许键值重复，而上面的 hashset 则不允许。下面是 hashset 的定义的主要代码：</p>

<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Value, class _HashFcn, class _EqualKey, class _Alloc&gt;
</span><span class='line'>class hash_set {
</span><span class='line'>private:
</span><span class='line'>  typedef hashtable&lt;_Value, _Value, _HashFcn, _Identity&lt;_Value&gt;, _EqualKey, _Alloc&gt; _Ht;
</span><span class='line'>  _Ht _M_ht; // 底层容器的定义
</span><span class='line'>public:
</span><span class='line'>  hash_set() : _M_ht(100, hasher(), key_equal(), allocator_type()) {} // 构造函数
</span><span class='line'>  iterator find(const key_type& __key) const { return _M_ht.find(__key); } // 查找
</span><span class='line'>  size_type count(const key_type& __key) const { return _M_ht.count(__key); } // 计数
</span><span class='line'>  size_type size() const { return _M_ht.size(); } // 表格大小
</span><span class='line'>  size_type max_size() const { return _M_ht.max_size(); } 
</span><span class='line'>  bool empty() const { return _M_ht.empty(); } // 是否为空
</span><span class='line'>  void swap(hash_set& __hs) { _M_ht.swap(__hs._M_ht); } // 交换
</span><span class='line'>  iterator begin() const { return _M_ht.begin(); }
</span><span class='line'>  iterator end() const { return _M_ht.end(); }
</span><span class='line'>  pair&lt;iterator, bool&gt; insert(const value_type& __obj){ // 插入
</span><span class='line'>      pair&lt;typename _Ht::iterator, bool&gt; __p = _M_ht.insert_unique(__obj);
</span><span class='line'>      return pair&lt;iterator,bool&gt;(__p.first, __p.second);
</span><span class='line'>  }
</span><span class='line'>  size_type erase(const key_type& __key) {return _M_ht.erase(__key); } // 擦除
</span><span class='line'>  void erase(iterator __it) { _M_ht.erase(__it); } 
</span><span class='line'>  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
</span><span class='line'>  void clear() { _M_ht.clear(); } // 清空
</span><span class='line'>};
</span><span class='line'>template &lt;class _Value, class _HashFcn, class _EqualKey, class _Alloc&gt;
</span><span class='line'>inline bool operator==(const hash_set&lt;_Value,_HashFcn,_EqualKey,_Alloc&gt;& __hs1,
</span><span class='line'>           const hash_set&lt;_Value,_HashFcn,_EqualKey,_Alloc&gt;& __hs2) {
</span><span class='line'>  return __hs1._M_ht == __hs2._M_ht;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>2. hashmap 和 hash_multi_map</h2>

<p>hashmap 是以 hashtable 为底层容器的 map，而 map 是同时拥有实值（value）和键值（key），且不允许键值重复。<br/>
而 hash_multi_map 是以 hashtable 为底层容器的 map，且允许键值重复。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.4) 关联式容器之hashtable]]></title>
    <link href="http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable/"/>
    <updated>2014-09-13T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hashtable.h</code>、<code>stl_hash_fun.h</code> 等文件。</p>

<h2>1. hashtable 简介</h2>

<p>在数据结构中我们知道，有种数据结构的插入、删除、查找等操作的性能是常数时间，但需要比元素个数更多的空间，这种数据结构就是哈希表。哈希表的基本思想是，将数据存储在与其数值大小相关的地方，比如对该数取模，然后存储在以余数为下表的数组中。但这样会出现一个问题，就是可能会有多个数据被映射到同一个存储位置，即出现了所谓的“碰撞”。哈希表的主要内容就是解决“碰撞”问题，一般而言有以下几种方法：线性探测、二次探测、开链等。</p>

<h4>线性探测</h4>

<p>简单而言，就是在出现“碰撞”后，寻找当前位置以后的空档，然后存入。如果找到尾部都没有空档，则从头部重新开始找。只要空间大小比元素个数大，总能找到的。相应的，元素的查找和删除也与普通的数组不同，查找如果直接定位到相应位置并找到或是空档，就可以确定存在或不存在，而如果定位到当前位置非空且与待查找的元素不同，则要依序寻找后续位置的元素，直到找到或移到了空档。删除则是采用懒惰删除策略，即只标记删除记号，实际删除操作则待表格重新整理时再进行。</p>

<h4>二次探测</h4>

<p>与线性探测类似，但向后寻找的策略是探测距当前位置为平方数的位置，即 $index = H+i<em><sup>{2}$</sup> </em>。但这样会有一个问题，那就是能否保证每次探测的是不同的位置，即是否存在某次插入时，探测完一圈后回到自己而出现死循环。</p>

<h4>开链</h4>

<p>这种方法是将出现冲突的元素放在一个链表中，而哈希表中只存储这些链表的首地址。SGI STL中就是使用这种方法来解决“碰撞”的。</p>

<h2>2. hashtable 的数据结构</h2>

<p>由于使用开链的方法解决冲突，所以要维护两种数据结构，一个是 hash table，在 STL 中称为 buckets，用 vector 作为容器；另一个是链表，这里没有使用 list 或 slist 这些现成的数据结构，而是使用自定义 <code>__hashtable_node</code> ，相关定义具体如下：</p>

<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Val&gt;
</span><span class='line'>struct _Hashtable_node { // 链表节点的定义
</span><span class='line'>  _Hashtable_node* _M_next; // 指向下一个节点
</span><span class='line'>  _Val _M_val;
</span><span class='line'>}; 
</span><span class='line'>template &lt;class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc&gt;
</span><span class='line'>class hashtable {
</span><span class='line'>private:
</span><span class='line'>  typedef _HashFcn hasher;
</span><span class='line'>  hasher                _M_hash; // 哈希函数
</span><span class='line'>  typedef _Hashtable_node&lt;_Val&gt; _Node; // 节点类型别名定义
</span><span class='line'>  vector&lt;_Node*,_Alloc&gt; _M_buckets; // hash table，存储链表的索引
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>这里 hashtable 的模板参数很多，其含义如下：</p>

<blockquote><p><em>Val: 节点的实值类型
</em>Key: 节点的键值类型
<em>HashFcn: 哈希函数的类型
</em>ExtractKey: 从节点中取出键值的方法（函数或仿函数）
<em>EqualKey: 判断键值相同与否的方法（函数或仿函数）
</em>Alloc: 空间配置器，默认使用 std::alloc</p></blockquote>

<p>虽然开链法并不要求哈希表的大小为质数，但 SGI STL 仍然以质数来设计表的大小，并将28个质数（大约2倍依次递增）计算好，并提供函数来查询其中最接近某数并大于某数的质数，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum { __stl_num_primes = 28 };
</span><span class='line'>static const unsigned long __stl_prime_list[__stl_num_primes] = {
</span><span class='line'>  53ul,         97ul,         193ul,       389ul,       769ul,
</span><span class='line'>  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
</span><span class='line'>  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
</span><span class='line'>  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
</span><span class='line'>  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, 
</span><span class='line'>  1610612741ul, 3221225473ul, 4294967291ul
</span><span class='line'>}; // 使用无符号长整型（32bit）
</span><span class='line'>inline unsigned long __stl_next_prime(unsigned long __n) {
</span><span class='line'>  const unsigned long* __first = __stl_prime_list;
</span><span class='line'>  const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes;
</span><span class='line'>  const unsigned long* pos = lower_bound(__first, __last, __n); // lower_bound 是泛型算法，后续会介绍
</span><span class='line'>  return pos == __last ? *(__last - 1) : *pos;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>3. hashtable 的空间配置</h2>

<h4>节点空间配置</h4>

<p>首先只考虑比较简单的情况，即哈希表的大小不需要调整，此时空间配置主要是链表节点的配置，而 hashtable 使用 vector 作为容器，链表节点的空间配置（分配和释放）如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef simple_alloc&lt;_Node, _Alloc&gt; _M_node_allocator_type;
</span><span class='line'>_Node* _M_get_node() { return _M_node_allocator_type::allocate(1); } // 分配一个节点的空间
</span><span class='line'>void _M_put_node(_Node* __p) { _M_node_allocator_type::deallocate(__p, 1); } // 释放一个节点的空间
</span><span class='line'>_Node* _M_new_node(const value_type& __obj) {
</span><span class='line'>  _Node* __n = _M_get_node();
</span><span class='line'>  __n-&gt;_M_next = 0;
</span><span class='line'>  __STL_TRY {
</span><span class='line'>      construct(&__n-&gt;_M_val, __obj);
</span><span class='line'>      return __n;
</span><span class='line'>  }
</span><span class='line'>  __STL_UNWIND(_M_put_node(__n));
</span><span class='line'>}
</span><span class='line'>void _M_delete_node(_Node* __n) {
</span><span class='line'>  destroy(&__n-&gt;_M_val);
</span><span class='line'>  _M_put_node(__n);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>插入操作表格重新整理</h4>

<p>哈希表的插入操作有两个问题要考虑，一个是 是否允许插入相同键值的元素，另一个是 是否需要扩充表的大小。在 STL 中，首先是判断新插入一个元素后是否需要扩充，判断的条件是插入后元素的个数大于当前哈希表的大小；而是否允许元素重复则通过提供 <code>insert_unique</code> 和 <code>insert_equal</code> 来解决。相关代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pair&lt;iterator, bool&gt; insert_unique(const value_type& __obj) { 
</span><span class='line'>  resize(_M_num_elements + 1); // 先进行扩充（如有必要）
</span><span class='line'>  return insert_unique_noresize(__obj); // 然后插入
</span><span class='line'>}
</span><span class='line'>iterator insert_equal(const value_type& __obj) {
</span><span class='line'>  resize(_M_num_elements + 1);
</span><span class='line'>  return insert_equal_noresize(__obj);
</span><span class='line'>}
</span><span class='line'>void hashtable&lt;_Val,_Key,_HF,_Ex,_Eq,_All&gt;::resize(size_type __num_elements_hint) { // 扩充表格
</span><span class='line'>  const size_type __old_n = _M_buckets.size();
</span><span class='line'>  if (__num_elements_hint &gt; __old_n) { // 判断是否需要扩充
</span><span class='line'>    const size_type __n = _M_next_size(__num_elements_hint); // 下一个质数
</span><span class='line'>    if (__n &gt; __old_n) {
</span><span class='line'>      vector&lt;_Node*, _All&gt; __tmp(__n, (_Node*)(0), _M_buckets.get_allocator()); // 新的buckets
</span><span class='line'>      __STL_TRY {
</span><span class='line'>        for (size_type __bucket = 0; __bucket &lt; __old_n; ++__bucket) { // 遍历旧的buckets
</span><span class='line'>          _Node* __first = _M_buckets[__bucket];
</span><span class='line'>          while (__first) { // 处理每一个链表
</span><span class='line'>            size_type __new_bucket = _M_bkt_num(__first-&gt;_M_val, __n); // 确定当前节点落在新buckets中的位置
</span><span class='line'>            _M_buckets[__bucket] = __first-&gt;_M_next; // 指向下一个节点
</span><span class='line'>            __first-&gt;_M_next = __tmp[__new_bucket]; // 在新buckets的新索引位置头部插入
</span><span class='line'>            __tmp[__new_bucket] = __first;
</span><span class='line'>            __first = _M_buckets[__bucket]; // 指向旧链表下一个节点
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>        _M_buckets.swap(__tmp); // 交换新旧buckets，退出后临时buckets __tmp 自动释放
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>template &lt;class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All&gt;
</span><span class='line'>pair&lt;typename hashtable&lt;_Val,_Key,_HF,_Ex,_Eq,_All&gt;::iterator, bool&gt; 
</span><span class='line'>hashtable&lt;_Val,_Key,_HF,_Ex,_Eq,_All&gt;::insert_unique_noresize(const value_type& __obj) { // 不允许键值重复
</span><span class='line'>  const size_type __n = _M_bkt_num(__obj);
</span><span class='line'>  _Node* __first = _M_buckets[__n];
</span><span class='line'>  for (_Node* __cur = __first; __cur; __cur = __cur-&gt;_M_next) 
</span><span class='line'>    if (_M_equals(_M_get_key(__cur-&gt;_M_val), _M_get_key(__obj))) // 判断是否存在重复的key
</span><span class='line'>      return pair&lt;iterator, bool&gt;(iterator(__cur, this), false); 
</span><span class='line'>  _Node* __tmp = _M_new_node(__obj);
</span><span class='line'>  __tmp-&gt;_M_next = __first;
</span><span class='line'>  _M_buckets[__n] = __tmp;
</span><span class='line'>  ++_M_num_elements;
</span><span class='line'>  return pair&lt;iterator, bool&gt;(iterator(__tmp, this), true);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>允许键值重复的插入操作类似的，只是为了确保相同键值的挨在一起，先要找到相同键值的位置，然后插入。</p>

<h4>整体复制和清空</h4>

<p>复制和清空时分别涉及空间的分配和释放，所以在这里也介绍一下。首先是复制操作，需要先将目标 hashtable 清空，然后将源 hashtable 的 buckets 中的每个链表一一复制，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All&gt;
</span><span class='line'>void hashtable&lt;_Val,_Key,_HF,_Ex,_Eq,_All&gt;::_M_copy_from(const hashtable& __ht) {
</span><span class='line'>  _M_buckets.clear(); // 先清空目标 hashtable
</span><span class='line'>  _M_buckets.reserve(__ht._M_buckets.size()); // 大小重置为源 hashtable 的大小
</span><span class='line'>  _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0); // 将目标 hashtable 的 buckets 置空
</span><span class='line'>  __STL_TRY {
</span><span class='line'>    for (size_type __i = 0; __i &lt; __ht._M_buckets.size(); ++__i) { // 遍历 buckets
</span><span class='line'>      const _Node* __cur = __ht._M_buckets[__i];
</span><span class='line'>      if (__cur) {
</span><span class='line'>        _Node* __copy = _M_new_node(__cur-&gt;_M_val);
</span><span class='line'>        _M_buckets[__i] = __copy;
</span><span class='line'>        for (_Node* __next = __cur-&gt;_M_next; __next; __cur = __next,
</span><span class='line'>              __next = __cur-&gt;_M_next) { // 复制每个节点
</span><span class='line'>          __copy-&gt;_M_next = _M_new_node(__next-&gt;_M_val);
</span><span class='line'>          __copy = __copy-&gt;_M_next;
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    _M_num_elements = __ht._M_num_elements;
</span><span class='line'>  }
</span><span class='line'>  __STL_UNWIND(clear());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. hashtable 的迭代器</h2>

<p>hashtable 的迭代器是前向的单向迭代器，遍历的方式是先遍历完一个 list 然后切换到下一个 bucket 指向的 list 进行遍历。以下是 hashtable 的迭代器的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc&gt;
</span><span class='line'>struct _Hashtable_iterator {
</span><span class='line'>  typedef hashtable&lt;_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc&gt; _Hashtable;
</span><span class='line'>  typedef _Hashtable_iterator&lt;_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc&gt; iterator;
</span><span class='line'>  typedef _Hashtable_const_iterator&lt;_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc&gt; const_iterator;
</span><span class='line'>  typedef _Hashtable_node&lt;_Val&gt; _Node;
</span><span class='line'>
</span><span class='line'>  _Node* _M_cur; // 指向当前节点
</span><span class='line'>  _Hashtable* _M_ht; // 指向当前节点所在 bucket
</span><span class='line'>
</span><span class='line'>  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) : _M_cur(__n), _M_ht(__tab) {}
</span><span class='line'>  _Hashtable_iterator() {}
</span><span class='line'>  reference operator*() const { return _M_cur-&gt;_M_val; }
</span><span class='line'>  iterator& operator++();
</span><span class='line'>  iterator operator++(int);
</span><span class='line'>  bool operator==(const iterator& __it) const { return _M_cur == __it._M_cur; }
</span><span class='line'>  bool operator!=(const iterator& __it) const { return _M_cur != __it._M_cur; }
</span><span class='line'>};
</span><span class='line'>template &lt;class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All&gt;
</span><span class='line'>_Hashtable_iterator&lt;_Val,_Key,_HF,_ExK,_EqK,_All&gt;&
</span><span class='line'>_Hashtable_iterator&lt;_Val,_Key,_HF,_ExK,_EqK,_All&gt;::operator++(){
</span><span class='line'>  const _Node* __old = _M_cur;
</span><span class='line'>  _M_cur = _M_cur-&gt;_M_next;
</span><span class='line'>  if (!_M_cur) { // 到了当前 bucket 的尾部
</span><span class='line'>    size_type __bucket = _M_ht-&gt;_M_bkt_num(__old-&gt;_M_val);
</span><span class='line'>    while (!_M_cur && ++__bucket &lt; _M_ht-&gt;_M_buckets.size())
</span><span class='line'>      _M_cur = _M_ht-&gt;_M_buckets[__bucket];
</span><span class='line'>  }
</span><span class='line'>  return *this;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>5. 哈希函数</h2>

<p>在第三节中介绍 hashtable 的数据结构时，提到了一个哈希函数类型的模板参数，从键值到索引位置的映射由这个哈希函数来完成，实际中是通过函数 <code>_M_bkt_num_key</code> 来完成这个映射的，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>size_type _M_bkt_num_key(const key_type& __key) const {
</span><span class='line'>  return _M_bkt_num_key(__key, _M_buckets.size());
</span><span class='line'>}
</span><span class='line'>size_type _M_bkt_num_key(const key_type& __key, size_t __n) const {
</span><span class='line'>  return _M_hash(__key) % __n; // 在这里调用函数 _M_hash，实现映射
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的 <code>_M_hash</code> 是一个哈希函数类型的成员，可以看做是一个函数指针，真正的函数的定义在 <code>&lt;stl_hash_fun.h&gt;</code> 中，针对 char，int，long 等整数型别，这里大部分的 hash function 什么也没做，只是重视返回原始值，但对字符串（const char* ）设计了一个转换函数，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Key&gt; struct hash { }; // 仿函数 hash
</span><span class='line'>inline size_t __stl_hash_string(const char* __s) { // 将字符串映射为整型
</span><span class='line'>  unsigned long __h = 0; 
</span><span class='line'>  for ( ; *__s; ++__s)
</span><span class='line'>    __h = 5*__h + *__s;
</span><span class='line'>  return size_t(__h);
</span><span class='line'>}
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;char*&gt; {
</span><span class='line'>  size_t operator()(const char* __s) const { return __stl_hash_string(__s); } // 函数调用操作符 operator()
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;const char*&gt; {
</span><span class='line'>  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;char&gt; {
</span><span class='line'>  size_t operator()(char __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;unsigned char&gt; {
</span><span class='line'>  size_t operator()(unsigned char __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;signed char&gt; {
</span><span class='line'>  size_t operator()(unsigned char __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;short&gt; {
</span><span class='line'>  size_t operator()(short __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;unsigned short&gt; {
</span><span class='line'>  size_t operator()(unsigned short __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;int&gt; {
</span><span class='line'>  size_t operator()(int __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;unsigned int&gt; {
</span><span class='line'>  size_t operator()(unsigned int __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;long&gt; {
</span><span class='line'>  size_t operator()(long __x) const { return __x; }
</span><span class='line'>};
</span><span class='line'>__STL_TEMPLATE_NULL struct hash&lt;unsigned long&gt; {
</span><span class='line'>  size_t operator()(unsigned long __x) const { return __x; }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>关于函数调用操作符的更多介绍，可以参见我的另一篇文章 【<a href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/">C语言函数指针与C++函数调用操作符</a>】。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.3) 关联式容器之map和multimap]]></title>
    <link href="http://ibillxia.github.io/blog/2014/08/31/insight-into-stl-4-associative-containers-3-map-and-multimap/"/>
    <updated>2014-08-31T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/08/31/insight-into-stl-4-associative-containers-3-map-and-multimap</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_map.h</code>、<code>stl_multimap.h</code>、<code>stl_pair.h</code>、<code>map.h</code>、 <code>multimap.h</code>、 <code>map</code>  等文件。</p>

<h2>1. map 简介</h2>

<p>map 的特性是，所有元素都是键值对，用一个 pair 表示，pair 的第一个元素是键值（key），第二个元素是实值（value），map 不允许两个元素的键值相同。<br/>
与 set 类似的，map 也不允许修改 key 的值，但不同的是可以修改 value 的值，因此 map 的迭代器既不是一种 constant iterators，也不是一种 mutable iterators。同样的，map的插入和删除操作不影响操作之前定义的迭代器的使用（被删除的那个元素除外）。<br/>
与 set 不同的是，map 没有交、并、差等运算，只有插入、删除、查找、比较等基本操作。</p>

<h2>2. map 的实现</h2>

<p>由于 map 的元素是键值对，用 pair 表示，下面是它的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _T1, class _T2&gt;
</span><span class='line'>struct pair {
</span><span class='line'>  typedef _T1 first_type;
</span><span class='line'>  typedef _T2 second_type;
</span><span class='line'>  _T1 first; // 两个成员 first 和 second
</span><span class='line'>  _T2 second;
</span><span class='line'>  pair() : first(_T1()), second(_T2()) {} // 构造函数
</span><span class='line'>  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {} // 拷贝构造函数
</span><span class='line'>};
</span><span class='line'>template &lt;class _T1, class _T2&gt;
</span><span class='line'>inline bool operator==(const pair&lt;_T1, _T2&gt;& __x, const pair&lt;_T1, _T2&gt;& __y) { // 相等比较
</span><span class='line'>  return __x.first == __y.first && __x.second == __y.second; 
</span><span class='line'>}
</span><span class='line'>template &lt;class _T1, class _T2&gt;
</span><span class='line'>inline bool operator&lt;(const pair&lt;_T1, _T2&gt;& __x, const pair&lt;_T1, _T2&gt;& __y) { // 大小比较
</span><span class='line'>  return __x.first &lt; __y.first || (!(__y.first &lt; __x.first) && __x.second &lt; __y.second); 
</span><span class='line'>}
</span><span class='line'>template &lt;class _T1, class _T2&gt;
</span><span class='line'>inline pair&lt;_T1, _T2&gt; make_pair(const _T1& __x, const _T2& __y) { // 创建一个 pair
</span><span class='line'>  return pair&lt;_T1, _T2&gt;(__x, __y);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<!-- more -->


<p>然后是 map 的定义，大体上和 set 差不多，只是在使用 RB-tree 作为容器时，传入的模板参数是一个 pair，主要代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Key, class _Tp, class _Compare, class _Alloc&gt;
</span><span class='line'>class map {
</span><span class='line'>public:
</span><span class='line'>  typedef _Key                  key_type;
</span><span class='line'>  typedef _Tp                   data_type;
</span><span class='line'>  typedef _Tp                   mapped_type;
</span><span class='line'>  typedef pair&lt;const _Key, _Tp&gt; value_type;
</span><span class='line'>  typedef _Compare              key_compare;
</span><span class='line'>  // 一个用于键值比较的内部类
</span><span class='line'>  class value_compare : public binary_function&lt;value_type, value_type, bool&gt; {
</span><span class='line'>  friend class map&lt;_Key,_Tp,_Compare,_Alloc&gt;;
</span><span class='line'>  protected :
</span><span class='line'>    _Compare comp;
</span><span class='line'>    value_compare(_Compare __c) : comp(__c) {}
</span><span class='line'>  public:
</span><span class='line'>    bool operator()(const value_type& __x, const value_type& __y) const {
</span><span class='line'>      return comp(__x.first, __y.first);
</span><span class='line'>    }
</span><span class='line'>  };
</span><span class='line'>private:
</span><span class='line'>  typedef _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;, 
</span><span class='line'>    key_compare, _Alloc&gt; _Rep_type; // 这里的value_type是一个pair&lt;const _Key, _Tp&gt;
</span><span class='line'>  _Rep_type _M_t;  // 用红黑树作为底层容器
</span><span class='line'>public:
</span><span class='line'>  map() : _M_t(_Compare(), allocator_type()) {} // 默认构造函数
</span><span class='line'>  bool empty() const { return _M_t.empty(); } // 判断是否为空
</span><span class='line'>  size_type size() const { return _M_t.size(); } // 获取元素个数
</span><span class='line'>  map(const value_type* __first, const value_type* __last)
</span><span class='line'>    : _M_t(_Compare(), allocator_type())
</span><span class='line'>    { _M_t.insert_unique(__first, __last); } // 构造函数，使用insert_unique，键值不允许重复
</span><span class='line'>  void insert(const value_type* __first, const value_type* __last) { // 插入操作
</span><span class='line'>    _M_t.insert_unique(__first, __last);
</span><span class='line'>  }
</span><span class='line'>  void erase(iterator __position) { _M_t.erase(__position); } // 删除操作
</span><span class='line'>  iterator find(const key_type& __x) { return _M_t.find(__x); } // 查找操作
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>可以看到，基本也是对底层容器 RB-tree 的一个简单的封装。</p>

<h2>3. multimap</h2>

<p>multimap 与 map 的关系和 multiset 与 set 的关系一样，即 multimap 允许键值（key）重复，插入操作使用 RB-tree 的 <code>insert_equal</code> ，其他都和 map 一样，这里就不贴源代码了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.2) 关联式容器之set和multiset]]></title>
    <link href="http://ibillxia.github.io/blog/2014/08/17/insight-into-stl-4-associative-containers-2-set-and-multiset/"/>
    <updated>2014-08-17T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/08/17/insight-into-stl-4-associative-containers-2-set-and-multiset</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要有 <code>stl_set.h</code>、 <code>stl_multiset.h</code>、 <code>set.h</code>、 <code>multiset.h</code>、 <code>set</code> 等文件。</p>

<h2>1. set 简介</h2>

<p>set 即集合，相比于其他容器有些特别。首先是它的每个元素是唯一的，即不允许有相同的值出现。其次，作为一种关联容器，set 的元素不像 map 那样可以同时拥有实值（value）和键值（key），set 元素的键值就是实值，实值就是键值。<br/>
由于 set 的实质和键值相同，共用同一个内存空间，而 set 的底层容器为红黑树（中序遍历有序），因此不能对其键值进行修改，否则会破坏其有序特性。为避免非法修改操作，在SGI STL的实现中，<code>set&lt;T&gt;::iterator</code> 被定义为 RB-tree 底层的 const_iterator，_杜绝写入操作。set 与 list 有一个相似的地方是，元素插入、删除后，之前的迭代器依然有效（被删除的那个元素的迭代器除外）。<br/>
我们知道集合有一些特殊的操作，诸如并、交、差等，在STL的 set 中，默认也提供了这些操作，如交集 <code>set_intersection</code> 、联集 <code>set_union</code> 、差集 <code>set_difference</code> 和对称差集 <code>set_symmetric_difference</code> 等。与之前那些线性容器不同的是，这些 set 的操作并不是在 set 内部实现的，而是放在了算法模块（algorithm）中，其具体实现在后面的算法章节中会具体介绍。</p>

<h2>2. set 的实现</h2>

<p>前面多次提到 set 的底层采用 RB-tree 容器，这是因为 RB-tree 是一种比较高效的平衡二叉搜索树，能够很好的满足元素值唯一的条件，而且查找效率高。由于 RB-tree 已实现了很多操作，因此 set 基本上只是对 RB-tree 进行了一层简单的封装。下面是其实现的主要代码：</p>

<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Key, class _Compare, class _Alloc&gt;
</span><span class='line'>class set {
</span><span class='line'>public:
</span><span class='line'>  typedef _Key     key_type;
</span><span class='line'>  typedef _Key     value_type; // 实值与键值同类型
</span><span class='line'>private:
</span><span class='line'>  typedef _Rb_tree&lt;key_type, value_type, _Identity&lt;value_type&gt;, key_compare, _Alloc&gt; _Rep_type;
</span><span class='line'>  _Rep_type _M_t;  // 底层使用红黑树作为容器
</span><span class='line'>  set() : _M_t(_Compare(), allocator_type()) {} // 默认构造函数
</span><span class='line'>  set(const set&lt;_Key,_Compare,_Alloc&gt;& __x) : _M_t(__x._M_t) {}  // 拷贝构造函数
</span><span class='line'>  pair&lt;iterator,bool&gt; insert(const value_type& __x) { // 插入操作
</span><span class='line'>    pair&lt;typename _Rep_type::iterator, bool&gt; __p = _M_t.insert_unique(__x); 
</span><span class='line'>    return pair&lt;iterator, bool&gt;(__p.first, __p.second);
</span><span class='line'>  }
</span><span class='line'>  void erase(iterator __position) { // 删除操作
</span><span class='line'>    typedef typename _Rep_type::iterator _Rep_iterator;
</span><span class='line'>    _M_t.erase((_Rep_iterator&)__position); 
</span><span class='line'>  }
</span><span class='line'>  void clear() { _M_t.clear(); } // 清空操作
</span><span class='line'>  iterator find(const key_type& __x) const { return _M_t.find(__x); } // 查找
</span><span class='line'>  size_type count(const key_type& __x) const { // 计数
</span><span class='line'>    return _M_t.find(__x) == _M_t.end() ? 0 : 1;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>template &lt;class _Key, class _Compare, class _Alloc&gt;
</span><span class='line'>inline bool operator==(const set&lt;_Key,_Compare,_Alloc&gt;& __x, 
</span><span class='line'>                       const set&lt;_Key,_Compare,_Alloc&gt;& __y) { // 比较相等操作符
</span><span class='line'>  return __x._M_t == __y._M_t;
</span><span class='line'>}
</span><span class='line'>template &lt;class _Key, class _Compare, class _Alloc&gt;
</span><span class='line'>inline bool operator&lt;(const set&lt;_Key,_Compare,_Alloc&gt;& __x, 
</span><span class='line'>                      const set&lt;_Key,_Compare,_Alloc&gt;& __y) { // 比较大小操作符
</span><span class='line'>  return __x._M_t &lt; __y._M_t;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到基本都是调用 <code>_M_t</code> 的方法来实现的，而这里的 <code>_M_t</code> 是一个红黑树对象。</p>

<h2>3. multiset</h2>

<p>multiset 的特性和用法与 set 基本相同，唯一差别在于它允许有重复的键值，因此它的插入操作使用的底层机制是 RB-tree 的 <code>insert_equal()</code> 而不是 <code>insert_unique()</code> ，下面是 multiset 的主要代码，主要列出了与 set 不同的部分。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Key, class _Compare, class _Alloc&gt;
</span><span class='line'>class multiset {
</span><span class='line'>public:
</span><span class='line'>  multiset(const value_type* __first, const value_type* __last)
</span><span class='line'>    : _M_t(_Compare(), allocator_type())
</span><span class='line'>    { _M_t.insert_equal(__first, __last); } // 构造函数
</span><span class='line'>  iterator insert(const value_type& __x) { // 插入操作
</span><span class='line'>    return _M_t.insert_equal(__x);
</span><span class='line'>  }
</span><span class='line'>  iterator insert(iterator __position, const value_type& __x) {
</span><span class='line'>    typedef typename _Rep_type::iterator _Rep_iterator;
</span><span class='line'>    return _M_t.insert_equal((_Rep_iterator&)__position, __x);
</span><span class='line'>  }
</span><span class='line'>  void insert(const value_type* __first, const value_type* __last) {
</span><span class='line'>    _M_t.insert_equal(__first, __last);
</span><span class='line'>  }
</span><span class='line'>  void insert(const_iterator __first, const_iterator __last) {
</span><span class='line'>    _M_t.insert_equal(__first, __last);
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其他部分基本与 set 一样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.1) 关联式容器之红黑树]]></title>
    <link href="http://ibillxia.github.io/blog/2014/08/03/insight-into-stl-4-associative-containers-1-red-black-tree/"/>
    <updated>2014-08-03T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/08/03/insight-into-stl-4-associative-containers-1-red-black-tree</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_tree.h</code> 这个文件。</p>

<h2>0. 关联式容器</h2>

<p>之前几篇文章详细介绍了SGI STL中序列式容器的实现，并提到过STL中还有一类关联式的容器。标准的STL管理师容器分为 set（集合）和map（映射表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表），这些容器的底层机制均以RB-Tree（红黑树）完成。RB-Tree是一种非常高效的数据结构，它本质上是一种平衡的二叉搜索树，因而其查找的平均时间复杂度为元素总个数的对数（即logN）。在STL中RB-Tree是一个独立的容器，但并没有对用户的公开接口，仅提供给STL的set和map使用。<br/>
SGI STL在标准STL之外，还提供了一类关联式容器——hash table（哈希表），以及以此为低层机制的hash set（散列集合）、hash map（散列映射表）、hash multiset（散列多键集合）和hash multimap（散列多键映射表）。相比于RB-Tree，hash table的时间效率更高，插入、删除、查找的时间复杂度均为常数时间，但需要比元素总个数多得多的空间。<br/>
本文接下来主要介绍树及RB-Tree相关的内容，后续文章将具体介绍SGI STL中set、map、hash table的实现。</p>

<h2>1. 树与二叉搜索树</h2>

<p>树是一种非常常见而且实用的数据结构，几乎所有的操作系统都将文件存放在树状结构里，几乎所有编译器需要实现一个表达式树（expression tree），文件压缩所用的哈夫曼算法也需要用到树状结构，数据库所使用的B-tree则是一种相当复杂的树状结构。<br/>
关于树的一些基本概念相信大家都比较熟悉，这里就不赘述了，如果需要可以google或看wikipedia，这里重点重温一下数据结构里的二叉搜索树、平衡二叉搜索树、AVL树。<br/>
<strong>二叉搜索树</strong>：任何节点的键值大于其<strong>左子树</strong>中<strong>每一个</strong>节点的键值，并小于其<strong>右子树</strong>中的<strong>每一个</strong>节点的键值。根据二叉搜索树的定义可知，按照中序遍历该树可以得到一个有序的序列。平均情况下，二叉搜索树可以提供对数时间的插入和访问。其插入和查找的算法也很简单，每次与根节点的键值进行比较，小于根节点的键值则往根节点的左子树插入或查找，大于则往右子树插入或查找，无论是递归实现还是非递归实现都很简单。<br/>
<strong>平衡二叉搜索树</strong>：上面提到二叉搜索数的<strong>平均</strong>性能为对数时间，这是因为二叉搜索树的深度与数据插入的顺序有关，如果插入的数据本身就比较有序，那么就会产生一个深度过大的树，甚至会退化为一个链表的结构，这中情况下，其查找的效率就是线性时间了。平衡二叉搜索树就是为了解决这个问题而产生的，“平衡”的意义是，没有任何一个节点过深。不同的平衡条件造就出不同的效率表现，以及不同的实现复杂度，如 <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL-Tree</a>、<a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">RB-Tree</a>、<a href="http://en.wikipedia.org/wiki/AA_tree">AA-Tree</a> _等。他们都比简单的二叉搜索树要复杂，特别是插入和删除操作，但他们可以避免高度不平衡的情况，因而查找时间较快。</p>

<!-- more -->


<p><strong>AVL树</strong>：AVL-tree（Adelson-Velskii-Landis tree）是一个加上了“额外平衡条件”的二叉搜索树，是一种高度平衡的二叉搜索树，它的这个额外的条件为：任何节点的左右子树高度相差最多1。该条件能够保证整棵树的高度为logN，但其插入和删除的操作也相对比较复杂，因为这些操作可能导致树的失衡，需要调整（或旋转）树的结构，使其保持平衡。插入时出现失衡的情况有如下四种（其中X为最小失衡子树的根节点）：</p>

<blockquote><ol>
<li>插入点位于X的左子节点的左子树——左左；</li>
<li>插入点位于X的左子节点的右子树——左右；</li>
<li>插入点位于X的右子节点的左子树——右左；</li>
<li>插入点位于X的右子节点的右子树——右右。</li>
</ol>
</blockquote>

<p>情况1和4对称，称为外侧插入，可以采用单旋转操作调整恢复平衡；2和3对称，称为内侧插入，可以采用双旋转操作调整恢复平衡：先经过一次旋转变成左左或右右，然后再经过一次旋转恢复平衡。1和2的实例如下图：<br/>
<img src="http://ibillxia.github.io/images/2014/IMAG2014080301.jpg"><br/>
图中从中间到最右情况1的恢复平衡的旋转方法，只是其中节点3为新插入的元素；而最左到最右是情况2的恢复平衡的旋转方法，其中节点4为新插入的元素。情况3和4分别与2和1对称，其调整方法也很类似，就不赘述了。<br/>
RB-tree是另一种被广泛使用的平衡二叉搜索树，也是SGI STL唯一实现的一种搜索树，作为关联式容器的底层容器。RB-tree的平衡条件不同于AVL-tree，但同样运用了单旋转和双旋转的恢复平衡的机制，下面我们详细介绍RB-tree的实现。</p>

<h2>2. RB-tree的定义及数据结构</h2>

<p>所谓RB-tree，不仅仅是一个二叉搜索树，而且必须满足以下规则：</p>

<blockquote><ol>
<li>每个节点不是红色就是黑色；</li>
<li>根节点为黑色；</li>
<li>每个叶子节点（NIL）为黑色；</li>
<li>如果节点为红，其左右子节点必为黑；</li>
<li>对每个节点，从该节点到其子孙中的叶子节点的所有路径上所包含的黑节点数目相同。</li>
</ol>
</blockquote>

<p>上面的这些约束保证了这个树大致上是平衡的，这也决定了红黑树的插入、删除、查询等操作是比较快速的。 根据规则5，新增节点必须为红色；根据规则4，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形。下图是一个典型的RB-tree（来自wiki）：<br/>
<img src="http://ibillxia.github.io/images/2014/IMAG2014080302.png"><br/>
SGI STL中RB-tree的数据结构比较简单，其中每个节点的数据结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef bool _Rb_tree_Color_type;
</span><span class='line'>const _Rb_tree_Color_type _S_rb_tree_red = false;
</span><span class='line'>const _Rb_tree_Color_type _S_rb_tree_black = true;
</span><span class='line'>//======================================
</span><span class='line'>struct _Rb_tree_node_base { // 节点的定义
</span><span class='line'>  typedef _Rb_tree_Color_type _Color_type;
</span><span class='line'>  typedef _Rb_tree_node_base* _Base_ptr;
</span><span class='line'>  _Color_type _M_color; // 节点颜色，实际为一个bool型变量
</span><span class='line'>  _Base_ptr _M_parent; // 指向父节点，方便遍历
</span><span class='line'>  _Base_ptr _M_left;
</span><span class='line'>  _Base_ptr _M_right;
</span><span class='line'>
</span><span class='line'>  static _Base_ptr _S_minimum(_Base_ptr __x) {
</span><span class='line'>    while (__x-&gt;_M_left != 0) __x = __x-&gt;_M_left;
</span><span class='line'>    return __x;
</span><span class='line'>  }
</span><span class='line'>  static _Base_ptr _S_maximum(_Base_ptr __x) {
</span><span class='line'>    while (__x-&gt;_M_right != 0) __x = __x-&gt;_M_right;
</span><span class='line'>    return __x;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>//======================================
</span><span class='line'>template &lt;class _Value&gt; struct _Rb_tree_node : public _Rb_tree_node_base { // 节点的定义
</span><span class='line'>  typedef _Rb_tree_node&lt;_Value&gt;* _Link_type;
</span><span class='line'>  _Value _M_value_field;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其中每个节点主要包含一个标志颜色的bool变量 <code>_M_color</code>，3个节点指针 <code>_M_parent</code> , <code>_M_left</code> , <code>_M_right</code>，2个成员函数 <code>_S_minimum</code> 和 <code>_S_maximum</code> （分别求取最小（最左）、最大（最右）节点）。<br/>
而RB-tree的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; struct _Rb_tree_base { // RB-tree的定义
</span><span class='line'>  typedef _Alloc allocator_type;
</span><span class='line'>  allocator_type get_allocator() const { return allocator_type(); }
</span><span class='line'>  _Rb_tree_base(const allocator_type&)  : _M_header(0) { _M_header = _M_get_node(); } // 构造函数
</span><span class='line'>  ~_Rb_tree_base() { _M_put_node(_M_header); } // 析构函数
</span><span class='line'>protected:
</span><span class='line'>  _Rb_tree_node&lt;_Tp&gt;* _M_header; // 根节点
</span><span class='line'>  typedef simple_alloc&lt;_Rb_tree_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type; // 空间配置器
</span><span class='line'>  _Rb_tree_node&lt;_Tp&gt;* _M_get_node()  { return _Alloc_type::allocate(1); } // 分配一个节点的空间
</span><span class='line'>  void _M_put_node(_Rb_tree_node&lt;_Tp&gt;* __p) { _Alloc_type::deallocate(__p, 1); } // 释放__p节点的空间
</span><span class='line'>};
</span><span class='line'>//======================================
</span><span class='line'>template &lt;class _Key, class _Value, class _KeyOfValue, class _Compare,
</span><span class='line'>          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) &gt;
</span><span class='line'>class _Rb_tree : protected _Rb_tree_base&lt;_Value, _Alloc&gt; {
</span><span class='line'>  typedef _Rb_tree_base&lt;_Value, _Alloc&gt; _Base;
</span><span class='line'>// ... 
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>可以看到RB-tree的空间配置器是 <code>simple_alloc</code> 配置器，按 <code>_Rb_tree_node</code> 节点大小分配空间，每次分配或释放一个节点的空间。</p>

<h2>3. RB-tree的迭代器</h2>

<p>要将RB-tree实现为一个泛型容器并用作set、map的低层容器，迭代器的设计是一个关键。RB-tree的迭代器是一个双向迭代器，但不具备随机访问能力，其引用（dereference）和访问（access）操作与list十分类似，较为特殊的是自增（operator++）和自减（operator&#8211;）操作，这里的自增/自减操作是指将迭代器移动到RB-tree按键值大小排序后当前节点的下一个/上一个节点，也即按中序遍历RB-tree时当前节点的下一个/上一个节点。RB-tree的迭代器的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct _Rb_tree_base_iterator {
</span><span class='line'>  typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
</span><span class='line'>  typedef bidirectional_iterator_tag iterator_category;
</span><span class='line'>  void _M_increment()  { }
</span><span class='line'>  void _M_decrement()  { }
</span><span class='line'>};
</span><span class='line'>template &lt;class _Value, class _Ref, class _Ptr&gt;
</span><span class='line'>struct _Rb_tree_iterator : public _Rb_tree_base_iterator {
</span><span class='line'>  _Self& operator++() { _M_increment(); return *this; }
</span><span class='line'>  _Self& operator--() { _M_decrement(); return *this; }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>可以看到RB-tree的自增和自减操作是使用基迭代器的increment和decrement来实现的，这里仅分析自增操作的实现（自减操作类似的）。RB-tree的自增操作实际上是寻找中序遍历下当前节点的后一个节点，其代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  void _M_increment()  { // 自增操作，中序遍历的下一个节点
</span><span class='line'>    if (_M_node-&gt;_M_right != 0) { // 当前节点有右子树
</span><span class='line'>      _M_node = _M_node-&gt;_M_right;
</span><span class='line'>      while (_M_node-&gt;_M_left != 0) // 右子树的最左节点即为所求
</span><span class='line'>        _M_node = _M_node-&gt;_M_left;
</span><span class='line'>    } else { // 当前节点没有右子树，找父节点且父节点的右子树不包含当前节点的祖先节点
</span><span class='line'>      _Base_ptr __y = _M_node-&gt;_M_parent;
</span><span class='line'>      while (_M_node == __y-&gt;_M_right) { // 当前节点在父节点的右子树中就继续往父节点的父节点找
</span><span class='line'>        _M_node = __y;
</span><span class='line'>        __y = __y-&gt;_M_parent;
</span><span class='line'>      }
</span><span class='line'>      if (_M_node-&gt;_M_right != __y)
</span><span class='line'>        _M_node = __y;
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>
下面几节主要介绍一下RB-tree的基本操作。</p>

<h2>4. RB-tree的插入操作</h2>

<h4>4.1 基本插入操作</h4>

<p>RB-tree提供两种插入操作，<code>insert_unique()</code> 和 <code>insert_equal()</code>，顾名思义，前者表示被插入的节点的键值在树中是唯一的（如果已经存在，就不需要插入了），后者表示可以存在键值相同的节点。这两个函数都有多个版本，下面以后者的最简单版本（单一参数：被插入的节点的键值）为实例进行介绍。下面是 <code>insert_equal</code> 的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt; ::insert_equal(const _Value& __v) {
</span><span class='line'>  _Link_type __y = _M_header;
</span><span class='line'>  _Link_type __x = _M_root(); // 从根节点开始
</span><span class='line'>  while (__x != 0) { // 往下寻找插入点
</span><span class='line'>    __y = __x;
</span><span class='line'>    // 比较，当前节点的键值比插入值大往左子树找，否则往右子树找
</span><span class='line'>    __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? _S_left(__x) : _S_right(__x); 
</span><span class='line'>  }
</span><span class='line'>  return _M_insert(__x, __y, __v); // 真正的插入操作，x为新插入节点，y为x的父节点，v为新值
</span><span class='line'>}
</span><span class='line'>//真正的插入操作，主要是对RB-tree及新节点的成员变量的设置
</span><span class='line'>_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt; ::_M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Value& __v) {
</span><span class='line'>  _Link_type __x = (_Link_type) __x_;
</span><span class='line'>  _Link_type __y = (_Link_type) __y_;
</span><span class='line'>  _Link_type __z;
</span><span class='line'>  if (__y == _M_header || __x != 0 || _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) {
</span><span class='line'>    __z = _M_create_node(__v); // 创建新节点
</span><span class='line'>    _S_left(__y) = __z;     // makes _M_leftmost() = __z, when __y == _M_header
</span><span class='line'>    if (__y == _M_header) { // y为header
</span><span class='line'>      _M_root() = __z;
</span><span class='line'>      _M_rightmost() = __z;
</span><span class='line'>    } else if (__y == _M_leftmost()) // y为最左节点
</span><span class='line'>      _M_leftmost() = __z;  // maintain _M_leftmost() pointing to min node
</span><span class='line'>  } else {
</span><span class='line'>    __z = _M_create_node(__v); // 创建新节点。???为什么不放到if-else上面???
</span><span class='line'>    _S_right(__y) = __z; // 新节点为y的右孩子
</span><span class='line'>    if (__y == _M_rightmost()) // y为最右节点
</span><span class='line'>      _M_rightmost() = __z; // maintain _M_rightmost() pointing to max node
</span><span class='line'>  }
</span><span class='line'>  _S_parent(__z) = __y; // 设定新节点的父节点
</span><span class='line'>  _S_left(__z) = 0;
</span><span class='line'>  _S_right(__z) = 0;
</span><span class='line'>  _Rb_tree_rebalance(__z, _M_header-&gt;_M_parent); // 调整RB-tree使之恢复平衡
</span><span class='line'>  ++_M_node_count;
</span><span class='line'>  return iterator(__z); // 返回指向新节点的迭代器
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>至此新节点插入完成。然而，由于新节点的插入，可能会引起RB-tree的性质4,5的破坏，需要对RB-tree进行旋转并对相关节点重新着色，这都是在 <code>_Rb_tree_rebalance</code> 这个函数中实现的，下面就主要介绍RB-tree是如何恢复平衡。</p>

<h4>4.2 调整RB-tree使之恢复平衡</h4>

<p>RB-tree的调整与AVL-tree类似但更复杂，因为不仅仅需要旋转，还需要考虑节点的颜色是否符合要求。破坏RB-tree性质4的可能起因是插入了一个红色节点、将一个黑色节点变为红色或者是旋转，而破坏性质5的可能原因是插入一个黑色的节点、节点颜色的改变（红变黑或黑变红）或者是旋转。<br/>
在讨论 RB-tree 插入操作之前必须明白一点，那就是新插入的节点的颜色必为红色（调整前），因为插入黑点会增加某条路径上黑结点的数目，从而导致整棵树黑高度的不平衡。但如果新结点的父结点为红色时（如下图所示），将会违反红黑树的性质：一条路径上不能出现父子同为红色结点。这时就需要通过一系列操作来使红黑树保持平衡。为了清楚地表示插入操作以下在结点中使用“N”字表示一个新插入的结点，使用“P”字表示新插入点的父结点，使用“U”字表示“P”结点的兄弟结点，使用“G”字表示“P”结点的父结点。插入操作分为以下几种情况：<br/>
<strong>1）、树为空</strong><br/>
此时，新插入节点为根节点，上面说过新插入节点均为红色，这不符合RB-tree的性质2，只需要将新节点重新改为黑色即可。<br/>
<strong>2）、黑父</strong><br/>
如果新节点的父结点为黑色结点，那么插入一个红点将不会影响红黑树的平衡，此时插入操作完成。红黑树比AVL树优秀的地方之一在于黑父的情况比较常见，从而使红黑树需要旋转的几率相对AVL树来说会少一些。<br/>
<strong>3）、红父</strong><br/>
这种情况就比较复杂。由于父节点为红，所以祖父节点必为黑色。由于新节点和父节点均为红，所以需要重新着色或进行旋转，此时就需要考虑叔父节点的颜色，进而可能需要考虑祖父、祖先节点的颜色。
<strong>3.1）、叔父为红</strong>
只要将父和叔结点变为黑色，将祖父结点变为红色即可，如下图所示：<br/>
<img src="http://ibillxia.github.io/images/2014/IMAG2014080303.png"><br/>
但由于祖父结点的父结点有可能为红色，从而违反红黑树性质。此时必须将祖父结点作为新的判定点<strong>继续向上</strong>（迭代）进行平衡操作。<br/>
<strong>3.2）、叔父为黑</strong><br/>
当叔父结点为黑色时，需要进行旋转，有4中情况（类似AVL），以下图示了所有的旋转可能：<br/>
<img src="http://ibillxia.github.io/images/2014/IMAG2014080304.png"><br/>
可以观察到，当旋转完成后，新的旋转根全部为黑色，此时不需要再向上回溯进行平衡操作，插入操作完成。篇幅原因，相关代码这里就不粘贴出来了，要注意的一点就是case1和case2的变色方案是一样的，虽然从上图中看一个是P由红变黑，一个是N由红变黑，但实际上在case2中，经过一次旋转后，迭代器所指向的节点已经发生改变，这样刚好使得这两个case的变色方案相同，均为P由红变黑而G由黑变红。case3与case4的变色方案也是类似的。</p>

<h2>5. RB-tree的删除操作</h2>

<p>相比于插入操作，RB-tree的删除操作更加复杂。在侯捷的书上并没有讲删除操作，而在算法导论上是有专门的一节内容的，wiki上也有详细的讲述。限于篇幅，这里指讲解一个大概的思路，更详细的介绍请参见wiki或算法导论。RB-tree删除操作的基本思路是这样的，首先按照一般的二叉搜索树进行节点的删除，然后对RB-tree相关节点进行变色或旋转。<br/>
一般的二叉搜索树删除节点的基本思路是：首先找到待删除节点位置，设为D。如果D同时有左右子树，那么用D的后继（右孩子的最左子节点，该后继最多有一个子节点——右孩子）替代D（<strong>注意</strong>：这里的替代是只key的替代，color不变，仍为D的color），从而将删除位置转移到该后继节点（成为新的D，为叶子节点或只有右孩子）。于是，我们只需要讨论删除只有一个儿子的节点的情况(如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子)，设这个儿子节点为N，这仍然需要分三种情况：<br/>
<strong>1）D为红</strong><br/>
这种情况比较简单。由于D为红色，所以它的父亲和儿子一定是黑色的，我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。<br/>
  <strong>2）D为黑且N为红</strong><br/>
如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，可能会破坏性质4，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5，同时也满足性质4。<br/>
<strong>3）D为黑且N为黑</strong><br/>
这是一种复杂的情况。我们首先把要删除的节点D替换为它的（右）儿子N，在新树中（D被N覆盖），设N的父节点为P，兄弟为S，SL为S的左儿子，SR为S的右儿子。此时，以N为根节点的子树的黑高度减少了一，与S为根节点的子树的黑高度不一致，破坏了性质5。为了恢复，可以分为如下情形：<br/>
<strong>3.1）N为根节点</strong><br/>
已经满足所有性质，不需要调整。<br/>
<strong>3.2） N是它父亲P的左儿子</strong><br/>
<strong>case1、S为红色</strong>：将P改为红色，S改为黑色，以P为中心左旋，旋转后<strong>SL为新的S</strong>，SL和SR是新的S的左右孩子，此时case1就转化为了case2或case3或case4；<br/>
注：case2~4中S均为黑色（否则是case1）。<br/>
<strong>case2、SL、SR同为黑色</strong>：将S改为红色，这样黑高度失衡的节点变为P，转到3.1）重新开始判断和调整；<br/>
<strong>case3、SR为黑</strong>：此时SL为红（否则是case2）。将S改为红色，SL改为黑色，然后以S为中心右旋，旋转后SL为新的S，而原S成为SR且为红色，这就将case3变成了case4；<br/>
<strong>case4、SR为红</strong>：以P为中心左旋，然后交换P和S的颜色，最后将SR改为黑色，即可完成调整。可以看到调整过程与SL的颜色无关。<br/>
<strong>3.3）N是它父亲P的右儿子</strong><br/>
与3.2）类似，这里就不详细展开了。</p>

<h2>6. RB-tree的查询操作</h2>

<p>RB-tree是一个二叉搜索树，元素的查询是其拿手项目，非常简单，以下是RB-tree提供的查询操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Key, class _Value, class _KeyOfValue, class _Compare, class _Alloc&gt;
</span><span class='line'>typename _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator 
</span><span class='line'>_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::find(const _Key& __k) {
</span><span class='line'>  _Link_type __y = _M_header;      // Last node which is not less than __k. 
</span><span class='line'>  _Link_type __x = _M_root();      // Current node. 
</span><span class='line'>
</span><span class='line'>  while (__x != 0) // x为NIL时推出循环
</span><span class='line'>    if (!_M_key_compare(_S_key(__x), __k))
</span><span class='line'>      __y = __x, __x = _S_left(__x); // 往左子树找（赋值运算优先于逗号运算，y是x的父节点）
</span><span class='line'>    else
</span><span class='line'>      __x = _S_right(__x); // 往右子树找
</span><span class='line'>
</span><span class='line'>  iterator __j = iterator(__y);   
</span><span class='line'>  return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ? 
</span><span class='line'>     end() : __j; // 没找到返回end()，否则返回相应节点的指针（迭代器）
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>小结</h2>

<p>关于RB-tree基本就介绍到这里了，主要是RB-tree的定义、数据结构、插入删除和查找等基本操作，其中最主要也最困难的就是插入和删除操作中恢复平衡的方法。另外，还介绍了二叉搜索树的基本概念和高度平衡的AVL树，可以看到，AVL树保持平衡的方法非常简单易懂，而RB-tree由于引入了节点的颜色属性，使得理解起来相对比较困难，那么问题就来了，为什么不用AVL-tree而用RB-tree作为set和map的低层容器呢？<br/>
这个问题要问STL的实现者了，其实AVL-tree和RB-tree的平均性能在 <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL-tree的wiki</a> _上是有严格的数学公式的，AVL的平均高度为 $1.44logN$ ，而RB-tree的平均高度为 $2logN$ ，这些数据的来历也有相关的论文，感兴趣的可以更深入的看看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.4) 序列式容器之heap和priority queue]]></title>
    <link href="http://ibillxia.github.io/blog/2014/07/27/stl-source-insight-3-sequential-containers-4-heap-and-priority-queue/"/>
    <updated>2014-07-27T21:31:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/07/27/stl-source-insight-3-sequential-containers-4-heap-and-priority-queue</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>heap</code>、<code>stl_heap.h</code>、<code>heap.h</code>、<code>stl_queue.h</code>、<code>queue</code> 等几个文件。</p>

<h2>1. 概述</h2>

<p>前面分别介绍了三种各具特色的序列式容器 —— vector、list和deque，他们几乎可以涵盖所有类型的序列式容器了，但本文要介绍的heap则是一种比较特殊的容器。其实，在STL中heap并没有被定义为一个容器，而只是一组算法，提供给priority queue（优先队列）。故名思议，priority queue 允许用户以任何次序将元素放入容器内，但取出时一定是从优先权最高的元素开始取，binary max heap（二元大根堆）即具有这样的特性，因此如果学过max-heap再看STL中heap的算法和priority queue 的实现就会比较简单。</p>

<h2>2. priority queue 的数据结构</h2>

<p>要实现priority queue的功能，binary search tree（BST）也可以作为其底层机制，但这样的话元素的插入就需要O(logN)的平均复杂度，而且要求元素的大小比较随机，才能使树比较平衡。而binary heap是一种完全二叉树的结构，而且可以使用vector来存储：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;), 
</span><span class='line'>          class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;
</span><span class='line'>class priority_queue { // in stl_queue.h 文件中
</span><span class='line'>protected:
</span><span class='line'>  _Sequence c; // 使用vector作为数据存储的容器
</span><span class='line'>  _Compare comp;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>
另外只需要提供一组heap算法，即元素插入和删除、获取堆顶元素等操作即可。</p>

<!-- more -->


<h2>3. push heap 算法</h2>

<p>为了满足完全二叉树的特性，新加入的元素一定要放在vector的最后面；又为了满足max-heap的条件（每个节点的键值不小于其叶子节点的键值），还需要执行上溯过程，将新插入的元素与其父节点进行比较，直到不大于父节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;
</span><span class='line'>void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value){
</span><span class='line'>  _Distance __parent = (__holeIndex - 1) / 2; //  新节点的父节点
</span><span class='line'>  while (__holeIndex &gt; __topIndex && *(__first + __parent) &lt; __value) { // 插入时的堆调整过程：当尚未到达顶端且父节点小于新值时，需要将新值往上（前）调整
</span><span class='line'>    *(__first + __holeIndex) = *(__first + __parent); // 父节点下移
</span><span class='line'>    __holeIndex = __parent;
</span><span class='line'>    __parent = (__holeIndex - 1) / 2;
</span><span class='line'>  }    
</span><span class='line'>  *(__first + __holeIndex) = __value; // 找到新值应当存储的位置
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;
</span><span class='line'>inline void __push_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance*, _Tp*) {
</span><span class='line'>  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), _Tp(*(__last - 1))); 
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator&gt;
</span><span class='line'>inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { // 真正的对外接口，在调用之前，元素已经放在了vector的最后面了（见priority queue的push_back）
</span><span class='line'>  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
</span><span class='line'>  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable);
</span><span class='line'>  __push_heap_aux(__first, __last, __DISTANCE_TYPE(__first), __VALUE_TYPE(__first)); // 直接调用 __push_heap_aux
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. pop heap 算法</h2>

<p>对heap进行pop操作就是取顶部的元素，取走后要对heap进行调整，是之满足max-heap的特性。调整的策略是，首先将最末尾的元素放到堆顶，然后进行下溯操作，将对顶元素下移到适当的位置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;
</span><span class='line'>void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value) { // 调整堆
</span><span class='line'>  _Distance __topIndex = __holeIndex; // 堆顶
</span><span class='line'>  _Distance __secondChild = 2 * __holeIndex + 2;
</span><span class='line'>  while (__secondChild &lt; __len) {
</span><span class='line'>    if (*(__first + __secondChild) &lt; *(__first + (__secondChild - 1))) __secondChild--; // secondChild 为左右两个子节点中较大者
</span><span class='line'>    *(__first + __holeIndex) = *(__first + __secondChild); // 节点的值上移
</span><span class='line'>    __holeIndex = __secondChild;
</span><span class='line'>    __secondChild = 2 * (__secondChild + 1); // 下移一层
</span><span class='line'>  }
</span><span class='line'>  if (__secondChild == __len) { // 最后一个元素
</span><span class='line'>    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
</span><span class='line'>    __holeIndex = __secondChild - 1;
</span><span class='line'>  }
</span><span class='line'>  __push_heap(__first, __holeIndex, __topIndex, __value);
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Tp, class _Distance&gt;
</span><span class='line'>inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Tp __value, _Distance*) {
</span><span class='line'>  *__result = *__first; // 获取堆顶元素，并赋给堆尾的last-1
</span><span class='line'>  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value); // 调整堆
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Tp&gt;
</span><span class='line'>inline void __pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*) {
</span><span class='line'>  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __DISTANCE_TYPE(__first)); // 对 [first,last-1)进行pop，并将first赋给last-1
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator&gt;
</span><span class='line'>inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { // 对外提供的接口，最后堆顶元素在堆的末尾，而[first,last-1) 区间为新堆，该接口调用完后再进行pop操作移除最后的元素
</span><span class='line'>  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
</span><span class='line'>  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable);
</span><span class='line'>  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>5. make heap 算法</h2>

<p>最后，我们来看看如何从一个初始序列来创建一个heap，有了前面的 <code>adjust_heap</code> ，创建heap也就很简单了，只需要从最后一个非叶子节点开始，不断调用堆调整函数，即可使得整个序列称为一个heap：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _RandomAccessIterator, class _Compare, class _Tp, class _Distance&gt;
</span><span class='line'>void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, _Tp*, _Distance*) {
</span><span class='line'>  if (__last - __first &lt; 2) return;
</span><span class='line'>  _Distance __len = __last - __first;
</span><span class='line'>  _Distance __parent = (__len - 2)/2; // 定位到最后一个非叶子节点
</span><span class='line'>  while (true) { // 对每个非叶子节点为根的子树进行堆调整
</span><span class='line'>    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)), __comp);
</span><span class='line'>    if (__parent == 0) return;
</span><span class='line'>    __parent--;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Compare&gt;
</span><span class='line'>inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) { // 对外提供的接口
</span><span class='line'>  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
</span><span class='line'>  __make_heap(__first, __last, __comp, __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>6. 基于 heap 的 priority queue</h2>

<p>上一篇文章中讲到stack和queue都是基于deque实现的，这里的priority queue是基于vector和heap来实现的，默认使用vector作为容器，而使用heap的算法来维持其priority的特性，因此priority queue也被归类为container adapter。其具体实现的主要代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;), class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;
</span><span class='line'>class priority_queue {
</span><span class='line'>protected:
</span><span class='line'>  _Sequence c;
</span><span class='line'>  _Compare comp;
</span><span class='line'>public:
</span><span class='line'>  priority_queue() : c() {}
</span><span class='line'>  explicit priority_queue(const _Compare& __x) :  c(), comp(__x) {}
</span><span class='line'>  priority_queue(const _Compare& __x, const _Sequence& __s) : c(__s), comp(__x) 
</span><span class='line'>    { make_heap(c.begin(), c.end(), comp); }
</span><span class='line'>  bool empty() const { return c.empty(); }
</span><span class='line'>  size_type size() const { return c.size(); }
</span><span class='line'>  const_reference top() const { return c.front(); }
</span><span class='line'>  void push(const value_type& __x) {
</span><span class='line'>    __STL_TRY {
</span><span class='line'>      c.push_back(__x); // 在push_heap之前先将x放在vector c的最后面
</span><span class='line'>      push_heap(c.begin(), c.end(), comp);
</span><span class='line'>    }
</span><span class='line'>    __STL_UNWIND(c.clear());
</span><span class='line'>  }
</span><span class='line'>  void pop() {
</span><span class='line'>    __STL_TRY {
</span><span class='line'>      pop_heap(c.begin(), c.end(), comp);
</span><span class='line'>      c.pop_back(); // 在调用pop_heap之后才将最后一个元素剔除出vector c
</span><span class='line'>    }
</span><span class='line'>    __STL_UNWIND(c.clear());
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，priority queue也没有迭代器，不能对其进行遍历等操作，因为它只能在顶部取和删除元素，而插入元素的位置也是确定的，而不能有用户指定。<br/>
关于heap和priority queue的内容就介绍到这里了，而序列式容器的介绍也到此结束了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.3) 序列式容器之deque和stack、queue]]></title>
    <link href="http://ibillxia.github.io/blog/2014/07/13/stl-source-insight-3-sequential-containers-3-deque-and-stack-queue/"/>
    <updated>2014-07-13T20:46:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/07/13/stl-source-insight-3-sequential-containers-3-deque-and-stack-queue</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>deque</code>、<code>stl_deque.h</code>、<code>deque.h</code>、<code>stack</code>、<code>stl_stack.h</code>、<code>queue</code>、<code>stl_queue.h</code> 等几个文件。</p>

<h2>1. deque 概述</h2>

<p>前面分别介绍了连续式存储的序列容器vector和以节点为单位链接起来的非连续存储的序列容器list，这两者各有优缺点，而且刚好是优缺互补的，那么何不将二者结合利用对方的优点来弥补己方的不足呢，于是这就有了强大的deque。</p>

<p>没错，与我们在数据结构中学到的固定连续空间的双端队列不同，STL中的deque是分段连续的空间通过list链接而成的序列容器，它结合了vector与list的存储特性，但与vector和list都不同的是deque只能在首部或尾部进行插入和删除操作，这个限制在一定程度上简化了deque实现的难度。由于使用分段连续空间链接的方式，所以deque不存在vector那样“因旧空间不足而重新配置新的更大的空间，然后复制元素，再释放原空间”的情形，也不会有list那样每次都只配置一个元素的空间而导致时间性能和空间的利用率低下。</p>

<h2>2. deque 的数据结构</h2>

<p>deque由一段一段连续空间串接而成，一旦有必要在deque的头部或尾端增加新的空间，便配置一段定量连续的空间，串接在deque的头部或尾端。deque的最大任务，就是在这些分段连续的空间上维护其整体连续的假象，并提供随机存取的接口。deque采用一块所谓的map（注意：不是STL中map容器，而是类似于vector）作为主控（为什么不使用list呢？），这块map是一个连续空间，其中每个元素都是一个指针，指向一段连续的空间，称为缓冲区，它才是deque的真正存储空间。SGI中允许指定缓冲区的大小，默认是512字节。除此之外，还有start和finish两个指针，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的最后一个元素。其数据结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inline size_t __deque_buf_size(size_t __size) { // 计算缓冲区的大小
</span><span class='line'>  return __size &lt; 512 ? size_t(512 / __size) : size_t(1);
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt; class _Deque_base {
</span><span class='line'>protected:
</span><span class='line'>  _Tp** _M_map; // 指向缓冲区的指针数组首地址
</span><span class='line'>  size_t _M_map_size;  // 指向缓冲区的指针数组的大小
</span><span class='line'>  iterator _M_start; // 指向第一个缓冲区的第一个元素
</span><span class='line'>  iterator _M_finish; // 指向最后一个缓冲区的最后一个元素
</span><span class='line'>};
</span><span class='line'>class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; {
</span><span class='line'>protected:  // Internal typedefs
</span><span class='line'>  typedef pointer* _Map_pointer;
</span><span class='line'>  static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<h2>3. deque 的配置器</h2>

<p>由于deque涉及到两种类型（map和buffer）数据的空间配置，因此deque定义了两个专属的配置器 <code>_Map_alloc_type</code> 和 <code>_Node_alloc_type</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; class _Deque_base {
</span><span class='line'>protected:
</span><span class='line'>  typedef simple_alloc&lt;_Tp, _Alloc&gt;  _Node_alloc_type;
</span><span class='line'>  typedef simple_alloc&lt;_Tp*, _Alloc&gt; _Map_alloc_type;
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;
</span><span class='line'>class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; { };</span></code></pre></td></tr></table></div></figure>


<p>而这里的 <code>_Alloc</code> 使用的都是STL默认的 <code>alloc</code> 这个配置器，因此这两个配置器实际上都是 <code>alloc</code> 类型的配置器，即SGI的第二级配置器。<br/>
在定义一个deque时，默认调用基类的构造函数，产生一个map大小为0的空的deque，随着第一次插入元素，由于map大小不够，需要调用<code>_M_push_back_aux</code> 进而调用 <code>_M_reallocate_map</code> 进行map的空间配置，如果初始的map不为空，还需要对map进行“分配新空间，复制，释放元空间”的操作，如果从头部插入同样的道理，这是就是map的配置逻辑（实际中，还有一种情况，就是map的前后剩余的node数不同，例如前部分都空着，而后面插入后溢出了，这时可以考虑在map内部移动，即将后半部分整体往前移动一定距离）。其中<code>_M_reallocate_map</code>的实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>void deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add, bool __add_at_front){
</span><span class='line'>  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;
</span><span class='line'>  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
</span><span class='line'>  _Map_pointer __new_nstart;
</span><span class='line'>  if (_M_map_size &gt; 2 * __new_num_nodes) { // map的size足够，在map内部移动
</span><span class='line'>    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
</span><span class='line'>    if (__new_nstart &lt; _M_start._M_node)
</span><span class='line'>      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
</span><span class='line'>    else
</span><span class='line'>      copy_backward(_M_start._M_node, _M_finish._M_node + 1, __new_nstart + __old_num_nodes);
</span><span class='line'>  } else { // map的size不够，重新分配
</span><span class='line'>    size_type __new_map_size = _M_map_size + max(_M_map_size, __nodes_to_add) + 2;
</span><span class='line'>    _Map_pointer __new_map = _M_allocate_map(__new_map_size); // 重新分配map
</span><span class='line'>    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
</span><span class='line'>    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart); // 复制原map到新的map中
</span><span class='line'>    _M_deallocate_map(_M_map, _M_map_size); // 释放原map
</span><span class='line'>    _M_map = __new_map;
</span><span class='line'>    _M_map_size = __new_map_size;
</span><span class='line'>  }
</span><span class='line'>  _M_start._M_set_node(__new_nstart);
</span><span class='line'>  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>那么每个连续的缓冲区buffer（或node）是在什么时候配置呢？它是在map中实际使用到的最后一个node不够用时但map还可以继续在这个node后面加入node时（即map非满而node满时），在 <code>_M_push_back_aux</code> 中调用 <code>_M_allocate_node</code> 来分配，相关函数都比较简单，这里就不贴了。<br/>
以上主要是空间分配相关的，那么在 <code>pop</code> 的时候，空间的释放又是怎样的呢？这里也需要判断是否当前node全部被 <code>pop</code> 了，如果是的则需要释放这个node所占用的空间。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void pop_back() { // deque内部实现的成员函数，inline的
</span><span class='line'>    if (_M_finish._M_cur != _M_finish._M_first) { // 整个node还没有pop完
</span><span class='line'>      --_M_finish._M_cur;
</span><span class='line'>      destroy(_M_finish._M_cur); // 析构当前元素
</span><span class='line'>    } else  _M_pop_back_aux();
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>void deque&lt;_Tp,_Alloc&gt;::_M_pop_back_aux() { // 整个node被pop完了的情况
</span><span class='line'>  _M_deallocate_node(_M_finish._M_first); // 释放整个node的空间
</span><span class='line'>  _M_finish._M_set_node(_M_finish._M_node - 1); // node前移
</span><span class='line'>  _M_finish._M_cur = _M_finish._M_last - 1; // 当前元素为最后一个node的最后一个元素
</span><span class='line'>  destroy(_M_finish._M_cur); // 释放当前元素
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. deque 的迭代器</h2>

<p>deque是分段连续空间，前面也提到了deque使用的是Bidirectional Iterators，因此deque的迭代器主要需要实现<code>operator++</code>和<code>operator--</code>。要实现这两个操作，需要考虑当前指针是否处于buffer的头/尾，如果在buffer的头部而需要前移（或尾部需要后移），就需要将buffer往前/后移一个，在SGI中是通过调用 <code>_M_set_node</code> 来实现的。具体代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Ref, class _Ptr&gt; struct _Deque_iterator {
</span><span class='line'>  typedef _Tp** _Map_pointer;
</span><span class='line'>  _Tp* _M_cur; // 几个成员变量
</span><span class='line'>  _Tp* _M_first;
</span><span class='line'>  _Tp* _M_last;
</span><span class='line'>  _Map_pointer _M_node;
</span><span class='line'>  _Self& operator++() { // ++ 操作符重载，后移
</span><span class='line'>    ++_M_cur;
</span><span class='line'>    if (_M_cur == _M_last) { // 到了buffer的最后一个
</span><span class='line'>      _M_set_node(_M_node + 1); // 将当前node指针_M_node指向下一个node
</span><span class='line'>      _M_cur = _M_first; // 当前指针指向新node的第一个元素
</span><span class='line'>    }
</span><span class='line'>    return *this; 
</span><span class='line'>  }
</span><span class='line'>  void _M_set_node(_Map_pointer __new_node) {
</span><span class='line'>    _M_node = __new_node; // map pointer后移
</span><span class='line'>    _M_first = *__new_node; // first指向新node
</span><span class='line'>    _M_last = _M_first + difference_type(_S_buffer_size()); // last指向下一个node
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用 <code>--</code> 操作符向前移动的同理，这里就不赘述了。</p>

<h2>5. deque 的常用操作</h2>

<p>deque中最常用的莫过于 <code>push</code> 和 <code>pop</code> 操作了，这些操作在前面的空间配置中基本已经介绍了，这里就主要介绍一下 <code>clear</code>、 <code>erase</code> 和 <code>insert</code> 操作吧。<br/>
<strong>（1）clear</strong><br/>
该函数的作用是清除整个deque，释放所有空间而只保留一个缓冲区：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; void deque&lt;_Tp,_Alloc&gt;::clear() {
</span><span class='line'>  for (_Map_pointer __node = _M_start._M_node + 1; __node &lt; _M_finish._M_node; ++__node) { // 从第二个node开始，遍历每个缓冲区（node）
</span><span class='line'>    destroy(*__node, *__node + _S_buffer_size()); // 析构每个元素
</span><span class='line'>    _M_deallocate_node(*__node); // 释放缓冲区
</span><span class='line'>  }
</span><span class='line'>  if (_M_start._M_node != _M_finish._M_node) { // 还剩下头尾两个node
</span><span class='line'>    destroy(_M_start._M_cur, _M_start._M_last); // 析构头node中的每个元素
</span><span class='line'>    destroy(_M_finish._M_first, _M_finish._M_cur); // 析构尾node中的每个元素
</span><span class='line'>    _M_deallocate_node(_M_finish._M_first); // 释放尾node的空间
</span><span class='line'>  } else destroy(_M_start._M_cur, _M_finish._M_cur); // 只有一个node，析构这个node中的所有元素
</span><span class='line'>  _M_finish = _M_start;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（2）erase</strong><br/>
该函数的作用是清除 [first,last) 间的所有元素：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typename deque&lt;_Tp,_Alloc&gt;::iterator 
</span><span class='line'>deque&lt;_Tp,_Alloc&gt;::erase(iterator __first, iterator __last) {
</span><span class='line'>  if (__first == _M_start && __last == _M_finish) { // erase 所有元素，直接调用clear
</span><span class='line'>    clear();
</span><span class='line'>    return _M_finish;
</span><span class='line'>  } else { // erase 部分元素
</span><span class='line'>    difference_type __n = __last - __first; // 待擦出的区间长度
</span><span class='line'>    difference_type __elems_before = __first - _M_start; // 擦出区间前的元素个数
</span><span class='line'>    if (__elems_before &lt; difference_type((this-&gt;size() - __n) / 2)) { // 前面的元素个个数小于擦除后剩余总数的一半，将这部分后移
</span><span class='line'>      copy_backward(_M_start, __first, __last); // 后移
</span><span class='line'>      iterator __new_start = _M_start + __n; 
</span><span class='line'>      destroy(_M_start, __new_start);
</span><span class='line'>      _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
</span><span class='line'>      _M_start = __new_start;
</span><span class='line'>    } else { // 前面剩余的元素较多，将后面的前移
</span><span class='line'>      copy(__last, _M_finish, __first); // 前移
</span><span class='line'>      iterator __new_finish = _M_finish - __n;
</span><span class='line'>      destroy(__new_finish, _M_finish);
</span><span class='line'>      _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);
</span><span class='line'>      _M_finish = __new_finish;
</span><span class='line'>    }
</span><span class='line'>    return _M_start + __elems_before;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（3）insert</strong><br/>
该函数的作用是在某个位置插入一个元素：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>iterator insert(iterator position, const value_type& __x) {
</span><span class='line'>  if (position._M_cur == _M_start._M_cur) { // 在头部插入，用push_front
</span><span class='line'>    push_front(__x);
</span><span class='line'>    return _M_start;
</span><span class='line'>  } else if (position._M_cur == _M_finish._M_cur) { // 在尾部插入
</span><span class='line'>    push_back(__x);
</span><span class='line'>    iterator __tmp = _M_finish;
</span><span class='line'>    --__tmp;
</span><span class='line'>    return __tmp; // 返回插入位置
</span><span class='line'>  } else { // 在中间插入
</span><span class='line'>    return _M_insert_aux(position, __x);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>deque&lt;_Tp,_Alloc&gt;::_M_insert_aux(iterator __pos, const value_type& __x) {
</span><span class='line'>  difference_type __index = __pos - _M_start; // 插入点之前的元素个数
</span><span class='line'>  value_type __x_copy = __x;
</span><span class='line'>  if (size_type(__index) &lt; this-&gt;size() / 2) { // 前面的元素个数较小
</span><span class='line'>    push_front(front()); // 在头部插入与头部相同的元素，然后从第二个元素开始到插入位置整体前移一步
</span><span class='line'>    iterator __front1 = _M_start; ++__front1;
</span><span class='line'>    iterator __front2 = __front1; ++__front2;
</span><span class='line'>    __pos = _M_start + __index;
</span><span class='line'>    iterator __pos1 = __pos; ++__pos1;
</span><span class='line'>    copy(__front2, __pos1, __front1);
</span><span class='line'>  } else { // 插入点后面的元素较少，从后面插入，然后插入点到尾部整体往后移一步
</span><span class='line'>    push_back(back());
</span><span class='line'>    iterator __back1 = _M_finish; --__back1;
</span><span class='line'>    iterator __back2 = __back1;  --__back2;
</span><span class='line'>    __pos = _M_start + __index;
</span><span class='line'>    copy_backward(__pos, __back2, __back1);
</span><span class='line'>  }
</span><span class='line'>  *__pos = __x_copy;
</span><span class='line'>  return __pos;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>deque原本只能在头部或尾部插入元素的，提供了insert之后，就可以任何位置插入元素了。</p>

<h2>6. 基于deque 的 stack 和 queue</h2>

<p>由于deque可以从首位两端插入或剔除元素，所以只需要对其进行简单的封装就可以分别实现先进先出（FIFO）的stack和先进后出（FILO）的queue了。stack和queue中都有一个deque类型的成员，用做数据存储的容器，然后对deque的部分接口进行简单的封装，例如stack只提供从末端插入和删除的接口以及获取末端元素的接口，而queue则只提供从尾部插入而从头部删除的接口以及获取首位元素的接口。像这样具有“修改某物接口，形成另一种风貌”的性质的，称为配接器（adapter），因此STL中stack和queue往往不被归类为容器（container），而被归类为容器配接器（container adapter）。（关于配接器后面文章还会具体介绍）<br/>
下面只给出stack的基本实现，并加以注解。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;
</span><span class='line'>class stack; // 原型声明
</span><span class='line'>template &lt;class _Tp, class _Sequence&gt; class stack {
</span><span class='line'>protected:
</span><span class='line'>  _Sequence c; // _Sequence为deque&lt;_Tp&gt;，c为实际存储数据的容器
</span><span class='line'>public: // 向外部提供的接口，都是调用deque的接口来实现的
</span><span class='line'>  stack() : c() {}
</span><span class='line'>  explicit stack(const _Sequence& __s) : c(__s) {}
</span><span class='line'>  bool empty() const { return c.empty(); }
</span><span class='line'>  size_type size() const { return c.size(); }
</span><span class='line'>  reference top() { return c.back(); }
</span><span class='line'>  const_reference top() const { return c.back(); }
</span><span class='line'>  void push(const value_type& __x) { c.push_back(__x); }
</span><span class='line'>  void pop() { c.pop_back(); }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，stack和queue都没有迭代器，因此不能对stack或queue进行遍历。但他们提供了 <code>operator ==</code> 和 <code>operator&lt;</code> 这两个比较大小的操作符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Seq&gt;
</span><span class='line'>bool operator==(const stack&lt;_Tp,_Seq&gt;& __x, const stack&lt;_Tp,_Seq&gt;& __y) {
</span><span class='line'>  return __x.c == __y.c;
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Seq&gt;
</span><span class='line'>bool operator&lt;(const stack&lt;_Tp,_Seq&gt;& __x, const stack&lt;_Tp,_Seq&gt;& __y) {
</span><span class='line'>  return __x.c &lt; __y.c;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外，除了使用默认的deque作为stack和queue的容器之外，我们还可以使用list或其他自定义的容器，只需要实现了stack或queue需要的接口，使用方法很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stack&lt;int,vector&lt;int&gt; &gt; ist;
</span><span class='line'>queue&lt;char,list&lt;char&gt; &gt; cq;</span></code></pre></td></tr></table></div></figure>


<p>即只需要指定模板中第二个参数即可。<br/>
关于deque的内容就介绍到这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.2) 序列式容器之list]]></title>
    <link href="http://ibillxia.github.io/blog/2014/07/06/stl-source-insight-3-sequential-containers-2-list/"/>
    <updated>2014-07-06T22:03:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/07/06/stl-source-insight-3-sequential-containers-2-list</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>list</code>、<code>stl_list.h</code>、<code>list.h</code> 等几个文件。</p>

<h2>1. list 和 slist</h2>

<p>STL中也实现了链表这种数据结构，list是STL标准的双向链表，而slit是SGI的单链表。相比于vector的连续线性空间而言，list即有有点也有缺点：优点是空间分配更灵活，对任何位置的插入删除操作都是常数时间；缺点是排序不方便。list和vector是比较常用的线性容器，那么什么时候用哪一种容器呢，需要视元素的多少、元素构造的复杂度（是否为POD数据）以及元素存取行为的特性而定。限于篇幅，本文主要介绍list的内容，关于单链表slist可以参见源码和侯捷的书。</p>

<h2>2. list 的数据结构</h2>

<p>在数据结构中，我们知道链表的节点node和链表list本身是不同的数据结构，以下分别是node和list的数据结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct _List_node_base {
</span><span class='line'>  _List_node_base* _M_next;
</span><span class='line'>  _List_node_base* _M_prev;
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp&gt;
</span><span class='line'>struct _List_node : public _List_node_base {  // node 的定义
</span><span class='line'>  _Tp _M_data;
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>class _List_base {
</span><span class='line'>protected:
</span><span class='line'>  _List_node&lt;_Tp&gt;* _M_node; // 只要一个指针就可以表示整个双向链表
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;
</span><span class='line'>class list : protected _List_base&lt;_Tp, _Alloc&gt; {
</span><span class='line'>public:
</span><span class='line'>  typedef _List_node&lt;_Tp&gt; _Node;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>在list中的 <code>_M_node</code> 其实指向一个空白节点，该空白节点的 <code>_M_data</code> 成员是没有被初始化的，实际上该节点是链表的尾部，后面将list的迭代器还会提到这样做的好处。</p>

<h2>3. list 的配置器</h2>

<p>list缺省使用 alloc （即 <code>__STL_DEFAULT_ALLOCATOR</code>） 作为空间配置器，并据此定义了另外一个 <code>list_node_allocator</code> ，并定义了<code>_M_get_node</code>和<code>_M_put_node</code>  两个函数，分别用于分配和释放空间，为的是更方便的以节点大小为配置单位。除此之外，还定义了两个<code>_M_create_node</code> 函数，在分配空间的同时调用元素的构建函数对其进行初始化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; 
</span><span class='line'>class _List_base {
</span><span class='line'>protected:
</span><span class='line'>  typedef simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type; // 专属配置器，每次配置一个节点
</span><span class='line'>  _List_node&lt;_Tp&gt;* _M_get_node() { return _Alloc_type::allocate(1); } // 分配一个节点
</span><span class='line'>  void _M_put_node(_List_node&lt;_Tp&gt;* __p) { _Alloc_type::deallocate(__p, 1); }  // 释放一个节点
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt; // 缺省使用 __STL_DEFAULT_ALLOCATOR 配置器
</span><span class='line'>class list : protected _List_base&lt;_Tp, _Alloc&gt; { 
</span><span class='line'>protected:
</span><span class='line'>  _Node* _M_create_node(const _Tp& __x){ // 分配空间并初始化
</span><span class='line'>    _Node* __p = _M_get_node();
</span><span class='line'>    __STL_TRY {  _Construct(&__p-&gt;_M_data, __x);  }
</span><span class='line'>    __STL_UNWIND(_M_put_node(__p));
</span><span class='line'>    return __p;
</span><span class='line'>  }
</span><span class='line'>  _Node* _M_create_node(){
</span><span class='line'>    _Node* __p = _M_get_node();
</span><span class='line'>    __STL_TRY {  _Construct(&__p-&gt;_M_data);  }
</span><span class='line'>    __STL_UNWIND(_M_put_node(__p));
</span><span class='line'>    return __p;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在list的构造和析构函数、插入、删除等操作中设计到空间的配置。由于list不涉及同时分配多个连续元素的空间，因此用不到SGI的第二层配置器。</p>

<h2>4. list 的迭代器</h2>

<p>由于list的节点在内存中不一定连续存储，其迭代器不能像vector那样使用普通指针了，由于list是双向的链表，迭代器必须具备前移、后移的能力，所以它的迭代器是BidirectionalIterators，即双向的可增可减的，以下是list的迭代器的设计：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct _List_iterator_base {
</span><span class='line'>  typedef bidirectional_iterator_tag iterator_category;
</span><span class='line'>  _List_node_base* _M_node;
</span><span class='line'>  _List_iterator_base(_List_node_base* __x) : _M_node(__x) {}
</span><span class='line'>  _List_iterator_base() {}
</span><span class='line'>  void _M_incr() { _M_node = _M_node-&gt;_M_next; }
</span><span class='line'>  void _M_decr() { _M_node = _M_node-&gt;_M_prev; }
</span><span class='line'>};
</span><span class='line'>template&lt;class _Tp, class _Ref, class _Ptr&gt;
</span><span class='line'>struct _List_iterator : public _List_iterator_base {
</span><span class='line'>  _Self& operator++() { this-&gt;_M_incr(); return *this; }
</span><span class='line'>  _Self operator++(int) { _Self __tmp = *this; this-&gt;_M_incr(); return __tmp; }
</span><span class='line'>  _Self& operator--() { this-&gt;_M_decr(); return *this; }
</span><span class='line'>  _Self operator--(int) { _Self __tmp = *this; this-&gt;_M_decr(); return __tmp; }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>list有一个重要性质，插入操作（insert）和接合操作（splice）都不会造成原有list迭代器失效，而list的删除操作（erase）也只对“指向被删除元素”的那个迭代器失效，其他迭代器不受任何影响。</p>

<h2>5. list 的常用操作</h2>

<p>list的常用操作有很多，例如最基本的<code>push_front</code>、<code>push_back</code>、<code>pop_front</code>、<code>pop_back</code> 等，这里主要介绍一下<code>clear</code>、<code>remove</code>、<code>unique</code>、<code>transfer</code> 这几个。<br/>
<strong>（1）clear</strong><br/>
clear 函数的作用是清楚整个list的所有节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void clear() { _Base::clear(); }
</span><span class='line'>void _List_base&lt;_Tp,_Alloc&gt;::clear() {
</span><span class='line'>  _List_node&lt;_Tp&gt;* __cur = (_List_node&lt;_Tp&gt;*) _M_node-&gt;_M_next;
</span><span class='line'>  while (__cur != _M_node) {
</span><span class='line'>    _List_node&lt;_Tp&gt;* __tmp = __cur;
</span><span class='line'>    __cur = (_List_node&lt;_Tp&gt;*) __cur-&gt;_M_next; // 后移
</span><span class='line'>    _Destroy(&__tmp-&gt;_M_data); // 析构当前节点的对象
</span><span class='line'>    _M_put_node(__tmp); // 释放当前节点的空间
</span><span class='line'>  }
</span><span class='line'>  _M_node-&gt;_M_next = _M_node; // 置为空list
</span><span class='line'>  _M_node-&gt;_M_prev = _M_node;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（2）remove</strong><br/>
remove 函数的作用是将数值为value的所有元素移除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void list&lt;_Tp, _Alloc&gt;::remove(const _Tp& __value) {
</span><span class='line'>  iterator __first = begin();
</span><span class='line'>  iterator __last = end();
</span><span class='line'>  while (__first != __last) { // 遍历list
</span><span class='line'>    iterator __next = __first;
</span><span class='line'>    ++__next;
</span><span class='line'>    if (*__first == __value) erase(__first); // 值与 value 相等就移除
</span><span class='line'>    __first = __next;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（3）unique</strong><br/>
unique函数的作用是移除相同的<strong>连续</strong>元素，只有“连续而且相同”的元素，才回被移除到只剩一个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void list&lt;_Tp, _Alloc&gt;::unique() {
</span><span class='line'>  iterator __first = begin();
</span><span class='line'>  iterator __last = end();
</span><span class='line'>  if (__first == __last) return;
</span><span class='line'>  iterator __next = __first;
</span><span class='line'>  while (++__next != __last) {
</span><span class='line'>    if (*__first == *__next) // 连续连个节点的值相同
</span><span class='line'>      erase(__next);
</span><span class='line'>    else
</span><span class='line'>      __first = __next;
</span><span class='line'>    __next = __first;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（4）transfer</strong><br/>
transfer的作用是将 [first, last) 内的所有元素移动到 position 之前。它是一个私有函数，它为其他常用操作如 splice、sort、merge 等的实现提供了便利。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protected:
</span><span class='line'>  void transfer(iterator __position, iterator __first, iterator __last) {
</span><span class='line'>    if (__position != __last) {
</span><span class='line'>      // Remove [first, last) from its old position.
</span><span class='line'>      __last._M_node-&gt;_M_prev-&gt;_M_next     = __position._M_node;
</span><span class='line'>      __first._M_node-&gt;_M_prev-&gt;_M_next    = __last._M_node;
</span><span class='line'>      __position._M_node-&gt;_M_prev-&gt;_M_next = __first._M_node; 
</span><span class='line'>      // Splice [first, last) into its new position.
</span><span class='line'>      _List_node_base* __tmp      = __position._M_node-&gt;_M_prev;
</span><span class='line'>      __position._M_node-&gt;_M_prev = __last._M_node-&gt;_M_prev;
</span><span class='line'>      __last._M_node-&gt;_M_prev     = __first._M_node-&gt;_M_prev; 
</span><span class='line'>      __first._M_node-&gt;_M_prev    = __tmp;
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>关于list的内容就介绍到这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.1) 序列式容器之vector]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/29/stl-source-insight-3-sequential-containers-1-vector/"/>
    <updated>2014-06-29T23:26:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/29/stl-source-insight-3-sequential-containers-1-vector</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>vector</code>、<code>stl_vector.h</code>、<code>vector.h</code> 等几个文件。</p>

<h2>1. 容器</h2>

<p>在数据结构的课程中，我们主要研究数据的特定排列方式，以利于搜索、排序等算法，几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL 容器即由一个个特定的数据结构组成，例如向量（vector），链表（list），堆栈（stack），队列（queue），树（tree），哈希表（hash table），集合（set），映射（map）等，根据数据在容器中的排列特性，这些数据接口分为序列式容器（sequence container）和关联式容器（association container）两种，本文主要解读SGI STL中的序列式容器。</p>

<p>所谓序列式容器，其中的元素可序（ordered），但未必有序（sorted）。C++ 本身提供了一个序列式容器——数组（array），STL中还提供了向量（vector），链表（list），堆栈（stack），队列（queue），优先队列（priority queue）等，其中stack和queue只是将deque（双端队列）设限而得到的，技术上可以被归为一种配接器（adaptor）。本系列文章将依次解读SGI STL各容器的关键实现细节。</p>

<h2>2. vector 及其数据结构</h2>

<p>在STL中，vector的空间在物理上就是连续的，而且是可以动态扩展的，这里的动态扩展，不需要用户去处理溢出的问题，而只需要关心上层逻辑。vector连续物理空间的动态扩展技术是该容器的关键，它主要分为三个步骤：配置新空间，数据移动，释放旧空间。这三个步骤执行的次数以及每次执行时的效率是影响最终 vector 效率的关键因素。为了减少执行的次数，就需要未雨绸缪，每次扩充空间时，成倍增长。而每次执行的效率，就主要是数据移动的效率了。下面，我们依次介绍vector的数据结构，使用的空间配置器和迭代器，以及常用操作。<br/>
<strong>vector 的数据结构</strong><br/>
vector的数据结构很简单，就是一段连续的物理空间，包含起止地址以及已用到的空间的末尾地址这三个成员：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>class _Vector_base {
</span><span class='line'>protected:
</span><span class='line'>  _Tp* _M_start;
</span><span class='line'>  _Tp* _M_finish;
</span><span class='line'>  _Tp* _M_end_of_storage;
</span><span class='line'>};
</span><span class='line'>class vector : protected _Vector_base&lt;_Tp, _Alloc&gt;{
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>其中 <code>_M_finish</code> 是当前使用到的空间的结束地址，而 <code>_M_end_of_storage</code> 是可用空间的结束地址，前者小于等于后者，当新加入元素使得前者大于后者之后，就需要进行空间扩充了。</p>

<h2>3. vector 的配置器</h2>

<p>vector的空间配置器 STL 默认的 <code>alloc</code> 即 <code>__default_alloc_template</code> 配置器，即第二级配置器，它对于 POD(plain old data) 类型数据使用内建内存池来应对内存碎片问题，关于该默认配置器的更多介绍请参见本系列第2篇文章 <a href="http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator/">深入理解STL源码(1) 空间配置器</a> . 除此之外，SGI vector 还定义了一个 <code>data_allocator</code>，为的是更方便的以元素大小为配置单位：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; 
</span><span class='line'>class _Vector_base  // vector 继承了该基类
</span><span class='line'>protected:
</span><span class='line'>    typedef simple_alloc&lt;_Tp, _Alloc&gt; _M_data_allocator;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于 <code>simple_alloc</code> 的内容见前面的文章，它其实就是简单的对 <code>malloc</code> 等的加一层封装。
vector的内存是在vector的构造或析构、插入元素而容量不够等情况下，需要进行配置。vector 提供了很多的构造函数，具体可见源代码，而更详细的列表并涉及各个版本的说明的列表可以参见C++的文档：<a href="http://en.cppreference.com/w/cpp/container/vector/vector">cpp references</a>.</p>

<h2>4. vector 的迭代器</h2>

<p>由于vector使用的物理连续的空间，需要支持随机访问，所以它使用的随机访问迭代器（Random Access Iterators）。也正由于vector使用连续物理空间，所以不论其元素类型为何，使用普通指针就可以作为它的迭代器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public:
</span><span class='line'>  typedef _Tp value_type;
</span><span class='line'>  typedef value_type* iterator;
</span><span class='line'>  typedef const value_type* const_iterator;</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>：vector中所谓的动态增加大小，并不是在原空间之后接连续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后再在其后构造新元素，最后释放原空间。因此，对于vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就失效了，这是vector使用中的一个大坑，务必小心。</p>

<h2>5. vector 的常用操作</h2>

<p>vector所提供的元素操作很多，这里选取几个常用操作介绍一下。<br/>
<strong>（1）push_back</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public  void push_back(const _Tp& __x) {
</span><span class='line'>if (_M_finish != _M_end_of_storage) {
</span><span class='line'>    construct(_M_finish, __x);
</span><span class='line'>    ++_M_finish;
</span><span class='line'>}
</span><span class='line'>else
</span><span class='line'>    _M_insert_aux(end(), __x); // auxiliary insert
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中辅助的insert函数的基本逻辑为：按原空间大小的两倍申请新空间，复制原数据到新空间，释放原空间，更新新vector的数据结构的成员变量。<br/>
<strong>（2）insert</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public  iterator insert(iterator __position, const _Tp& __x) {
</span><span class='line'>    size_type __n = __position - begin();
</span><span class='line'>    if (_M_finish != _M_end_of_storage && __position == end()) {
</span><span class='line'>      construct(_M_finish, __x);
</span><span class='line'>      ++_M_finish;
</span><span class='line'>    }
</span><span class='line'>    else
</span><span class='line'>      _M_insert_aux(__position, __x);
</span><span class='line'>    return begin() + __n;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>与<code>push_back</code>类似，只是<code>push_back</code> 在最后插入，更为简单。insert 首先判断是否为在最后插入且容量足够，如果是最后插入且容量足够就就直接内部实现了。否则还是调用上面的辅助插入函数，该函数中首先判断容量是否足够，容量足的话，先构造一个新元素并以当前vector的最后一个元素的值作为其初始值，然后从倒数第二个元素开始从后往前拷贝，将前一元素的值赋给后一元素，知道当前插入位置。<br/>
<strong>(3)erase</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public  iterator erase(iterator __first, iterator __last) {
</span><span class='line'>    iterator __i = copy(__last, _M_finish, __first);
</span><span class='line'>    destroy(__i, _M_finish);
</span><span class='line'>    _M_finish = _M_finish - (__last - __first);
</span><span class='line'>    return __first;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>与insert相反，该函数将某些连续的元素从vector中删除，所以不存在容量不足等问题，但也不会将没有使用的空间归还给操作系统。这里只有简单的元素拷贝（copy）和元素的析构（destroy）。另外，需要说明的是，对于vector而言clear函数和erase函数是等同的，都只清空对应内存块的值，而不将空间归还给操作系统，所以vector的容量是只增不减的。而对于其他一些容器就有所不同了，比如list之类以node为单位的数据结构。<br/>
关于vector的内容就介绍到这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(2) 迭代器(Iterators)和Traits]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits/"/>
    <updated>2014-06-21T21:46:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有 <code>iterator.h</code>, <code>stl_iterator_base.h</code>, <code>concept_checks.h</code>, <code>stl_iterator.h</code>, <code>type_traits.h</code>, <code>stl_construct.h</code>, <code>stl_raw_storage_iter.h</code> 等7个文件。</p>

<h2>1. 迭代器的设计思维</h2>

<p>迭代器（iterators）是一种抽象的设计概念，显示程序中并没有直接对应于这个概念的实体。在 <em>Design Patterns</em> 一书中，对 iterators 模式的定义如下：提供一种方法，使之能够依序遍历某个聚合物（容器）所包含的各个元素，而又无需暴露该聚合物内部的表述方式。</p>

<p>在STL中迭代器扮演着重要的角色。STL的中心思想在于：将数据容器（container）和算法（algorithm）分开，彼此独立设计，最后再通过某种方式将他们衔接在一起。容器和算法的泛型化，从技术的角度来看并不困难，C++ 的 class template 和 function template 可以分别达到目标，难点在于如何设计二者之间的衔接器。</p>

<p>在STL中，起者这种衔接作用的是迭代器，它是一种行为类似指针的对象。指针的各种行为中最常见也最重要的便是内容获取（dereference）和成员访问（member access），因此迭代器最重要的工作就是对 <code>operator*</code> 和 <code>operator-&gt;</code> 进行重载。然而要对这两个操作符进行重载，就需要对容器内部的对象的数据类型和存储结构有所了解，于是在 STL 中迭代器的最终实现都是由容器本身来实现的，每种容器都有自己的迭代器实现，例如我们使用vector容器的迭代器的时候是这样用的 <code>vector&lt;int&gt;::iterator it;</code> 。而本文所讨论的迭代器是不依存于特定容器的迭代器，它在STL中主要有以下两个方面的作用（我自己的理解和总结）：</p>

<blockquote><ul>
<li>规定容器中需要实现的迭代器的类型及每种迭代器的标准接口</li>
<li>通过Traits编程技巧实现迭代器相应型别的获取，弥补 C++ 模板参数推导的不足，为配置器提供可以获取容器中对象型别的接口</li>
</ul>
</blockquote>

<p>其中前一个没啥好解释的。关于第二个，后面第3节会详细介绍，那就是Traits编程技巧。</p>

<!-- more -->


<h2>2. STL 迭代器的分类与标准接口</h2>

<h3>2.1 STL 迭代器的分类</h3>

<p>在SGI STL中迭代器按照移动特性与读写方式分为 <code>input_iterator</code>, <code>output_iterator</code>, <code>forward_iterator</code>, <code>bidirectional_iterator</code>, <code>random_access_iterator</code> 这5种，他们的定义都在 <code>stl_iterators_base.h</code> 文件中。这5种迭代器的特性如下：</p>

<ul>
<li>input_iterator:  这种迭代器所指对象只允许读取，而不允许改变，是只读的（read only）。</li>
<li>output_iterator:  与上面的相反，只能写（write only）。</li>
<li>forward_iterator: 同时允许读和写，适用于 <code>replace()</code> 等算法。</li>
<li>bidirectional_iterator: 可双向移动，即既可以按顺序访问，也可以按逆序访问。</li>
<li>random_access_iterator: 前4种只提供一部分指针运算功能，如前3种只支持 <code>operator++</code>, 而第4种还支持 <code>operator--</code>, 但这种随机访问迭代器还支持 <code>p+n</code>, <code>p-n</code>, <code>p[n]</code>, <code>p1-p2</code>, <code>p1+p2</code> 等。</li>
</ul>


<p>从以上的特性可以看出，<code>input_iterator</code> 和 <code>output_iterator</code> 都是特殊的 <code>forward_iterator</code>, 而 <code>forward_iterator</code> 是特殊的 <code>bidirectional_iterator</code>, <code>bidirectional_iterator</code> 是特殊的 <code>random_access_iterator</code> 。在 <code>stl_iterator_base.h</code> 文件中，他们的定义中我们并不能看到这种特性的表达，而只是规定了这几种迭代器类型及应该包含的成员属性，真正表达这些迭代器不同特性的代码在 <code>stl_iterator.h</code> 文件中。在 <code>stl_iterator_base.h</code> 文件中，除了对这几种迭代器类型进行规定之外，还提供了获取迭代器类型的接口、获取迭代器中的 <code>value_type</code> 类型、获取迭代器中的 <code>distance_type</code> 、获取两个迭代器的距离（<code>distance</code> 函数）、将迭代器向前推进距离 n （<code>advance</code> 函数）等标准接口。</p>

<h3>2.2 STL迭代器的标准接口</h3>

<p>在 <code>stl_iterator.h</code> 文件中，设计了 <code>back_insert_iterator</code>, <code>front_insert_iterator</code>, <code>insert_iterator</code>, <code>reverse_bidirectional_iterator</code>, <code>reverse_iterator</code>, <code>istream_iterator</code>, <code>ostream_iterator</code>,  等标准的迭代器，其中前3中都使用 <code>output_iterator</code> 的只写特性（只进行插入操作，只是插入的位置不同而已），而第4种使用的是 <code>bidirectional_iterator</code> 的双向访问特性，第5种使用的是 <code>random_access_iterator</code> 的随机访问特性。而最后两种标准迭代器分别是使用 <code>input_iterator</code> 和 <code>output_iterator</code> 特性的迭代器。从这几个标准的迭代器的定义中可以看出，主要是实现了 <code>operator=</code>, <code>operator*</code>, <code>operator-&gt;</code>, <code>operator==</code>, <code>operator++</code>, <code>operator--</code>, <code>operator+</code>, <code>operator-</code>, <code>operator+=</code>, <code>operator-=</code> 等指针操作的标准接口。根据定义的操作符的不同，就是不同类型的迭代器了。</p>

<p>例如，下面是 <code>back_insert_iterator</code> 的标准定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Container&gt;
</span><span class='line'>class back_insert_iterator {
</span><span class='line'>protected:
</span><span class='line'>  _Container* container;
</span><span class='line'>public:
</span><span class='line'>  // member variables
</span><span class='line'>  typedef _Container          container_type;
</span><span class='line'>  typedef output_iterator_tag iterator_category;
</span><span class='line'>  typedef void                value_type;
</span><span class='line'>  typedef void                difference_type;
</span><span class='line'>  typedef void                pointer;
</span><span class='line'>  typedef void                reference;
</span><span class='line'>  // member functions, mainly about operator overloading
</span><span class='line'>  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;&
</span><span class='line'>  operator=(const typename _Container::value_type& __value) { 
</span><span class='line'>    container-&gt;push_back(__value);
</span><span class='line'>    return *this;
</span><span class='line'>  }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator*() { return *this; }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator++() { return *this; }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator++(int) { return *this; }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>3. 迭代器相应型别与Traits编程技巧</h2>

<h3>3.1 迭代器相应型别</h3>

<p>在算法中运用迭代器是，很可能需要获取器相应型别，即迭代器所指对象的类型。此时需要使用到 function template 的参数推导（argument deducation）机制，在传入迭代器模板类型的同时，传入迭代器所指对象的模板类型，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template&lt;class I, class T&gt;
</span><span class='line'>void func_impl(I iter, T t){
</span><span class='line'>    // TODO: Add your code here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里不仅要传入类型 <code>class I</code>, 还要传入类型 <code>class T</code>。然而，迭代器的相应型别并不仅仅只有 “迭代器所指对象的类型” 这一种，例如在STL中就有如下5种：</p>

<ul>
<li>value_type: 迭代器所指对象的类型。</li>
<li>difference_type: 表示两个迭代器之间的距离，因此也可以用来表示一个容器的最大容量。例如一个提供计数功能的泛型算法 <code>count()</code> ，其返回值的类型就是迭代器的 <code>difference_type</code> .</li>
<li>reference_type: 从迭代器所指内容是否允许修改来看，迭代器分为 constant iterator 和 mutable iterator，如果传回一个可以修改的对象，一般是以 reference 的方式，因此需要传回引用时，使用此类型。</li>
<li>pointer_type: 在需要传回迭代器所指对象的地址时，使用这种类型。</li>
<li>iterator_category: 即前面提到5种的迭代器的类型。</li>
</ul>


<p>而且实际当中，并不是所有情况都可以通过以上的 template 的参数推导机制来实现（例如算法返回值的类型是迭代器所指对象的类型，template参数推导机制无法推导返回值类型），因此需要更一般化的解决方案，在STL中，这就是Traits编程技巧。</p>

<h3>3.2 Traits 编程技巧</h3>

<p>在STL的每个标准迭代器中，都定义了5个迭代器相应型别的成员变量，在STL定义了一个统一的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// In file stl_iterator_base.h
</span><span class='line'>template &lt;class _Category, class _Tp, class _Distance = ptrdiff_t,
</span><span class='line'>          class _Pointer = _Tp*, class _Reference = _Tp&&gt;
</span><span class='line'>struct iterator {
</span><span class='line'>  typedef _Category  iterator_category;
</span><span class='line'>  typedef _Tp        value_type;
</span><span class='line'>  typedef _Distance  difference_type;
</span><span class='line'>  typedef _Pointer   pointer;
</span><span class='line'>  typedef _Reference reference;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其他的迭代器都可以继承这个标注类，由于后面3个模板参数都有默认值，因此新的迭代器只需提供前两个参数即可（但在SGI STL中并没有使用继承机制）。这样在使用该迭代器的泛型算法中，可以返回这5种类型中的任意一种，而不需要依赖于 template 参数推导的机制。</p>

<p>在SGI STL中，如果启用 <code>__STL_CLASS_PARTIAL_SPECIALIZATION</code> 这个宏定义，还有这样一个标准的 <code>iterator_traits</code> ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// In file stl_iterator_base.h
</span><span class='line'>template &lt;class _Iterator&gt;
</span><span class='line'>struct iterator_traits {
</span><span class='line'>  typedef typename _Iterator::iterator_category iterator_category;
</span><span class='line'>  typedef typename _Iterator::value_type        value_type;
</span><span class='line'>  typedef typename _Iterator::difference_type   difference_type;
</span><span class='line'>  typedef typename _Iterator::pointer           pointer;
</span><span class='line'>  typedef typename _Iterator::reference         reference;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，这些类型不仅可以是泛型算法的返回值类型，还可以是传入参数的类型。例如 <code>iterator_category</code> 可以作为迭代器的接口 <code>advance()</code> 和 <code>distance()</code>  的传入参数之一。 不同类型的迭代器实现同一算法的方式可能不同，可以通过这个参数类型来区分不同的重载函数。</p>

<h2>4. SGI 中的 __type_traits</h2>

<p>traits 编程技巧非常赞，适度弥补了 C++ template 本身的不足。 STL 只对迭代器加以规范，设计了 <code>iterator_traits</code> 这样的东西，SGI进一步将这种技法扩展到了迭代器之外，于是有了所谓的 <code>__type_traits</code>。</p>

<p>在SGI中， <code>__type_traits</code> 可以获取一些类型的特殊属性，如该类型是否具备 trivial default ctor？是否具备 trivial copy ctor？是否具备 trivial assignment operator？是否具备 tivial dtor？是否是 plain old data（POD）？ 如果答案是肯定的，那么我们对这些类型进行构造、析构、拷贝、赋值等操作时，就可以采用比较有效的方法，如不调用该类型的默认构造、析构函数，而是直接调用 <code>malloc()</code>, <code>free()</code>, <code>memcpy()</code> 等等，这对于大量而频繁的操作容器，效率有显著的提升。</p>

<p>SGI中 <code>__type_traits</code> 的特性的实现都在 <code>type_traits.h</code> 文件中。其中将 <code>bool</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code> 等基本的数据类型及其相应的指针类型的这些特性都定义为 <code>__true_type</code>，这以为着，这些对基本类型进行构造、析构、拷贝、赋值等操作时，都是使用系统函数进行的。而除了这些类型之外的其他类型，除非用户指定了它的这些特性为 <code>__true_type</code>，默认都是 <code>__false_type</code> 的，不能直接调用系统函数来进行内存配置或赋值等，而需要调用该类型的构造函数、拷贝构造函数等。</p>

<p>另外，用户在自定义类型时，究竟一个 class 什么时候应该是 <code>__false_type</code> 的呢？一个简单的判断标准是：如果 class 内部有指针成员并需要对其进行动态配置内存是，这个 class 就需要定义为 <code>__false_type</code>的，需要给该类型定义构造函数、拷贝构造函数、析构函数等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(1) 空间配置器(allocator)]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator/"/>
    <updated>2014-06-13T22:04:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator</id>
    <content type="html"><![CDATA[<p>在STL中，Memory Allocator 处于最底层的位置，为一切的 Container 提供存储服务，是一切其他组件的基石。对于一般使用 STL 的用户而言，Allocator 是不可见的，如果需要对 STL 进行扩展，如编写自定义的容器，就需要调用 Allocator 的内存分配函数进行空间配置。本文涉及到的 SGI STL 源代码文件有 <code>alloc.h</code>, <code>stl_config.h</code>, <code>stl_alloc.h</code>, <code>stl_threads.h</code> 这4个。</p>

<p>在C++中，一个对象的内存配置和释放一般都包含两个步骤，对于内存的配置，首先是调用operator new来配置内存，然后调用对象的类的构造函数进行初始化；而对于内存释放，首先是调用析构函数，然后调用 operator delete进行释放。 如以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Foo { ... };
</span><span class='line'>Foo* pf = new Foo;
</span><span class='line'>...
</span><span class='line'>delete pf;</span></code></pre></td></tr></table></div></figure>


<p>Allocator 的作用相当于operator new 和operator delete的功能，只是它考虑得更加细致周全。SGI STL 中考虑到了内存分配失败的异常处理，内置轻量级内存池（主要用于处理小块内存的分配，应对内存碎片问题）实现， 多线程中的内存分配处理（主要是针对内存池的互斥访问）等，本文就主要分析 SGI STL 中在这三个方面是如何处理的。在介绍着三个方面之前，我们先来看看 Allocator的标准接口。</p>

<!-- more -->


<h2>1. Allocator 的标准接口</h2>

<p>在 SGI STL 中，Allocator的实现主要在文件<code>alloc.h</code> 和 <code>stl_alloc.h</code> 文件中。根据 STL 规范，Allocator 需提供如下的一些接口（见 <code>stl_alloc.h</code> 文件的第588行开始的class template allocator）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 标识数据类型的成员变量，关于中间的6个变量的涵义见后续文章（关于Traits编程技巧）
</span><span class='line'>typedef alloc _Alloc;
</span><span class='line'>typedef size_t     size_type;
</span><span class='line'>typedef ptrdiff_t  difference_type;
</span><span class='line'>typedef _Tp*       pointer;
</span><span class='line'>typedef const _Tp* const_pointer;
</span><span class='line'>typedef _Tp&       reference;
</span><span class='line'>typedef const _Tp& const_reference;
</span><span class='line'>typedef _Tp        value_type;
</span><span class='line'>template &lt;class _Tp1&gt; struct rebind {
</span><span class='line'>  typedef allocator&lt;_Tp1&gt; other;
</span><span class='line'>}; // 一个嵌套的class template，仅包含一个成员变量 other
</span><span class='line'>// 成员函数
</span><span class='line'>allocator() __STL_NOTHROW {}  // 默认构造函数，其中__STL_NOTHROW 在 stl_config.h中定义，要么为空，要么为 throw()
</span><span class='line'>allocator(const allocator&) __STL_NOTHROW {}  // 拷贝构造函数
</span><span class='line'>template &lt;class _Tp1&gt; allocator(const allocator&lt;_Tp1&gt;&) __STL_NOTHROW {} // 泛化的拷贝构造函数
</span><span class='line'>~allocator() __STL_NOTHROW {} // 析构函数
</span><span class='line'>pointer address(reference __x) const { return &__x; } // 返回对象的地址
</span><span class='line'>const_pointer address(const_reference __x) const { return &__x; }  // 返回const对象的地址
</span><span class='line'>_Tp* allocate(size_type __n, const void* = 0) {
</span><span class='line'>  return __n != 0 ? static_cast&lt;_Tp*&gt;(_Alloc::allocate(__n * sizeof(_Tp))) : 0; 
</span><span class='line'>  // 配置空间，如果申请的空间块数不为0，那么调用 _Alloc 也即 alloc 的 allocate 函数来分配内存，
</span><span class='line'>} //这里的 alloc 在 SGI STL 中默认使用的是__default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt;这个实现（见第402行）
</span><span class='line'>void deallocate(pointer __p, size_type __n) { _Alloc::deallocate(__p, __n * sizeof(_Tp)); } // 释放空间
</span><span class='line'>size_type max_size() const __STL_NOTHROW  // max_size() 函数，返回可成功配置的最大值
</span><span class='line'>    { return size_t(-1) / sizeof(_Tp); }  //这里没看懂，这里的size_t(-1)是什么意思？
</span><span class='line'>void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); } // 调用 new 来给新变量分配空间并赋值
</span><span class='line'>void destroy(pointer __p) { __p-&gt;~_Tp(); } // 调用 _Tp 的析构函数来释放空间</span></code></pre></td></tr></table></div></figure>


<p>在SGI STL中设计了如下几个空间分配的 class template：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;int __inst&gt; class __malloc_alloc_template // Malloc-based allocator.  Typically slower than default alloc
</span><span class='line'>typedef __malloc_alloc_template&lt;0&gt; malloc_alloc
</span><span class='line'>template&lt;class _Tp, class _Alloc&gt; class simple_alloc
</span><span class='line'>template &lt;class _Alloc&gt; class debug_alloc
</span><span class='line'>template &lt;bool threads, int inst&gt; class __default_alloc_template // Default node allocator.
</span><span class='line'>typedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc
</span><span class='line'>typedef __default_alloc_template&lt;false, 0&gt; single_client_alloc
</span><span class='line'>template &lt;class _Tp&gt;class allocator
</span><span class='line'>template&lt;&gt;class allocator&lt;void&gt;
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt;struct __allocator
</span><span class='line'>template &lt;class _Alloc&gt;class __allocator&lt;void, _Alloc&gt;</span></code></pre></td></tr></table></div></figure>


<p>其中<code>simple_alloc</code> , <code>debug_alloc</code> , <code>allocator</code> 和 <code>__allocator</code>  的实现都比较简单，都是对其他适配器的一个简单封装（因为实际上还是调用其他配置器的方法，如 <code>_Alloc::allocate</code> ）。而真正内容比较充实的是 <code>__malloc_alloc_template</code> 和 <code>__default_alloc_template</code> 这两个配置器，这两个配置器就是 SGI STL 配置器的精华所在。其中 <code>__malloc_alloc_template</code> 是SGI STL 的第一层配置器，只是对系统的 <code>malloc</code> , <code>realloc</code> 函数的一个简单封装，并考虑到了分配失败后的异常处理。而 <code>__default_alloc_template</code> 是SGI STL 的第二层配置器，在第一层配置器的基础上还考虑了内存碎片的问题，通过内置一个轻量级的内存池。下文将先介绍第一级配置器的异常处理机制，然后介绍第二级配置器的内存池实现，及在多线程环境下内存池互斥访问的机制。</p>

<h2>2. SGI STL 内存分配失败的异常处理</h2>

<p>内存分配失败一般是由于out-of-memory(oom)，SGI STL 本身并不会去处理oom问题，而只是提供一个 private 的函数指针成员和一个 public 的设置该函数指针的方法，让用户来自定义异常处理逻辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private:
</span><span class='line'>#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
</span><span class='line'>  static void (* __malloc_alloc_oom_handler)();  // 函数指针
</span><span class='line'>#endif
</span><span class='line'>public:
</span><span class='line'>  static void (* __set_malloc_handler(void (*__f)()))() // 设置函数指针的public方法
</span><span class='line'>  {
</span><span class='line'>    void (* __old)() = __malloc_alloc_oom_handler;
</span><span class='line'>    __malloc_alloc_oom_handler = __f;
</span><span class='line'>    return(__old);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>如果用户没有调用该方法来设置异常处理函数，那么就不做任何异常处理，仅仅是想标准错误流输出一句out of memory并退出程序（对于使用new和C++特性的情况而言，则是抛出一个<code>std::bad_alloc()</code>异常）， 因为该函数指针的缺省值为0，此时对应的异常处理是 <code>__THROW_BAD_ALLOC</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// line 152 ~ 155
</span><span class='line'>#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
</span><span class='line'>template &lt;int __inst&gt;
</span><span class='line'>void (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = 0;
</span><span class='line'>#endif
</span><span class='line'>// in _S_oom_malloc and _S_oom_realloc
</span><span class='line'>__my_malloc_handler = __malloc_alloc_oom_handler;
</span><span class='line'>if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
</span><span class='line'>// in preprocess, line 41 ~ 50
</span><span class='line'>#ifndef __THROW_BAD_ALLOC
</span><span class='line'>#  if defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)
</span><span class='line'>#    include &lt;stdio.h&gt;
</span><span class='line'>#    include &lt;stdlib.h&gt;
</span><span class='line'>#    define __THROW_BAD_ALLOC fprintf(stderr, "out of memory\n"); exit(1)
</span><span class='line'>#  else /* Standard conforming out-of-memory handling */
</span><span class='line'>#    include &lt;new&gt;
</span><span class='line'>#    define __THROW_BAD_ALLOC throw std::bad_alloc()
</span><span class='line'>#  endif
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>SGI STL 内存配置失败的异常处理机制就是这样子了，提供一个默认的处理方法，也留有一个用户自定义处理异常的接口。</p>

<h2>3. SGI STL 内置轻量级内存池的实现</h2>

<p>第一级配置器 <code>__malloc_alloc_template</code> 仅仅只是对 <code>malloc</code> 的一层封装，没有考虑可能出现的内存碎片化问题。内存碎片化问题在大量申请小块内存是可能非常严重，最终导致碎片化的空闲内存无法充分利用。SGI 于是在第二级配置器 <code>__default_alloc_template</code> 中 内置了一个轻量级的内存池。 对于小内存块的申请，从内置的内存池中分配。然后维护一些空闲内存块的链表（简记为空闲链表，free list），小块内存使用完后都回收到空闲链表中，这样如果新来一个小内存块申请，如果对应的空闲链表不为空，就可以从空闲链表中分配空间给用户。具体而言SGI默认最大的小块内存大小为128bytes，并设置了128/8=16 个free list，每个list 分别维护大小为 8, 16, 24, &#8230;, 128bytes 的空间内存块（均为8的整数倍），如果用户申请的空间大小不足8的倍数，则向上取整。</p>

<p>SGI STL内置内存池的实现请看 <code>__default_alloc_template</code> 中被定义为 private 的这些成员变量和方法（去掉了部分预处理代码和互斥处理的代码）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private:
</span><span class='line'>#if ! (defined(__SUNPRO_CC) || defined(__GNUC__))
</span><span class='line'>    enum {_ALIGN = 8}; // 对齐大小
</span><span class='line'>    enum {_MAX_BYTES = 128}; // 最大有内置内存池来分配的内存大小
</span><span class='line'>    enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN  // 空闲链表个数
</span><span class='line'># endif
</span><span class='line'>  static size_t  _S_round_up(size_t __bytes) // 不是8的倍数，向上取整
</span><span class='line'>    { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }
</span><span class='line'>__PRIVATE:
</span><span class='line'>  union _Obj { // 空闲链表的每个node的定义
</span><span class='line'>        union _Obj* _M_free_list_link;
</span><span class='line'>        char _M_client_data[1];   };
</span><span class='line'>  static _Obj* __STL_VOLATILE _S_free_list[]; // 空闲链表数组
</span><span class='line'>  static size_t _S_freelist_index(size_t __bytes) { // __bytes 对应的free list的index
</span><span class='line'>        return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);
</span><span class='line'>  }
</span><span class='line'>  static void* _S_refill(size_t __n); // 从内存池中申请空间并构建free list，然后从free list中分配空间给用户
</span><span class='line'>  static char* _S_chunk_alloc(size_t __size, int& __nobjs); // 从内存池中分配空间
</span><span class='line'>  static char* _S_start_free;  // 内存池空闲部分的起始地址
</span><span class='line'>  static char* _S_end_free; // 内存池结束地址
</span><span class='line'>  static size_t _S_heap_size; // 内存池堆大小，主要用于配置内存池的大小</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>_S_refill</code> 和 <code>_S_chunk_alloc</code> 这两个函数是该内存池机制的核心。 <code>__default_alloc_template</code> 对外提供的 public 的接口有 <code>allocate</code>, <code>deallocate</code> 和 <code>reallocate</code> 这三个，其中涉及内存分配的 <code>allocate</code> 和 <code>reallocate</code> 的逻辑思路是，首先看申请的size（已round up）对应的free list是否为空，如果为空，则调用 <code>_S_refill</code> 来分配，否则直接从对应的free list中分配。而 <code>deallocate</code> 的逻辑是直接将空间插入到相应free list的最前面。</p>

<p>函数 <code>_S_refill</code> 的逻辑是，先调用 <code>_S_chunk_alloc</code> 从内存池中分配20块小内存（而不是用户申请的1块），将这20块中的第一块返回给用户，而将剩下的19块依次链接，构建一个free list。这样下次再申请同样大小的内存就不用再从内存池中取了。有了 <code>_S_refill</code> ，用户申请空间时，就不是直接从内存池中取了，而是从 free list 中取。因此 <code>allocate</code> 和 <code>reallocate</code> 在相应的free list为空时都只需直接调用 <code>_S_refill</code> 就行了。</p>

<p>这里默认是依次申请20块，但如果内存池空间不足以分配20块时，会尽量分配足够多的块，这些处理都在 <code>_S_chunk_alloc</code> 函数中。该函数的处理逻辑如下（源代码这里就不贴了）：</p>

<blockquote><p>1) 能够分配20块</p>

<blockquote><p>从内存池分配20块出来，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>2) 不足以分配20块，但至少能分配一块</p>

<blockquote><p>分配经量多的块数，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>3) 一块也分配不了</p>

<blockquote><p>首先计算新内存池大小 <code>size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4)</code><br/>
将现在内存池中剩余空间插入到适当的free list中<br/>
调用 <code>malloc</code> 来获取一大片空间作为新的内存池：<br/>
&#8211; 如果分配成功，则调整 <code>_S_end_free</code> 和 <code>_S_heap_size</code> 的值，并重新调用自身，从新的内存池中给用户分配空间；
&#8211; 否则，分配失败，考虑从比当前申请的空间大的free list中分配空间，如果无法找不到这样的非空free list，则调用第一级配置器的allocate，看oom机制能否解决问题</p></blockquote></blockquote>

<p>SGI STL的轻量级内存池的实现就是酱紫了，其实并不复杂。</p>

<h2>4. SGI STL 内存池在多线程下的互斥访问</h2>

<p>最后，我们来看看SGI STL中如何处理多线程下对内存池互斥访问的（实际上是对相应的free list进行互斥访问，这里访问是只需要对free list进行修改的访问操作）。在SGI的第二级配置器中与内存池互斥访问相关的就是 <code>_Lock</code> 这个类了，它仅仅只包含一个构造函数和一个析构函数，但这两个函数足够了。在构造函数中对内存池加锁，在析构函数中对内存池解锁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//// in __default_alloc_template
</span><span class='line'># ifdef __STL_THREADS
</span><span class='line'>    static _STL_mutex_lock _S_node_allocator_lock; // 互斥锁变量
</span><span class='line'># endif
</span><span class='line'>class _Lock {
</span><span class='line'>    public:
</span><span class='line'>        _Lock() { __NODE_ALLOCATOR_LOCK; }
</span><span class='line'>        ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }
</span><span class='line'>};
</span><span class='line'>//// in preprocess
</span><span class='line'>#ifdef __STL_THREADS
</span><span class='line'># include &lt;stl_threads.h&gt; // stl 的线程，只是对linux或windows线程的一个封装
</span><span class='line'># define __NODE_ALLOCATOR_THREADS true
</span><span class='line'># ifdef __STL_SGI_THREADS
</span><span class='line'>#   define __NODE_ALLOCATOR_LOCK if (threads && __us_rsthread_malloc) \
</span><span class='line'>                { _S_node_allocator_lock._M_acquire_lock(); }  // 获取锁
</span><span class='line'>#   define __NODE_ALLOCATOR_UNLOCK if (threads && __us_rsthread_malloc) \
</span><span class='line'>                { _S_node_allocator_lock._M_release_lock(); }  // 释放锁
</span><span class='line'># else /* !__STL_SGI_THREADS */
</span><span class='line'>#   define __NODE_ALLOCATOR_LOCK \
</span><span class='line'>        { if (threads) _S_node_allocator_lock._M_acquire_lock(); }
</span><span class='line'>#   define __NODE_ALLOCATOR_UNLOCK \
</span><span class='line'>        { if (threads) _S_node_allocator_lock._M_release_lock(); }
</span><span class='line'># endif
</span><span class='line'>#else /* !__STL_THREADS */
</span><span class='line'>#   define __NODE_ALLOCATOR_LOCK
</span><span class='line'>#   define __NODE_ALLOCATOR_UNLOCK
</span><span class='line'>#   define __NODE_ALLOCATOR_THREADS false
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>由于在 <code>__default_alloc_template</code> 的对外接口中，只有 <code>allocate</code> 和 <code>deallocate</code> 中直接涉及到对free list进行修改的操作，所以在这两个函数中，在对free list进行修改之前，都要实例化一个 <code>_Lock</code> 的对象 <code>__lock_instance</code> ，此时调用构造函数进行加锁，当函数结束时，的对象 <code>__lock_instance</code> 自动析构，释放锁。这样，在多线程下，可以保证free list的一致性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(0) STL简介]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/08/stl-source-insight-0-stl-overview/"/>
    <updated>2014-06-08T21:39:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/08/stl-source-insight-0-stl-overview</id>
    <content type="html"><![CDATA[<h2>0. 两个问题</h2>

<p>在介绍 STL 之前，先讨论两个问题：为什么要剖析 STL 源代码？如何剖析 STL 源代码？</p>

<p>首先是为什么要剖析 STL 源代码呢？ 有人会说，会使用 STL 不就性了，为什么一定要知道其内部的机制呢？ 对于大多数程序猿来说，确实没有必要去阅读或分析 STL 的源代码，但如果要想提升自己的编程修养，要相让自己编码的思想境界提升一个档次，还是很有必要读读 STL 这样的大师制作。阅读和分析之后，你会明白STL是如何分配和管理内存的（特别是对vector、string、deque等动态数据结构），是如何实现各种数据结构（特别是红黑树等比较复杂的数据结构）和相关算法的，又是如何将这些组件融合起来实现高内聚低耦合的。或许用《洋葱》的几句歌词获取最能表达你的明白这些问题之后的心情：</p>

<blockquote><p>如果你愿意一层一层<br/>
一层的剥开我的心<br/>
你会发现<br/>
你会讶异<br/>
你是我<br/>
最压抑<br/>
最深处的秘密</p>

<p>如果你愿意一层一层<br/>
一层的剥开我的心<br/>
你会鼻酸<br/>
你会流泪<br/>
只要你能<br/>
听到我<br/>
看到我的全心全意</p></blockquote>

<p>那么，如何剖析源代码呢？其实歌词中已经蕴含这答案了，那就是“一层一层一层的剥开”。当然，我这里说的一层一层不是说要一个函数step in 到底，而是说要按层次解读：首先从最外层结构框架着手，从整体上把握；然后从细处着笔，一个组件一个组件的来分析；在分析每个组件时，也是先把握改组件的全貌及其与其他组件的关联关系，然后在深入组件内部，了解其实现。在阅读和分析源码的过程中，首先要理解其功能，然后在看它是如何实现的。切忌纠缠于代码的细节或陷入源码而不能自拔，即坠入“不识庐山真面目，只缘身在此山中”的深渊！</p>

<p>因此，本文的目的在于，站在STL这座大山的山顶，一窥其全貌。随后的文章则深入每个组件，细细观赏每一处的风景。</p>

<!-- more -->


<h2>1. STL 简史</h2>

<p>声明：这里的内容主要来自<a href="http://zh.wikipedia.org/">Wiki中文网</a>，这里尽量简化其描述，虽然是尽量剪裁，但可能还是有些罗嗦，而且大段copy，掩面 ~(@&and;-&and;@)~</p>

<p>STL 是 Standard Template Library（标准模板库）的缩写。Standard 是指STL是C++标准程序库的一部分，Template是指STL是一套模板，这也是STL最本质的特征。标准模板库使得C++编程语言在有了同Java一样强大的类库的同时，保有了更大的可扩展性。</p>

<p>标准模板库系由 <a href="http://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a> 创造于1979年前后，这也正是 <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a> 创造C++的年代（非常巧的是，这两为大师都出生于1950年）。</p>

<p>Stepanov早期从事教育工作，在20世纪70年代就开始研究泛型程序设计了。1983年，Stepanov先生转至Polytechnic大学教书，继续研究泛型程序设计，同时写了许多Scheme的程序，应用在graph与network的算法上。1985年又转至GE公司专门教授高级程序设计，并将graph与network的Scheme程序，改用Ada写，用了Ada以后，他发现到一个动态（dynamically）类型的程序（如Scheme）与强制（strongly）类型的程序（如Ada）有多么的不同。在动态类型的程序中，所有类型都可以自由的转换成别的类型，而强制类型的程序却不能。但是，强制类型在出错时较容易发现程序错误。</p>

<p>1988年Stepanov先生转至HP公司运行开发泛型程序库的工作。此时，他已经认识C语言中指针(pointer)的威力，他表示一个程序员只要有些许硬件知识，就很容易接受C语言中指针的观念，同时也了解到C语言的所有数据结构均可以指针间接表示，这点是C与Ada、Scheme的最大不同。Stepanov认为，虽然C++中的继承功能可以表示泛型设计，但终究有个限制。虽然可以在基础类型（superclass）定义算法和接口，但不可能要求所有对象皆是继承这些，而且庞大的继承体系将降低虚拟（virtual）函数的运行效率，这便违反了所谓的“效率”原则。</p>

<p>在C++标准及C++模板概念的标准化过程中，Stepanov参加了许多有关的研讨会，并与C++之父Bjarne讨论模板的设计细节。Stepanov认为C++的函数模板（function template）应该像Ada一样，在声明其函数原型后，应该显式的声明一个函数模板之实例（instance）；Bjarne则不然，他认为可以通过C++的重载（overloading）功能来表达。几经争辩，Stepanov发现Bjarne是对的。</p>

<p>事实上，C++的模板，本身即是一套复杂的宏语言（macro language），宏语言最大的特色为：所有工作在编译时期就已完成。显式的声明函数模板之实例，与直接通过C++的重载功能隐式声明，结果一样，并无很大区别，只是前者加重程序员的负担，使得程序变得累赘。</p>

<p>1992年Meng Lee加入Alex的项目，成为另一位主要贡献者。1992年，HP泛型程序库计划退出，小组解散，只剩下Stepanov先生与Meng Lee小姐（她是东方人，标准模板库的英文名称其实是取STepanov与Lee而来），Lee先前研究的是编译器的制作，对C++的模板很熟，第一版的标准模板库中许多程序都是Lee的杰作。</p>

<p>1993年，Andy Koenig到斯坦福演讲，Stepanov便向他介绍标准模板库，Koenig听后，随即邀请Stepanov参加1993年11月的ANSI/ISO C++标准化会议，并发表演讲。Bell实验室的Andrew Koenig于1993年知道标准模板库研究计划后，邀请Alex于是年11月的ANSI/ISO C++标准委员会会议上展示其观念。并获得与会者热烈的回应。</p>

<p>1994年1月6日，Koenig寄封电子邮件给Stepanov，表示如果Stepanov愿意将标准模板库的说明文件撰写齐全，在1月25日前提出，便可能成为标准C++的一部份。</p>

<p>Alex于是在次年夏天在Waterloo举行的会议前完成其正式的提案，并以百分之八十压倒性多数，一举让这个巨大的计划成为C++ Standard的一部份。</p>

<p>标准模板库于1994年2月年正式成为ANSI/ISO C++的一部份，它的出现，促使C++程序员的思维方式更朝向泛型编程（generic program）发展。</p>

<p>目前，常见的STL实现版本有HP(Hewlett-Packard Company) STL，P.J Plauger版，Rouge Wave版，STLport版，SGI(Silicon Graphics Computer System .Inc) STL版等。</p>

<h2>2. STL 六大组件</h2>

<p>STL的官方文档将STL划分成了五个主要部分，分别是Containers（容器）、Iterators（迭代器）、Algorithms（算法）、函数对象（Function Objects）、空间分配（Memory Allocation）。而在侯姐的《STL源码剖析》中，还有一个组成部分是Adaptors（适配器）。本文也按照侯姐的规范将STL分为六个部分，而且介绍的顺序也按照他的书中的顺序来介绍。（PS：这里只是简要介绍六大组件的主要功能，真的很简要哦）</p>

<h4>2.1 Memory Allocation</h4>

<p>负责空间配置与管理，本质是实现动态空间配置、空间管理、空间释放的一系列class template。它是容器的底层接口，实际使用STL的用户是看不到Allocation的。</p>

<h4>2.2 Iterators</h4>

<p>迭代器扮演容器与算法之间的胶合剂，可以形象的理解为“泛型指针”。从实现的角度看，迭代器是一种将operator*、operator->、operator++、operator&#8211;等指针相关操作进行重载的class template。所有的STL容器都有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素，原生指针（Native pointer）也是一迭代器。</p>

<h4>2.3 Containers</h4>

<p>容器可以理解为各种数据结构，如vector、list、deque、set、map等用来存放特定结构的数据的容器，也是一系列的class template。对于普通用户而言，容器是最熟悉不过了，我们最经常使用的容器主要有 vector, queue, stack, deque, map。相信很多人对 STL 的接触是从使用容器开始的，也有很多人对 STL 印象最深刻的就是容器了。</p>

<h4>2.4 Algorithm</h4>

<p>主要是各种常用的算法，如sort、search、copy、erase、unique等。从实现的角度看，STL算法是一种function template。其中 sort 相信很多人并不陌生，在很多算法中我们都需要对数据进行排序。</p>

<h4>2.5 Function Objects</h4>

<p>函数对象的行为类似函数，但可作为算法的某种策略（policy）。从实现的角度看，函数对象是一种重载了operator()（函数调用操作符）的class或class template。</p>

<h4>2.6 Adaptors</h4>

<p>适配器是一种用来修饰容器或函数对象或迭代器的东西。例如，STL 提供queue和stack，虽然他们看似容器，但其实只能算是一种容器适配器，因为他们的底层实现完全借助于deque，所有的操作都由底层deque提供。改变functor/container/iterator的接口者称为functor/container/iterator adaptor。</p>

<h2>3. STL 各组件间的关系</h2>

<p>STL 六大组件间的关系如下图（来自侯姐《STL源码剖析》一书 p6）：<br/>
<img src="http://ibillxia.github.io/images/2014/IMAG2014060801.jpg"><br/>
其中 Container 通过 Allocator 取得数据存储空间，Alogrithm 通过 Iterator 存取 Container 内容，Functor 可以协助 Algorithm 完成不同的策略变化，Adapter 可以修饰或套接 Functor。这里的描述有些抽象，等详细了解了每个组件的功能职责后，就比较好懂了。</p>

<h2>4. SGI STL源码结构</h2>

<p>最后，这里简单介绍一下SGI STL 源码的结构。我下载的是<a href="https://www.sgi.com/tech/stl/download.html">SGI-STL-v3.3</a>， 它是基于1994年HP版STL改造而成的，最新版本v3.3的更新时间是2000年6月8日，共91个文件（SGI-STL官网文档中只列出了90个文件，少列了<code>vector.h</code>这个文件），1.1M大小（其实总代码量并不是很大，非常轻量级 (*&and;-&and;*) ，比较适合拿来彻底分析一遍 ）。</p>

<p>在这91个文件中，有<strong>37个</strong>以 <code>stl_</code> 开头的文件，这些都是STL内部实现文件。有<strong>23个</strong>无扩展名的文件，这些都是STL对外提供的标准接口。 有<strong>11个</strong>与无扩展名文件同名的.h文件，这是对应的old-style形式的头文件（至于为什么不是每个无扩展名（new-style）头文件都有对应的 <code>.h</code> 文件，我也不太清楚）。 还有<strong>20个</strong>文件，主要是为 <code>stl_</code> 开头的文件提供比较 common 的功能，如 <code>algobase.h</code>、<code>hashtable.h</code> 等，或者是对 <code>stl_</code> 开头的文件进行一次内部封装，还有其他一些杂项功能等。</p>

<h2>5. 参考及推荐</h2>

<h3>推荐阅读</h3>

<p>介绍STL模板的书，有两本比较经典：<br/>
一本是《Generic Programming and the STL》，中文翻译为《泛型编程与STL模板》，这本书由STL开发者 Matthew H.Austern编著，由STL之父Alexander Stepanov等大师审核的，介绍STL思想及其使用技巧，适合初学者使用。<br/>
另一本书是《STL源码剖析》，是《深入浅出MFC》的作者侯捷编写的，介绍STL源代码的实现，适合深入学习STL，不适合初学者。</p>

<h3>源码阅读与分析工具</h3>

<p>能在Linux下用熟练使用vim最好了，实在不行用 Code::Blocks 也挺不错的，可以查找函数原型、定义、调用等。在Windows下用Source Insight最好了，可惜不是免费的，但同样也可以用Code::Blocks 或 Visual C++ Express 等 IDE。<br/>
原本想用一个UML建模工具来分析一下STL中的类之间的关系的，但是看了看源代码，基本没有太多的继承之类的关系，而且很多UML工具对C++源码自动生成类图的功能支持得并不好，就放弃了。</p>

<h3>参考</h3>

<p>[1] <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">Wiki: Standard Template Library</a> <br/>
[2] <a href="http://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93">Wiki: 标准模板库</a> <br/>
[3] <a href="https://www.sgi.com/tech/stl/">Standard Template Library Programmer&#8217;s Guide</a> <br/>
[4] <a href="http://www.cnblogs.com/todototry/archive/2009/06/21/1507760.html">如何看懂源代码&#8211;(分析源代码方法)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言函数指针与C++函数调用操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/"/>
    <updated>2014-05-24T21:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在编程过程中，一些特殊的时候，我们需要向一个函数传递另一个函数的地址（比如在快速排序中，我们需要传入两个元素大小比较的函数的地址），此时在C语言中一般是通过传递一个函数指针来实现。最近在看《STL源码剖析》一书，上面提到，在C++中其实可以通过另一种方式实现，那就是函数调用操作符<code>()</code> 。本文首先介绍一下C语言中函数指针的用法，然后再介绍C++中函数调用操作符的用法。</p>

<h2>C语言中的函数指针</h2>

<p>我们先直接看一个例子吧。这个例子比较全面而且简单，其中的函数指针是带参数且有返回值的函数指针，而且还有把函数指针作为参数来传递的代码。这个例子来自 <a href="http://blog.jobbole.com/44639/">jobbole伯乐在线</a>，代码如下：</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'> 
</span><span class='line'>// 函数原型
</span><span class='line'>int add(int x, int y);
</span><span class='line'>int subtract(int x, int y);
</span><span class='line'>int domath(int (*mathop)(int, int), int x, int y);
</span><span class='line'> 
</span><span class='line'>// 加法 x+ y
</span><span class='line'>int add(int x, init y) {
</span><span class='line'>    return x + y;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 减法 x - y
</span><span class='line'>int subtract(int x, int y) {
</span><span class='line'>    return x - y;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 根据输入执行函数指针
</span><span class='line'>int domath(int (*mathop)(int, int), int x, int y) {
</span><span class='line'>    return (*mathop)(x, y);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main() {
</span><span class='line'>  // 用加法调用domath
</span><span class='line'>  int a = domath(add, 10, 2);
</span><span class='line'>  printf("Add gives: %d\n", a);
</span><span class='line'>   
</span><span class='line'>  // 用减法调用domath
</span><span class='line'>  int b = domath(subtract, 10, 2);
</span><span class='line'>  printf("Subtract gives: %d\n", b);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在函数 <code>domath</code> 中，我们可以根据传入的 <code>mathop</code> 函数指针来做不同的计算操作。另外，在该文中，最后提到函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名，解引用符 <code>*</code> 和取地址符 <code>&amp;</code> 用在函数名之前基本上都是多余的。这个之前还真不知道，新技能get，哈哈</p>

<h4>使用typedef</h4>

<p>在C语言中，对于函数指针，我们可以使用 <code>typedef</code> 将其定义为一种数据类型，这样我们就可以定义这种类型的变量了，就像使用普通的变量类型一样。下面是一个具体的定义（来自<a href="http://stackoverflow.com/questions/4295432/typedef-function-pointer">stackoverflow</a>）：</p>

<blockquote><p>typedef   void      (*FunctionFunc)  ( );
//         ^                ^         ^
//     return type      type name  arguments</p></blockquote>

<p>这里 <code>typedef</code> 的使用方法与一般的 <code>typedef A B</code> 的使用方式不不大一样的，如果没有接触过这种用法，可能开起来很别扭（在很多开源库中可能经常会碰到）。下面是其具体使用的实例（不完整代码）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FunctionFunc x;
</span><span class='line'>void doSomething() { printf("Hello there\n"); }
</span><span class='line'>x = &doSomething;
</span><span class='line'>x(); //prints "Hello there"</span></code></pre></td></tr></table></div></figure>


<p>根据上面提到的隐式转换，这里的取址符其实是没有必要的。关于C语言的函数指针就介绍到这儿了，接下来介绍一下C++的函数调用操作符。</p>

<h2>C++中的函数调用操作符</h2>

<p>在C++中，函数调用操作符是指左右小括弧 <code>()</code> ，该操作符是可以重载的。许多 STL 算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时按照使用者自定义的大小关系进行排序）。 上面讲了，在C语言中使用者是通过传递函数指针的方式来实现的。然而，函数指针有一些缺点，最重要的是它无法持有自己的状态（这里指局部状态，local states，具体可以通过后面的例子来理解），也无法达到组件技术中的可适配性 —— 也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>

<p>在C++中，对应于C中函数指针的东西是仿函数（functor），使用起来就像函数一样。其实现方法是对某个 class 进行 <code>operator()</code> 重载，他就成为一个仿函数。而要成为一个可适配（adaptable）的仿函数，还需要其他的一些努力（在《STL源码剖析》一书的第8章，关于适配器（adaptor）的内容）。这里，我们只拿书中的那个例子来简单的看一下仿函数的定义和使用方法吧。代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>
</span><span class='line'>// 对plus进行operator() 重载，使得 plus 变成了一个仿函数
</span><span class='line'>template&lt;class T&gt;
</span><span class='line'>struct plus{
</span><span class='line'>  T operator() (const T &x, const T &y) const {return x+y;}
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// 对 minus 进行operator() 重载，使得 minus 变成了一个仿函数
</span><span class='line'>template&lt;class T&gt;
</span><span class='line'>struct minus{
</span><span class='line'>  T operator() (const T &x, const T &y) const {return x-y;}
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>int main(){
</span><span class='line'>  // 以下产生仿函数对象
</span><span class='line'>  plus&lt;int&gt; plusObj;
</span><span class='line'>  minus&lt;int&gt; minusObj;
</span><span class='line'>  // 以下使用仿函数，就像使用一般函数一样
</span><span class='line'>  cout&lt;&lt;plusObj(3,5)&lt;&lt;endl;
</span><span class='line'>  cout&lt;&lt;minusObj(3,5)&lt;&lt;endl;
</span><span class='line'>  // 也可以这样使用，通过临时对象（匿名对象）
</span><span class='line'>  cout&lt;&lt;plus&lt;int&gt;()(3,5)&lt;&lt;endl;
</span><span class='line'>  cout&lt;&lt;minus&lt;int&gt;()(3,5)&lt;&lt;endl;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的 <code>plus&lt;T&gt;</code> 和 <code>minus&lt;T&gt;</code> 已经非常接近 STL 的实现了，唯一的差别是它缺乏“可适配能力”，关于 STL 中的适配器（adaptor），我现在也还没看完该书，也还不太了解，在后续文章中应该会介绍到。读者可以自行google。</p>

<h2>在快排中使用函数调用操作符</h2>

<p>为了加深对函数调用操作符的理解，并将其真正用到实际中，这里拿快排这个非常典型的例子，并充分利用C++及STL的特性。下面是核心代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template&lt;typename InIt,typename FuncType&gt;
</span><span class='line'>void myqsort(InIt begin, InIt end, FuncType cmp){
</span><span class='line'>  if(begin==end||begin==end-1)return;
</span><span class='line'>  InIt it = mysplit(begin,end,cmp);
</span><span class='line'>  if(it!=end){
</span><span class='line'>      myqsort(begin,it,cmp);
</span><span class='line'>      myqsort(it+1,end,cmp);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>template&lt;typename InIt,typename FuncType&gt;
</span><span class='line'>InIt mysplit(InIt begin, InIt end, FuncType cmp){
</span><span class='line'>  InIt itl,itr;
</span><span class='line'>  itl=begin;
</span><span class='line'>  itr=end-1;
</span><span class='line'>  while(itl != itr){
</span><span class='line'>      while(itl != itr && cmp(*itr,*begin)&gt;0)itr--;
</span><span class='line'>      if(itl==itr)break;
</span><span class='line'>      while(itl != itr && cmp(*begin,*itl)&gt;0)itl++;
</span><span class='line'>      if(itl==itr)break;
</span><span class='line'>      swap(*itl,*itr);
</span><span class='line'>      itr--;
</span><span class='line'>  }
</span><span class='line'>  return itl;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Test{
</span><span class='line'>public:
</span><span class='line'>  double m_lf;
</span><span class='line'>  string m_str;
</span><span class='line'>
</span><span class='line'>public:
</span><span class='line'>  void set(){
</span><span class='line'>      cin&gt;&gt;m_lf;
</span><span class='line'>      cin&gt;&gt;m_str;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  void print(){
</span><span class='line'>      cout&lt;&lt;m_lf&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;m_str&lt;&lt;endl;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct cmpd{
</span><span class='line'>  int operator()(Test a,Test b){
</span><span class='line'>      if(abs(a.m_lf - b.m_lf)&lt;INF)return 0;
</span><span class='line'>      if(a.m_lf &gt; b.m_lf)return 1;
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct cmps{
</span><span class='line'>  int operator()(Test a,Test b){
</span><span class='line'>      return a.m_str.compare(b.m_str);
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>完整的代码及测试输入可以通过以下链接打包下载：<a href="https://ibillxia.github.io/upload/code/20140525.tar.gz">code-2014-05-25</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解C语言的define和内联函数]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c/"/>
    <updated>2014-05-17T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在 <code>Robert C.Searcord</code> 的 <em>The</em> <em>Cert</em> <em>C</em> <em>Secure</em> <em>Coding</em> <em>Standard</em> 一书中，关于宏定义的规范中第一条就是</p>

<blockquote><p>用内联函数或静态函数替代与函数相似的宏</p></blockquote>

<p>这个规范非常实用。内联函数是C99标准中新增的，当宏定义和内联函数可以互换时，应该优先考虑选择内联函数，这也是为什么在C++标准库函数中 <code>max</code>, <code>min</code>, <code>swap</code> 等都是通过内联函数来实现的原因。 宏定义是完全原封不动的很SB的替换，而内联函数则并非简单的文本替换，而是按函数调用的方式展开。关于内联函数相对于宏替换的优点，在wiki有如下几点的总结：</p>

<ul>
<li>宏调用并不执行类型检查，甚至连正常参数也不检查，但是函数调用却要检查。</li>
<li>C语言的宏使用的是文本替换，可能导致无法预料的后果，因为需要重新计算参数和操作顺序。</li>
<li>在宏中的编译错误很难发现，因为它们引用的是扩展的代码，而不是程序员键入的。</li>
<li>许多结构体使用宏或者使用不同的语法来表达很难理解。内联函数使用与普通函数相同的语言，可以随意的内联和不内联。</li>
<li>内联代码的调试信息通常比扩展的宏代码更有用。</li>
</ul>


<p>其中前面两条很好理解，相信大家应该不陌生，这里主要通过具体讨论一个该书中提到的一个程序实例来感受一下后面几点。</p>

<!-- more -->


<h2>宏定义引起的运行时错误</h2>

<p>下面我们看一个稍微复杂的例子，这个例子是在运行时才出现另我们感到意外的错误（这里的运行时错误并不是指 <code>Runtime Error</code>，么么哒）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int count=0;
</span><span class='line'>
</span><span class='line'>void g(void){
</span><span class='line'>    printf("Called g, count=%d.\n",count);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#define EXEC_BUMP(func) (func(),++count)
</span><span class='line'>typedef void(*exec_func)(void);  // 定义函数指针类型
</span><span class='line'>inline void exec_bump(exec_func f){
</span><span class='line'>    f();
</span><span class='line'>    ++count;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(void)
</span><span class='line'>{
</span><span class='line'>    int count=0;
</span><span class='line'>    while(count++&lt;10){
</span><span class='line'>        //EXEC_BUMP(g);  // (1) 宏定义实现
</span><span class='line'>      exec_bump(g);    // (2) 内联实现
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>使用宏定义的实现得到输出如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.</span></code></pre></td></tr></table></div></figure>


<p>这并不是我们想要的结果。而使用内联函数实现得到的输出如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=1.
</span><span class='line'>Called g, count=2.
</span><span class='line'>Called g, count=3.
</span><span class='line'>Called g, count=4.
</span><span class='line'>Called g, count=5.
</span><span class='line'>Called g, count=6.
</span><span class='line'>Called g, count=7.
</span><span class='line'>Called g, count=8.
</span><span class='line'>Called g, count=9.</span></code></pre></td></tr></table></div></figure>


<p>这才是我们想要的结果。根据这两个输出结果，我们可以分析宏定义和内联的区别。通过宏定义时，直接使用 <code>(g(),++count);</code> 替换 <code>EXEC_BUMP(g);</code> 即可，这样每次调用 <code>g()</code> 函数时输出的 <code>count</code> 是全局的变量，所以都是0；而调用完 <code>g()</code> 函数之后，对局部变量 <code>count</code> 进行了自加操作，所以循环了5次。然而使用内联函数实现时，是按照函数调用的方式展开的，首先将全局变量和内联函数的传入参数压栈，然后是执行函数体，最后参数出栈；因此，内联函数中调用 <code>g()</code> 函数时输出的 <code>count</code> 也是全局变量，而且在内联函数中的 <code>++count</code> 也是对全局变量的操作，因此每次调用时输出的计数变量是递增的。  由此，我们可以更清楚的理解内联函数的替换原理了，它是由编译器显式地将函数调用中的压栈、函数体、出栈等步骤生成到可执行文件中，而不是像普通函数那样，函数体与调用该函数的代码部分是分离的，在调用内联函数时不需要跳转，因而执行效率会比普通的函数要高。（然而，如果函数本身代码较多，如果使用内联，就会在可执行文件中多个地方有该内联函数的函数体，这样可执行文件的大小就会比不使用内联的大。因此，一般不会将函数体复杂的函数定义为内联函数，除非特殊情况下，为了运行时间性能的考虑）</p>

<h2>宏定义的典型应用场景</h2>

<p>上面主要是对宏定义的贬低和歧视，其实宏定义也并非毫无用武之地，下面几种情况下宏定义还是不可替代的：</p>

<p>（1）用于实现局部函数 <br/>
此时无法用内联函数替代宏定义。因为宏定义代码块中的自动变量可以和引用宏的前后代码块互为使用，即宏引用前的代码快中的自动变量可以在宏中直接使用，而宏中定义的自动变量可以在宏引用的代码块之后使用。例如，比较常见是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#define FOR(i,n) for(int i=0;i&lt;n;i++)  // 宏定义部分
</span><span class='line'>
</span><span class='line'>int main(){
</span><span class='line'>  int a[]={1,2,3,4,5};
</span><span class='line'>  FOR(j,5) // 宏引用，这里j是在宏中才定义的自动变量
</span><span class='line'>      printf("%d ",a[j]);  // 但是可以在宏引用之后的代码中使用
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中对临时变量 <code>j</code> 的声明是在宏中定义的，可以在宏调用完后使用这个变量。同样的，也可以在宏定义前声明临时变量，而直接在宏中使用（不需要作为参数传递给宏）。</p>

<p>（2）宏可以支持某种形式的惰式计算<br/>
例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SELECT(s,v1,v2) ((s)?(v1):(v2))</span></code></pre></td></tr></table></div></figure>


<p>这个是无法用内联实现的。</p>

<p>(3)宏定义可以产生编译时常量<br/>
例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define ADD(a,b) ((a)+(b))</span></code></pre></td></tr></table></div></figure>


<p>调用 <code>ADD(3,4)</code> 会产生一个常量表达式 <code>3+4</code> ，而内联无此效果。</p>

<p>（4）实现类型通用的函数<br/>
如果不借助C++模板这样的机制，C语言内联是无法实现这样的功能的，而只能针对不同的数据类型定义不同名的函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 应用程序性能优化之 new/delete 操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator/"/>
    <updated>2014-05-11T20:33:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>

<p>C++ 程序的存储空间可以分为静态/全局存储区、栈区和堆区。下图展示了一个典型的Linux C/C++ 程序内存空间布局：</p>

<center><img src="http://ibillxia.github.io/images/2014/IMAG2014051101.png"></center>


<p>其中，每一部分的具体涵义如下：<br/>
- <strong>代码段（.text）</strong>：这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是<strong>只读</strong>的，防止程序由于错误而修改自身的指令。<br/>
- <strong>初始化数据段（.data）</strong>：这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=100;</code> 。 需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用 exec 函数启动该程序时从源程序文件中读入。<br/>
- <strong>未初始化数据段（.bss）</strong>：位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：<code>int sum;</code><br/>
- <strong>堆（Heap）</strong>：这个段用于在程序中进行动态内存申请，例如经常用到的 malloc，new 系列函数就是从这个段中申请内存。<br/>
- <strong>栈（Stack）</strong>：函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。<br/>
静态/全局存储区和栈区一般在程序编译阶段决定；而堆区则随着程序的运行而动态变化，每一次程序运行都会有不同的行为，因此动态内存管理对于一个程序在运行过程中占用的内存大小及程序运行性能有非常重要的影响。 本文主要探讨在C++中如何管理动态内存，以及如何使用 C++ 的语言特性来提高动态内存的管理效率，减少错误的发生。</p>

<!-- more -->


<h2>2. new/delete 操作符</h2>

<h4>2.1 C++内置new/delete的原型</h4>

<p>一般来说 C++ 的运行库提供了默认的全局 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的实现，程序也可以用自定义的实现来取代运行库的实现。 下面是 C++ 标准中定义的 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的声明（位于 <code>include/c++/new</code> 文件中）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>namespace std {
</span><span class='line'>  class bad_alloc : public exception {
</span><span class='line'>    public:
</span><span class='line'>      bad_alloc() throw() { }
</span><span class='line'>      virtual ~bad_alloc() throw();
</span><span class='line'>      virtual const char* what() const throw();
</span><span class='line'>  };
</span><span class='line'>  struct nothrow_t { };
</span><span class='line'>  extern const nothrow_t nothrow;
</span><span class='line'>  typedef void (*new_handler)();
</span><span class='line'>  new_handler set_new_handler(new_handler) throw();
</span><span class='line'>} // namespace std
</span><span class='line'>
</span><span class='line'>void* operator new(std::size_t) throw (std::bad_alloc);  // (1)
</span><span class='line'>void* operator new[](std::size_t) throw (std::bad_alloc);
</span><span class='line'>void operator delete(void*) throw();
</span><span class='line'>void operator delete[](void*) throw();
</span><span class='line'>void* operator new(std::size_t, const std::nothrow_t&) throw();  // (2)
</span><span class='line'>void* operator new[](std::size_t, const std::nothrow_t&) throw();
</span><span class='line'>void operator delete(void*, const std::nothrow_t&) throw();
</span><span class='line'>void operator delete[](void*, const std::nothrow_t&) throw();
</span><span class='line'>// Default placement versions of operator new.
</span><span class='line'>inline void* operator new(std::size_t, void* __p) throw() { return __p; }  // (3)
</span><span class='line'>inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
</span><span class='line'>// Default placement versions of operator delete.
</span><span class='line'>inline void  operator delete  (void*, void*) throw() { }
</span><span class='line'>inline void  operator delete[](void*, void*) throw() { }</span></code></pre></td></tr></table></div></figure>


<p>其中最后的 <code>inline</code> 函数是 <code>placement</code> 版本的 new/delete 操作，其特点在于分配的内存块的起始地址由用户给定（通过参数 <code>void* __p</code>）。 而前面两种 <code>new/delete</code> （(1)和(2)处）是系统决定待分配内存块的起始地址，区别在于：第一个在分配失败是会抛出 <code>bad_alloc</code> 异常（这是C++标准要求的）；而第二个则不抛出异常，返回0。 很多应用程序都没有处理内存分配的失败情况，但相对于一个需要长期稳定运行的系统来说，这种处理是必不可少的。 应用程序可以通过捕获 <code>bad_alloc</code> 异常或者检查返回值来检查内存分配是否成功，而更好的方法是使用C++中的 <code>new_handler()</code> 函数。 C++规定 <code>new_handler</code> 要执行如下操作中的一种：</p>

<ul>
<li>使 <code>new</code> 有更多的内存可用，然后返回</li>
<li>抛出一个 <code>bad_alloc</code> 或其派生类的异常</li>
<li>调用 <code>abort()</code> 或者 <code>exit()</code> 退出</li>
</ul>


<h4>2.2 使用 <code>new_handler</code> 自定义异常处理</h4>

<p>下面看一个例子，看看如何使用 <code>new_handler</code> 处理内存分配失败的情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;new&gt;
</span><span class='line'>#include&lt;cstdio&gt;
</span><span class='line'>#include&lt;Windows.h&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>char *gPool = NULL;
</span><span class='line'>void my_new_handler();
</span><span class='line'>
</span><span class='line'>int main(){
</span><span class='line'>    set_new_handler(my_new_handler);
</span><span class='line'>    gPool = new char[512*1024*1024];
</span><span class='line'>    if(gPool!=NULL){
</span><span class='line'>        printf("Preserve 512MB memory at %x.\n",gPool);
</span><span class='line'>    }
</span><span class='line'>    char *p = NULL;
</span><span class='line'>    for(int i=0;i&lt;4;i++){
</span><span class='line'>        p = new char[512*1024*1024];
</span><span class='line'>        printf("%d * 512M, p = %x\n",i+1,p);
</span><span class='line'>        Sleep(5000); // 休眠5s
</span><span class='line'>    }
</span><span class='line'>    printf("Done.\n");
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void my_new_handler(){
</span><span class='line'>    if(gPool!=NULL){
</span><span class='line'>        printf("try to get more memory...\n");
</span><span class='line'>        delete[] gPool; // 释放512MB内存空间
</span><span class='line'>        gPool = NULL;
</span><span class='line'>        return;
</span><span class='line'>    }else{
</span><span class='line'>        printf("I can not help...\n");
</span><span class='line'>        throw bad_alloc();  // 分配失败，抛出异常
</span><span class='line'>    }
</span><span class='line'>    return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在 Windows 上编译并运行（使用Code::Blocks 13.12 IDE），得到如下输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Preserve 512MB memory at 7e0020.
</span><span class='line'>1 * 512M, p = 207f0020
</span><span class='line'>2 * 512M, p = 40800020
</span><span class='line'>try to get more memory...
</span><span class='line'>3 * 512M, p = 7e0020
</span><span class='line'>I can not help...
</span><span class='line'>terminate called after throwing an instance of 'std::bad_alloc'
</span><span class='line'>  what():  std::bad_alloc
</span><span class='line'>
</span><span class='line'>This application has requested the Runtime to terminate it in an unusual way.
</span><span class='line'>Please contact the application's support team for more information.</span></code></pre></td></tr></table></div></figure>


<p>在 Windows 的 win32 程序中，一个进程可以访问的内存空间是 4GB，但可以用来动态分配的最大内存是 2GB，因而上面的程序执行到第3次（为神马不是第4次？）动态内存分配时由于内存不够，调用了 <code>my_new_handler</code> 获得了内存（可以看到第3次分配的内存的地址和Preserve的内存地址是一样的），而当执行第4次内存分配时，<code>gPool</code> 已被分配，于是 <code>my_new_handler</code> 中抛出了 <code>bad_alloc</code> 异常，导致程序退出。 另外，在程序实际运行过程当中，会发现任务管理器中内存占用不会往上飙，这可能是因为操作系统的动态内存管理策略在作怪，不会说你一申请就立马全部给你，只是建立了一个映射表，只有当你真正用的时候才会给你。</p>

<h4>2.3 使用 placement new</h4>

<p>在 C++ 内置 <code>new/delete</code> 中最后的一种是 placement 形式的 <code>new/delete</code> ，即分配的内存地址有用户给定。下面是一个最简单的实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;cstdio&gt;
</span><span class='line'>#include &lt;new&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    char buffer[100];
</span><span class='line'>    char *p = new(buffer) char[20]; // call placement new
</span><span class='line'>    printf("Address of buffer: %x, and p: %x.\n",buffer,p);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>// output: Address of buffer: 28feb8, and p: 28feb8.</span></code></pre></td></tr></table></div></figure>


<p>可以看到 <code>buffer</code> 和 <code>p</code> 的地址是一样的。在大型应用程序中，我们可以充分利用 <code>placement new</code> 的特性，实现自己管理（分配、释放等）本应用的内存空间，基本思路就是： 首先申请一大片内存，然后对每个小的动态内存分配都使用 <code>placement new</code> 的方式进行申请。</p>

<h4>2.4 重载 placement new</h4>

<p>在 <code>new</code> 操作符中，除了可以使用自定义申请的内存的大小及位置，我们还可以通过重载系统的 <code>new/delete</code> 操作符来加入其它一些附加参数，但仍称之为 <code>placement new</code> 。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;cstdio&gt;
</span><span class='line'>#include&lt;new&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>#define DEBUG
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>// 自定义 new 操作符
</span><span class='line'>void *operator new[](unsigned int n, const char* file, int line){
</span><span class='line'>    printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
</span><span class='line'>    return ::operator new(n);
</span><span class='line'>}
</span><span class='line'>// 自定义 delete 操作符
</span><span class='line'>// void operator delete(void *p,const char *file, int line){
</span><span class='line'>void operator delete[](void *p,const char *file, int line){
</span><span class='line'>    printf("delete at file %s, in line %d\n",file,line);
</span><span class='line'>    ::operator delete(p);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>// 宏定义，必须放在重载函数之后
</span><span class='line'>#define new new(__FILE__, __LINE__)
</span><span class='line'>#define delete delete(__FILE__, __LINE__)
</span><span class='line'>#endif
</span><span class='line'>int main(){
</span><span class='line'>    char *p = new char[10];
</span><span class='line'>    //delete p;  // delete 的重载还有问题 "error: type 'int' argument given to 'delete', expected pointer"
</span><span class='line'>    delete[] p;  // 直接报语法错误，"error: expected primary-expression before ']' token"
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>// output: Alloc size: 10 at file D:\Programs\test\main.cpp, in line 22</span></code></pre></td></tr></table></div></figure>


<p>这在 <code>DEBUG</code> 模式下非常好使。</p>

<p>更新：关于 <code>placement new</code> 的 demo 改为如下代码后就没问题了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;cstdio&gt;
</span><span class='line'>#include&lt;new&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>#define DEBUG
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>// 自定义 new 操作符
</span><span class='line'>void *operator new[](unsigned int n, const char* file, int line){
</span><span class='line'>    printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
</span><span class='line'>    return ::operator new(n);
</span><span class='line'>}
</span><span class='line'>// 自定义 delete 操作符
</span><span class='line'>void operator delete(void *p,char *file, int line){
</span><span class='line'>    printf("Delete at file %s, in line %d\n",file,line);
</span><span class='line'>    ::operator delete(p);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>// 宏定义，必须放在重载函数之后
</span><span class='line'>#define new new(__FILE__, __LINE__)
</span><span class='line'>#define delete(ptr) delete(ptr,__FILE__, __LINE__)
</span><span class='line'>#endif
</span><span class='line'>int main(){
</span><span class='line'>    char *p = new char[10];
</span><span class='line'>    operator delete(p);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>但是还是不知道之前的代码为什么会出现这个错误，已在 <a href="http://stackoverflow.com/questions/23614215/destructor-error-in-c-type-int-argument-given-to-delete-expected-pointer">StackOverFlow上提问</a>，希望能得到满意的答案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 下 Android NDK 开发入门]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/04/android-ndk-development/"/>
    <updated>2014-05-04T23:53:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/04/android-ndk-development</id>
    <content type="html"><![CDATA[<p>本文首先介绍一下在 Ubuntu 下如何配置 Android NDK 开发环境，然后用一个简单的 hello-jni 项目来介绍 NDK 开发流程，本文的全部代码下载链接：<a href="https://ibillxia.github.io/upload/code/20140504-HelloJni.tar.gz">HelloJni.tar.gz</a>，也可以在我的 <a href="https://github.com/ibillxia/Demo/tree/master/HelloJni">GitHub</a> 上下载。</p>

<h2>1. 简介</h2>

<p>什么是 Android NDK 呢？ NDK(Native Development Kit) 是一个允许开发者用一些本地语言(C/C++)编写 Android App 的部分功能的工具集。对于一些特定的 App，NDK 非常有利于我们直接使用现成的用 C/C++ 编写的代码库（但对于大多数 App 来说，NDK 是没有必要的）。使用 NDK 进行 C/C++ Android 开发的基本结构和流程如下图（来自<a href="http://shihongzhi.com/ndk/">shihongzhi博客</a> ）：</p>

<center> <img src="http://ibillxia.github.io/images/2014/IMAG2014050401.jpg"> </center>


<p>在开始之前，这里要提醒大家：NDK 对大多数 App 而言是不会有太多的好处的，在 Android 上使用原生 C/C++ 代码并不会很明显的提升应用的性能，但却增加了你开发应用的复杂度。所以，仅仅在需要使用 NDK 时才使用它 —— 不要因为你更喜欢用 C/C++。典型的 NDK 应用场景是一些 CPU 操作密集而不需要太多内存的场合，如信号处理、物理模拟等等，很多这些处理过程都已经封装到了 Android 系统内部，所以当你不确定是否要使用本地 C/C++ 代码时，先看看你的需求，以及 Android 框架中的 API 是否已经提供你需要的功能。</p>

<!-- more -->


<h2>2.开发环境配置</h2>

<p>由于 NDK 开发过程中涉及到将 C/C++ 程序编译为动态库(.so文件)，所以首先系统中需要安装 C/C++ 的编译工具 gcc/g++，还要有 make 工具，一般情况下 Linux 系统会默认安装，如果没有安装请先安装这几个工具。然后是 Java 和 Android 开发相关环境的配置。首先需要安装 JDK，并配置 Java 的环境变量，然后是集成开发环境如 Eclipse 的安装和配置，这些也不是本文的重点，如果你没有安装，请自行 google 并安装配置好。</p>

<p>下面重点讲讲 Android 相关 SDK 的安装和配置，主要涉及到 Android SDK，ADT，NDK等。要进行 Android 开发，首先需要安装 Android SDK，要在 Eclipse 中进行开发的话，还需在 Eclipse 中安装 ADT(Android Develop Tools)，在 Android 官网上提供了 SDK 和 包含 ADT 的 Eclipse 的集成开发包，可以一起下载：<a href="http://dl.google.com/android/adt/22.6.2/adt-bundle-linux-x86-20140321.zip">adt-bundle-linux-x86-20140321.zip</a>。另外，还需要安装 NDK，下载地址：<a href="http://dl.google.com/android/ndk/android-ndk-r9d-linux-x86.tar.bz2">android-ndk-r9d-linux-x86.tar.bz2</a>。下载完这两个压缩包后解压并移动到 /usr/local 目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo mv Downloads/adt-bundle-x86-20140321/ /usr/local/adt-x86-20140321 
</span><span class='line'>mv Downloads/android-ndk-r9d/ /usr/local/adt-x86-20140321/ndk-r9d </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后配置环境变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo vim /etc/profile </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在 /etc/profile 最后添加如下两行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PATH=/usr/local/adt-x86-20140321/sdk/tools:/usr/local/adt-x86-20140321/sdk/platform-tools:$PATH 
</span><span class='line'>export PATH=/usr/local/adt-x86-20140321/ndk-r9d:$PATH </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>保存并退出，并用如下命令使设置生效：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source /etc/profile </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>完了可以执行如下命令看看设置是否生效：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo $PATH 
</span><span class='line'>adb --version 
</span><span class='line'>emulator -version 
</span><span class='line'>ndk-build --version </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>至此，开发环境已经配置完成了，接下来我们看一个 hello-jni 的例子。</p>

<h2>3.NDK 开发实例 hello-jni</h2>

<h4>3.1 JNI 简介</h4>

<p>首先我们了解一下什么是JNI。JNI(Java Native Interface)是一种在Java虚拟机控制下执行代码的标准机制。 代码被编写成汇编程序或者C/C++程序，并组装为动态库，从而提供了一个在Java平台上调用C/C++的一种途径。 JNI主要的竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及在某些具体平台上的Java虚拟机兼容性（当谈及JNI，这里并不特别针对Dalvik；JNI由Oracle开发，适用于所有Java虚拟机）。 关于JNI的更多内容可以参见该文：<a href="http://www.importnew.com/8038.html">Android NDK介绍</a>。</p>

<h4>3.2 Eclipse 配置</h4>

<p>下面以参考 Android NDK 自带的 hello-jni 示例程序改写的我自己的 hello-jni 来介绍开发流程。首先打开 Eclipse 并配置 Android SDK 和 NDK 的路径。 选择 Eclipse 的如下菜单：Window =&gt; Preferences =&gt; Android，点击浏览按钮设置 SDK 路径；Window =&gt; Preferences =&gt; Android =&gt; NDK，点击浏览按钮设置 NDK 路径。接下来按照简介中的开发流程图来一步一步介绍 NDK 开发步骤。</p>

<h4>3.3 创建 Android App 并添加 Native Support</h4>

<p>首先用Eclipse 创建一个空的 Android App，命名为 HelloJni。在项目上点击右键，选择 Android Tools =&gt; Add Native Support&#8230; ，在弹出的对话框中填入 HelloJni 并确定，会发现项目中多了一个 jni 目录，并自动生成了 HelloJni.cpp 和 Android.mk 文件，分别是我们需要封装的native C++ 代码和编译它的 Makefile 文件。</p>

<h4>3.4 编写 java API</h4>

<p>原本按照图一中的流程我们需要先编写一些 C/C++ 原生的代码，但实际中，为了简便起见，我们可以使用 jdk 的 javah 工具（如果没有， <code>sudo apt-get update</code> 一下）来根据 java 调用 C/C++ API 的接口类来自动生成 jni 的头文件。因此，我们需要先做第3步的内容，这里编写的 Java API 接口 HelloCal 类（在 <code>src/io.ibillxia.hellojni</code> 路径下）如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//HelloCal.java
</span><span class='line'>package io.ibillxia.hellojni; 
</span><span class='line'>
</span><span class='line'>public class HelloCal { 
</span><span class='line'>  static { 
</span><span class='line'>      System.loadLibrary("HelloJni"); // 加载 jni 动态库 
</span><span class='line'>  } 
</span><span class='line'>  
</span><span class='line'>  public native String helloSay(); // 返回字符串 
</span><span class='line'>  public native int helloAdd(int a,int b); // 两个整数相加 
</span><span class='line'>  public native int helloSub(int a,int b); // 两个整数相减 
</span><span class='line'>  public native int helloMul(int a,int b); // 两个整数相乘 
</span><span class='line'>  public native int helloDiv(int a,int b); // 两个整数相除 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>3.5 使用 javah 生成 jni 格式的 C/C++ API</h4>

<p>编写完 java API 后在 Eclipse 中 build 一下生成对应 .class 文件，然后使用 javah 工具根据该 class 文件自动生成 jni API 的头文件。在 HelloJni App 根目录下执行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>javah -classpath ./bin/classes -d jni io.ibillxia.hellojni.HelloCal </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>其中 <code>-classpath ./bin/classes</code> 表示类的路径，<code>-d jni</code> 表示生成的头文件存放的目录， <code>io.ibillxia.hellojni.HelloCal</code> 则是完整类名，如果不出意外，在 <code>~/workspace/HelloJni/jni</code> 目录下生成了 <code>io_ibillxia_hellojni_HelloCal.h</code> 。然后根据这个头文件的内容，编写 <code>HelloCal.cpp</code> 文件实现头文件中声明的接口，具体的头文件和 cpp 源文件内容见源码压缩包。值得一提的是，在 cpp 源文件中，对数据运算后可能产生溢出进行了判断，对于溢出异常这里处理的办法是，如果上溢则返回最大值，下溢则返回最小值。实际中，这样做可能还不是很合理，比较好的做法是，在 cpp 中处理并返回异常值，并在相应的 Java API 中针对返回的异常值进行不同的处理，即在 cpp 中只检查异常，而真正处理异常则由 Java API 来处理。</p>

<p>注意，这里需要添加一下 C/C++ 的包含目录，否则会报错。选中 jni文件夹，右键选择 Properties =&gt; C/C++ General =&gt; Paths and Symbols =&gt; Includes，点击 Add 一个一个添加如下依赖库：</p>

<blockquote><p>/usr/include<br/>
/usr/include/c++/4.8<br/>
/usr/include/c++/4.8/backward<br/>
/usr/include/i386-linux-gnu<br/>
/usr/include/i386-linux-gnu/c++/4.8<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed<br/>
/usr/local/include<br/>
/usr/local/adt-x86-20140321/ndk-r9d/platforms/android-19/arch-arm/usr/include</p></blockquote>

<p>添加完后 build 一下，看看是否有错误，如果不出意外，应该在 <code>HelloJni/libs/armeabi/</code> 目录下生成了 <code>libHelloJni.so</code> 文件。</p>

<h4>3.6 编写 Android App</h4>

<p>最后是编写 Android App，并在 App 中调用 Jni 接口函数。在 <code>io.ibillxia.hellojni</code> 包中新建一个 Java 类 HelloJni ，编写如下代码（import 内容省略，具体见源码压缩包）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//HelloJni.java
</span><span class='line'>public class HelloJni extends Activity {
</span><span class='line'>    /** Called when the activity is first created. */
</span><span class='line'>    @Override
</span><span class='line'>    public void onCreate(Bundle savedInstanceState)
</span><span class='line'>    {
</span><span class='line'>        super.onCreate(savedInstanceState);
</span><span class='line'>        setContentView(R.layout.hello_jni);
</span><span class='line'>        
</span><span class='line'>        Button btn = (Button)findViewById(R.id.btn_cal);
</span><span class='line'>        btn.setOnClickListener(new Button.OnClickListener() {
</span><span class='line'>          @Override
</span><span class='line'>          public void onClick(View v) {
</span><span class='line'>              // TODO Auto-generated method stub
</span><span class='line'>              TextView tv1 = (TextView) findViewById(R.id.textView1);
</span><span class='line'>              TextView tv2 = (TextView) findViewById(R.id.textView2);
</span><span class='line'>              TextView tv3 = (TextView) findViewById(R.id.textView3);
</span><span class='line'>
</span><span class='line'>              int a = Integer.parseInt(tv1.getText().toString());
</span><span class='line'>              int b = Integer.parseInt(tv2.getText().toString());
</span><span class='line'>              HelloCal cal = new HelloCal();
</span><span class='line'>              int c = cal.helloAdd(a,b);
</span><span class='line'>              String str = cal.helloSay();  
</span><span class='line'>              tv3.setText(str + Integer.toString(c));
</span><span class='line'>          }
</span><span class='line'>        });
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>另外，还需要设计对应的 layout xml 文件，具体见源码压缩包。 最后上一张运行效果截图：
<img src="http://ibillxia.github.io/images/2014/IMAG2014050402.png">
图中输入的两个数的和超过了 int 能表示的最大值，出现上溢，但返回的是最大值。如果输入的两个数本身就超出范围将出现
<code>Unfortunately, HelloJni has stopped.</code> 的异常的对话框。实际过程中，究竟在哪一步检测并处理异常，还是一个值得商讨的问题。如果是引用第三方的库，可能需要对相应的接口提供充分的测试，对于可以并且方便在 native code 层面解决的异常就在 native code 层面上处理掉，实在不行也要在 Java API 层面上解决掉，比如这里需要在 Java 中判断输入参数本身的合法性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Octopress博客配置Twitter Bootstrap主题]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress/"/>
    <updated>2014-04-28T22:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress</id>
    <content type="html"><![CDATA[<p>很长一段时间以来就看到各种基于 Twitter Bootstrap 主题的博客很清爽，而且对 Tag 的归档也做得很赞，于是很想将自己的博客也换成 Bootstrap 的主题，随着看到的博客越来越多，自己的 Octopress 主题先得越来越臃肿，而 Tags 归档功能也相形见绌，更换主题的欲望越来越强烈了。于是乎，趁这个周末捣鼓了一番，最终大功告成，在这里分享一下具体过程。</p>

<h2>Bootstrap 主题的安装</h2>

<p>首先下载适用于 Octopress 的 <a href="https://github.com/bkutil/bootstrap-theme">Bootstrap主题</a> 并解压缩到博客的 .theme 目录，然后安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install['bootstrap']</span></code></pre></td></tr></table></div></figure>


<p>安装的过程中可能会提示有 sass 或其他依赖库的语法错误神马的，这是因为 sass 的版本过低，可以通过如下命令来跟新：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bundle update sass</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>其他库的升级类推。升级完这些依赖后，要修改你的 Octopress 博客的根目录下的 Gemfile 中的版本说明。最后再重新运行上上条的 rake install 指令。这样就完成主体的安装了，是不是很简单（实际操作中遇到问题的话，一般都是 jekyll 等各种的库的版本及相互间的依赖问题，通过 bundle update 基本上都能搞定）。安装完了之后，可以运行 rake generate 和 rake preview 来看看效果了。</p>

<h2>配置 Tags 归档</h2>

<p>接下来是配置类似 <a href="http://ibillxia.github.io/blog/tags/">这种显示结果</a> 的 Tags 归档页面了。</p>

<p>首先，需要安装 <a href="https://github.com/plusjade/jekyll-bootstrap">jekyll-bootstrap</a> 的一些东西，请先下载并解压。主要是 <em>includes/JB/ 目录下的内容，将 JB 文件夹拷贝到 $BLOG_HOME/source/</em>includes/ 目录下，还有 jekyll-bootstrap 根目录下的 tags.html 拷贝到你想展示 Tags 的目录，并在 _config.yml 文件中配置 tag_dir 项的值为该目录，例如我这里的配置是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tag_dir: blog/tags</span></code></pre></td></tr></table></div></figure>


<p>所以我的 tags.html 文件放在了 $BLOG_HOME/source/blog/tags 目录下，并将 tags.html 重命名为 index.html。</p>

<p>这些配置好了后，你就可以先运行 rake generate 和 rake preview 来看看效果。可以发现 Tags 归档页的显示还是不太友好。那么我们需要加入一些自己的 css 样式。这里我参考了 pluskid 师兄的博客的 css 代码并略有修改，在我新建的 $BLOG_HOME/source/stylesheets/style.css 文件中加入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* tag_box */
</span><span class='line'>.tag_box {
</span><span class='line'>  list-style:none;
</span><span class='line'>  margin:0;
</span><span class='line'>  padding:2px 0 ;
</span><span class='line'>  overflow:hidden;
</span><span class='line'>}
</span><span class='line'>.tag_box li {
</span><span class='line'>  line-height:20px;
</span><span class='line'>  margin:0;
</span><span class='line'>}
</span><span class='line'>.tag_box.inline li {
</span><span class='line'>  float:left;
</span><span class='line'>  padding:2px 0 ;
</span><span class='line'>}
</span><span class='line'>.tag_box a {
</span><span class='line'>  padding: 2px;
</span><span class='line'>  margin: 2px;
</span><span class='line'>  background: #eee;
</span><span class='line'>  color:#005F6B;
</span><span class='line'>  border-radius: 3px;
</span><span class='line'>  text-decoration:none;
</span><span class='line'>}
</span><span class='line'>.tag_box a span{
</span><span class='line'>  vertical-align:super;
</span><span class='line'>  font-size:0.8em;
</span><span class='line'>}
</span><span class='line'>.tag_box a.active {
</span><span class='line'>  background:#57A957;
</span><span class='line'>  border:1px solid #4C964D;
</span><span class='line'>  color:#FFF;
</span><span class='line'>}
</span><span class='line'>/* tag_box end */</span></code></pre></td></tr></table></div></figure>


<p>注意，这里由于新加了 css 文件，要让其生效，需要在 html 模板中加入引用，具体我是在 $BLOG_HOME/source/_includes/head.html 文件中加入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;link href="http://ibillxia.github.io/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;</span></code></pre></td></tr></table></div></figure>


<p>你也可以直接在 html 模板中加入 css 代码而不用新建 css 文件并添加引用。</p>

<p>至此，已经配置完成了 ^_^ 可以运行 rake generate 和 rake preview 来看看最终效果了。</p>

<p>PS：本博客的主题及插件相关文件和代码可以看我的 GitHub Repo：<a href="https://github.com/ibillxia/xoctopress/tree/master">xoctopress</a>. 如有问题，可以参考这些代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全排列及某排列的后继的求解及其STL实现的分析]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation/"/>
    <updated>2014-04-24T23:24:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation</id>
    <content type="html"><![CDATA[<p>在Leetcode上有好几道全排列相关的题，一直以来只是会写基于递归的全排列生成算法，遇到这几道题后，搜了下一些非递归的实现方法，发现其实全排列的生成还是很有规律的有木有！这里就总结一下递归和非递归的全排列生成方法，并分析一下 STL 的实现。</p>

<p>递归和非递归实现全排列生成的方法也分别有多种，递归法有基于交换的，有基于链接的，还有回溯，非递归法有排序、回溯、求模等，关于所有这些方法的具体实现参见 <a href="http://mengliao.blog.51cto.com/876134/824079">全排列的六种算法</a>. 本文只实现一种递归和一种非递归算法，并在最后对 STL 的非递归算法进行分析。</p>

<p>本文的全部代码下载：<a href="http://ibillxia.github.io/upload/code/20140424.cpp">code</a>.</p>

<h2>递归法求全排列</h2>

<p>递归法的基本思路是这样的：</p>

<blockquote><p>首先选一个元素排在第一个（有 n 中选法）；
然后递归的对剩下的所有元素进行全排列；
直到一个元素的全排列是其本身。</p></blockquote>

<p>假设给定的元素序列为 &lt;e1, e2, &#8230;, en>，其全排列表示为 P(e1, e2, &#8230;, en)，则对递归的第一步展开有：</p>

<blockquote><p>P(e1, e2, &#8230;, en) = {
&lt;e1, P(e2, e3, &#8230;, en)>,
&lt;e2, P(e1, e3, &#8230;, en)>,
&#8230; &#8230;
&lt;en, P(e1, e2, &#8230;, e(n-1))> }</p></blockquote>

<!-- more -->


<p> 一个简单的实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void recursive_permute(int A[],int i,int n){
</span><span class='line'>  if(i==n-1){
</span><span class='line'>      for(int j=0;j&lt;n;j++)
</span><span class='line'>          cout&lt;&lt;A[j]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'>  for(int j=i;j&lt;n;j++){
</span><span class='line'>      swap(A[i],A[j]);  // choose A[j] as the ith element
</span><span class='line'>      recursive_permute(A,i+1,n);
</span><span class='line'>      swap(A[i],A[j]);  // reset to enter next for
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个实现非常精简易懂，但却存在一个问题，那就是当数组 A 中存在重复元素时，得到的排列是有重复的，这是因为在第8行的循环中，可能会选取重复的 A[j] 值。 为了去掉重复排列，我们可以在选取第 i 个数 A[j] 之前（即交换 A[i] 和 A[j] 之前），判断值为 A[j] 的元素是否选取过，即要判断在 A[i] 到 A[j-1] 中是否存在与 A[j] 相等的元素，如果出现过，说明 A[i] 选 A[j] 这个排列已经生成过了，可以直接跳过当前的 A[j] 看看是否可以选取 A[j+1] 作为 A[i] 了。比如上面的 e1 = e2，那么无重复的全排列应该是：</p>

<blockquote><p>P(e1, e2, &#8230;, en) = {
&lt;e1, P(e2, e3, &#8230;, en)>,
&lt;e3, P(e1, e2, e4, &#8230;, en)>,
&#8230; &#8230;
&lt;en, P(e1, e2, &#8230;, e(n-1))> }</p></blockquote>

<p>添加这个限制的递归实现代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void recursive_permute2(int A[],int i,int n){
</span><span class='line'>  if(i==n-1){
</span><span class='line'>      for(int j=0;j&lt;n;j++)
</span><span class='line'>          cout&lt;&lt;A[j]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'>  for(int j=i;j&lt;n;j++){
</span><span class='line'>      int k;
</span><span class='line'>      for(k=i;k&lt;j;k++)if(A[k]==A[j])break; // A[j] already used
</span><span class='line'>      if(k&lt;j)continue;
</span><span class='line'>      swap(A[i],A[j]);  // choose A[j] as the ith element
</span><span class='line'>      recursive_permute2(A,i+1,n);
</span><span class='line'>      swap(A[i],A[j]);  // reset to enter next for
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>至此，递归法实现全排列的求解就总结到这儿了，下面来看看非递归怎么实现。</p>

<h2>非递归法求全排列</h2>

<p>非递归法求全排列的一种最常用算法是基于字典序的全排列生成算法，其基本思路为，先解决生成一个序列在字典序下的下一个排列这个问题，然后利用这个来一次求解每一个排列。其中求解给定序列在字典序下的下一个排列序列的基本思想如下：</p>

<blockquote><ol>
<li>对于给定序列 &lt;e1, e2, &#8230;, en> 从右往左找到第一个非递增点，设下标为 i；</li>
<li>从右往左查找第一个比 e[i] 大的数，设其下标为 j;</li>
<li>交换 e[i] 和 e[j] 的值；</li>
<li>将序列 e[i+1..n] 逆置。</li>
</ol>
</blockquote>

<p>举个例子，如下图（修改自 <a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html">Next Permutation 解题报告</a> ）所示：</p>

<center><img src="http://ibillxia.github.io/images/2014/IMAG2014042401.png"></center>


<p>上面的说明已经很接近伪代码了，具体实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bool next_permute(int A[],int n){
</span><span class='line'>  int i,j;
</span><span class='line'>  // step .1
</span><span class='line'>  if(n&lt;2)return false;
</span><span class='line'>  for(i=n-2;i&gt;=0;i--){
</span><span class='line'>      if(A[i]&lt;A[i+1])break;
</span><span class='line'>  }
</span><span class='line'>  if(i&lt;0)return false; // A[0] is maximum, no next permute for it
</span><span class='line'>  // step .2
</span><span class='line'>  for(j=n-1;j&gt;i;j--){
</span><span class='line'>      if(A[j]&gt;A[i])break;
</span><span class='line'>  }
</span><span class='line'>  // step .3
</span><span class='line'>  swap(A[i],A[j]);
</span><span class='line'>  // step .4
</span><span class='line'>  while(++i &lt; --n){
</span><span class='line'>      swap(A[i],A[n]);
</span><span class='line'>  }
</span><span class='line'>  return true;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里将其返回值定义为 bool 类型，可以方便后面求解全排列时调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void non_recursive_permute(int A[],int n){
</span><span class='line'>  sort(A,A+n);
</span><span class='line'>  int i;
</span><span class='line'>  do{
</span><span class='line'>      for(i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>  }while(next_permute(A,n));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面这个函数即实现了按字典序生成全排列的功能，而且对于输入含有重复值的情况，不会生成重复的排列。对于非递归实现，很容易分析其时间复杂度，next_permute 的时间复杂度为 O(n)，而 non_recursive_permute 的时间复杂度为 O(n*n!)。</p>

<h2>STL 中 next permute 的实现</h2>

<p>下面来分析一下 STL 中是如何实现 next permute 的，在 stl_algo.h 中我们可以找到 next_permutation 的实现，基本思路也是按照上面的四步走来实现的，具体见如下代码及注释：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  @brief  Permute range into the next @a dictionary ordering.
</span><span class='line'> *  @ingroup sorting_algorithms
</span><span class='line'> *  @param  first  Start of range.
</span><span class='line'> *  @param  last   End of range.
</span><span class='line'> *  @return  False if wrapped to first permutation, true otherwise.
</span><span class='line'> *
</span><span class='line'> *  Treats all permutations of the range as a set of @a dictionary sorted
</span><span class='line'> *  sequences.  Permutes the current sequence into the next one of this set.
</span><span class='line'> *  Returns true if there are more sequences to generate.  If the sequence
</span><span class='line'> *  is the largest of the set, the smallest is generated and false returned.
</span><span class='line'>*/
</span><span class='line'>template&lt;typename _BidirectionalIterator&gt;
</span><span class='line'>bool
</span><span class='line'>next_permutation(_BidirectionalIterator __first,
</span><span class='line'>                 _BidirectionalIterator __last)
</span><span class='line'>{
</span><span class='line'>    // concept requirements
</span><span class='line'>    __glibcxx_function_requires(_BidirectionalIteratorConcept&lt;
</span><span class='line'>                                _BidirectionalIterator&gt;)
</span><span class='line'>    __glibcxx_function_requires(_LessThanComparableConcept&lt;
</span><span class='line'>                                typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;)
</span><span class='line'>    __glibcxx_requires_valid_range(__first, __last);
</span><span class='line'>
</span><span class='line'>    if (__first == __last)  // 容器中没有元素，没有 next permute
</span><span class='line'>        return false;
</span><span class='line'>    _BidirectionalIterator __i = __first;
</span><span class='line'>    ++__i;
</span><span class='line'>    if (__i == __last)  // 容器中只有一个元素，同没有
</span><span class='line'>        return false;
</span><span class='line'>    __i = __last;
</span><span class='line'>    --__i;  // 将 __i 指向最后一个元素
</span><span class='line'>
</span><span class='line'>    for(;;) {
</span><span class='line'>        _BidirectionalIterator __ii = __i;  
</span><span class='line'>        --__i;
</span><span class='line'>        if (*__i &lt; *__ii) {  // step .1, 这里的 __i 就相当于上面step 1中的i
</span><span class='line'>            _BidirectionalIterator __j = __last;
</span><span class='line'>            while (!(*__i &lt; *--__j)) {  // step .2, 这里的 __j 就相当上面 step 2中的j
</span><span class='line'>            }
</span><span class='line'>            std::iter_swap(__i, __j);  // step .3 交换
</span><span class='line'>            std::reverse(__ii, __last);  // step .4 逆置
</span><span class='line'>            return true;
</span><span class='line'>        }
</span><span class='line'>        if (__i == __first) {  // 直到 __i = __first 还是没有 *__i &lt; *__ii ，说明序列是递减排列的
</span><span class='line'>            std::reverse(__first, __last); // 本应该没有下一个排列，但这里将字典序中第一个排列作为最后一个排列的 next permute
</span><span class='line'>            return false; // 这里返回 false 而不是 true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里是用双向迭代器对容器中的元素进行操作的，一个调用的实例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &num) {
</span><span class='line'>  vector&lt;vector&lt;int&gt; &gt; ans;
</span><span class='line'>  sort(num.begin(),num.end());
</span><span class='line'>  do{
</span><span class='line'>      ans.push_back(num);
</span><span class='line'>  }while(next_permutation(num.begin(),num.end()));
</span><span class='line'>  return ans;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，其实 STL 的 next permute 的实现跟我们的非递归算法是一致的。但这里有两个问题：一是，这里看似有二重循环（在 for 中套 while ），但实际上复杂度是 n+n =》 O(n) 的（可以为什么要写成这种二重循环的形式捏？不解）；二是，我们可以看到在 for 循环中，对 __ii 这个变量进行了多次声明，为什么不将其声明放在 for 外面捏？（虽然待排列的元素数 n 不会很大，但这样多次声明一个迭代器变量，虽不会占用过多内存，但在声明时调用构造函数和析构函数也是有一定的时间开销的吧，虽然相对于求全排列的复杂度 O(n*n!) 几乎可以忽略不计）</p>
]]></content>
  </entry>
  
</feed>
