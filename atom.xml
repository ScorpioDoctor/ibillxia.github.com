<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-09-18T15:16:42+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.4) 序列式容器之heap和priority queue]]></title>
    <link href="http://ibillxia.github.io/blog/2014/07/27/stl-source-insight-3-sequential-containers-4-heap-and-priority-queue/"/>
    <updated>2014-07-27T21:31:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/07/27/stl-source-insight-3-sequential-containers-4-heap-and-priority-queue</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>heap</code>、<code>stl_heap.h</code>、<code>heap.h</code>、<code>stl_queue.h</code>、<code>queue</code> 等几个文件。</p>

<h2>1. 概述</h2>

<p>前面分别介绍了三种各具特色的序列式容器 —— vector、list和deque，他们几乎可以涵盖所有类型的序列式容器了，但本文要介绍的heap则是一种比较特殊的容器。其实，在STL中heap并没有被定义为一个容器，而只是一组算法，提供给priority queue（优先队列）。故名思议，priority queue 允许用户以任何次序将元素放入容器内，但取出时一定是从优先权最高的元素开始取，binary max heap（二元大根堆）即具有这样的特性，因此如果学过max-heap再看STL中heap的算法和priority queue 的实现就会比较简单。</p>

<h2>2. priority queue 的数据结构</h2>

<p>要实现priority queue的功能，binary search tree（BST）也可以作为其底层机制，但这样的话元素的插入就需要O(logN)的平均复杂度，而且要求元素的大小比较随机，才能使树比较平衡。而binary heap是一种完全二叉树的结构，而且可以使用vector来存储：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;), 
</span><span class='line'>          class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;
</span><span class='line'>class priority_queue { // in stl_queue.h 文件中
</span><span class='line'>protected:
</span><span class='line'>  _Sequence c; // 使用vector作为数据存储的容器
</span><span class='line'>  _Compare comp;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>另外只需要提供一组heap算法，即元素插入和删除、获取堆顶元素等操作即可。</p>

<!-- more -->


<h2>3. push heap 算法</h2>

<p>为了满足完全二叉树的特性，新加入的元素一定要放在vector的最后面；又为了满足max-heap的条件（每个节点的键值不小于其叶子节点的键值），还需要执行上溯过程，将新插入的元素与其父节点进行比较，直到不大于父节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;
</span><span class='line'>void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value){
</span><span class='line'>  _Distance __parent = (__holeIndex - 1) / 2; //  新节点的父节点
</span><span class='line'>  while (__holeIndex &gt; __topIndex && *(__first + __parent) &lt; __value) { // 插入时的堆调整过程：当尚未到达顶端且父节点小于新值时，需要将新值往上（前）调整
</span><span class='line'>    *(__first + __holeIndex) = *(__first + __parent); // 父节点下移
</span><span class='line'>    __holeIndex = __parent;
</span><span class='line'>    __parent = (__holeIndex - 1) / 2;
</span><span class='line'>  }    
</span><span class='line'>  *(__first + __holeIndex) = __value; // 找到新值应当存储的位置
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;
</span><span class='line'>inline void __push_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance*, _Tp*) {
</span><span class='line'>  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), _Tp(*(__last - 1))); 
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator&gt;
</span><span class='line'>inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { // 真正的对外接口，在调用之前，元素已经放在了vector的最后面了（见priority queue的push_back）
</span><span class='line'>  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
</span><span class='line'>  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable);
</span><span class='line'>  __push_heap_aux(__first, __last, __DISTANCE_TYPE(__first), __VALUE_TYPE(__first)); // 直接调用 __push_heap_aux
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. pop heap 算法</h2>

<p>对heap进行pop操作就是取顶部的元素，取走后要对heap进行调整，是之满足max-heap的特性。调整的策略是，首先将最末尾的元素放到堆顶，然后进行下溯操作，将对顶元素下移到适当的位置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _RandomAccessIterator, class _Distance, class _Tp&gt;
</span><span class='line'>void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value) { // 调整堆
</span><span class='line'>  _Distance __topIndex = __holeIndex; // 堆顶
</span><span class='line'>  _Distance __secondChild = 2 * __holeIndex + 2;
</span><span class='line'>  while (__secondChild &lt; __len) {
</span><span class='line'>    if (*(__first + __secondChild) &lt; *(__first + (__secondChild - 1))) __secondChild--; // secondChild 为左右两个子节点中较大者
</span><span class='line'>    *(__first + __holeIndex) = *(__first + __secondChild); // 节点的值上移
</span><span class='line'>    __holeIndex = __secondChild;
</span><span class='line'>    __secondChild = 2 * (__secondChild + 1); // 下移一层
</span><span class='line'>  }
</span><span class='line'>  if (__secondChild == __len) { // 最后一个元素
</span><span class='line'>    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
</span><span class='line'>    __holeIndex = __secondChild - 1;
</span><span class='line'>  }
</span><span class='line'>  __push_heap(__first, __holeIndex, __topIndex, __value);
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Tp, class _Distance&gt;
</span><span class='line'>inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Tp __value, _Distance*) {
</span><span class='line'>  *__result = *__first; // 获取堆顶元素，并赋给堆尾的last-1
</span><span class='line'>  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value); // 调整堆
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Tp&gt;
</span><span class='line'>inline void __pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*) {
</span><span class='line'>  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __DISTANCE_TYPE(__first)); // 对 [first,last-1)进行pop，并将first赋给last-1
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator&gt;
</span><span class='line'>inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) { // 对外提供的接口，最后堆顶元素在堆的末尾，而[first,last-1) 区间为新堆，该接口调用完后再进行pop操作移除最后的元素
</span><span class='line'>  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
</span><span class='line'>  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type, _LessThanComparable);
</span><span class='line'>  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>5. make heap 算法</h2>

<p>最后，我们来看看如何从一个初始序列来创建一个heap，有了前面的 <code>adjust_heap</code> ，创建heap也就很简单了，只需要从最后一个非叶子节点开始，不断调用堆调整函数，即可使得整个序列称为一个heap：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _RandomAccessIterator, class _Compare, class _Tp, class _Distance&gt;
</span><span class='line'>void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, _Tp*, _Distance*) {
</span><span class='line'>  if (__last - __first &lt; 2) return;
</span><span class='line'>  _Distance __len = __last - __first;
</span><span class='line'>  _Distance __parent = (__len - 2)/2; // 定位到最后一个非叶子节点
</span><span class='line'>  while (true) { // 对每个非叶子节点为根的子树进行堆调整
</span><span class='line'>    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)), __comp);
</span><span class='line'>    if (__parent == 0) return;
</span><span class='line'>    __parent--;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>template &lt;class _RandomAccessIterator, class _Compare&gt;
</span><span class='line'>inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) { // 对外提供的接口
</span><span class='line'>  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
</span><span class='line'>  __make_heap(__first, __last, __comp, __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>6. 基于 heap 的 priority queue</h2>

<p>上一篇文章中讲到stack和queue都是基于deque实现的，这里的priority queue是基于vector和heap来实现的，默认使用vector作为容器，而使用heap的算法来维持其priority的特性，因此priority queue也被归类为container adapter。其具体实现的主要代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector&lt;_Tp&gt;), class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less&lt;typename _Sequence::value_type&gt;) &gt;
</span><span class='line'>class priority_queue {
</span><span class='line'>protected:
</span><span class='line'>  _Sequence c;
</span><span class='line'>  _Compare comp;
</span><span class='line'>public:
</span><span class='line'>  priority_queue() : c() {}
</span><span class='line'>  explicit priority_queue(const _Compare& __x) :  c(), comp(__x) {}
</span><span class='line'>  priority_queue(const _Compare& __x, const _Sequence& __s) : c(__s), comp(__x) 
</span><span class='line'>    { make_heap(c.begin(), c.end(), comp); }
</span><span class='line'>  bool empty() const { return c.empty(); }
</span><span class='line'>  size_type size() const { return c.size(); }
</span><span class='line'>  const_reference top() const { return c.front(); }
</span><span class='line'>  void push(const value_type& __x) {
</span><span class='line'>    __STL_TRY {
</span><span class='line'>      c.push_back(__x); // 在push_heap之前先将x放在vector c的最后面
</span><span class='line'>      push_heap(c.begin(), c.end(), comp);
</span><span class='line'>    }
</span><span class='line'>    __STL_UNWIND(c.clear());
</span><span class='line'>  }
</span><span class='line'>  void pop() {
</span><span class='line'>    __STL_TRY {
</span><span class='line'>      pop_heap(c.begin(), c.end(), comp);
</span><span class='line'>      c.pop_back(); // 在调用pop_heap之后才将最后一个元素剔除出vector c
</span><span class='line'>    }
</span><span class='line'>    __STL_UNWIND(c.clear());
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，priority queue也没有迭代器，不能对其进行遍历等操作，因为它只能在顶部取和删除元素，而插入元素的位置也是确定的，而不能有用户指定。<br/>
关于heap和priority queue的内容就介绍到这里了，而序列式容器的介绍也到此结束了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.3) 序列式容器之deque和stack、queue]]></title>
    <link href="http://ibillxia.github.io/blog/2014/07/13/stl-source-insight-3-sequential-containers-3-deque-and-stack-queue/"/>
    <updated>2014-07-13T20:46:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/07/13/stl-source-insight-3-sequential-containers-3-deque-and-stack-queue</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>deque</code>、<code>stl_deque.h</code>、<code>deque.h</code>、<code>stack</code>、<code>stl_stack.h</code>、<code>queue</code>、<code>stl_queue.h</code> 等几个文件。</p>

<h2>1. deque 概述</h2>

<p>前面分别介绍了连续式存储的序列容器vector和以节点为单位链接起来的非连续存储的序列容器list，这两者各有优缺点，而且刚好是优缺互补的，那么何不将二者结合利用对方的优点来弥补己方的不足呢，于是这就有了强大的deque。</p>

<p>没错，与我们在数据结构中学到的固定连续空间的双端队列不同，STL中的deque是分段连续的空间通过list链接而成的序列容器，它结合了vector与list的存储特性，但与vector和list都不同的是deque只能在首部或尾部进行插入和删除操作，这个限制在一定程度上简化了deque实现的难度。由于使用分段连续空间链接的方式，所以deque不存在vector那样“因旧空间不足而重新配置新的更大的空间，然后复制元素，再释放原空间”的情形，也不会有list那样每次都只配置一个元素的空间而导致时间性能和空间的利用率低下。</p>

<h2>2. deque 的数据结构</h2>

<p>deque由一段一段连续空间串接而成，一旦有必要在deque的头部或尾端增加新的空间，便配置一段定量连续的空间，串接在deque的头部或尾端。deque的最大任务，就是在这些分段连续的空间上维护其整体连续的假象，并提供随机存取的接口。deque采用一块所谓的map（注意：不是STL中map容器，而是类似于vector）作为主控（为什么不使用list呢？），这块map是一个连续空间，其中每个元素都是一个指针，指向一段连续的空间，称为缓冲区，它才是deque的真正存储空间。SGI中允许指定缓冲区的大小，默认是512字节。除此之外，还有start和finish两个指针，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的最后一个元素。其数据结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inline size_t __deque_buf_size(size_t __size) { // 计算缓冲区的大小
</span><span class='line'>  return __size &lt; 512 ? size_t(512 / __size) : size_t(1);
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt; class _Deque_base {
</span><span class='line'>protected:
</span><span class='line'>  _Tp** _M_map; // 指向缓冲区的指针数组首地址
</span><span class='line'>  size_t _M_map_size;  // 指向缓冲区的指针数组的大小
</span><span class='line'>  iterator _M_start; // 指向第一个缓冲区的第一个元素
</span><span class='line'>  iterator _M_finish; // 指向最后一个缓冲区的最后一个元素
</span><span class='line'>};
</span><span class='line'>class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; {
</span><span class='line'>protected:  // Internal typedefs
</span><span class='line'>  typedef pointer* _Map_pointer;
</span><span class='line'>  static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<h2>3. deque 的配置器</h2>

<p>由于deque涉及到两种类型（map和buffer）数据的空间配置，因此deque定义了两个专属的配置器 <code>_Map_alloc_type</code> 和 <code>_Node_alloc_type</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; class _Deque_base {
</span><span class='line'>protected:
</span><span class='line'>  typedef simple_alloc&lt;_Tp, _Alloc&gt;  _Node_alloc_type;
</span><span class='line'>  typedef simple_alloc&lt;_Tp*, _Alloc&gt; _Map_alloc_type;
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;
</span><span class='line'>class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; { };</span></code></pre></td></tr></table></div></figure>


<p>而这里的 <code>_Alloc</code> 使用的都是STL默认的 <code>alloc</code> 这个配置器，因此这两个配置器实际上都是 <code>alloc</code> 类型的配置器，即SGI的第二级配置器。<br/>
在定义一个deque时，默认调用基类的构造函数，产生一个map大小为0的空的deque，随着第一次插入元素，由于map大小不够，需要调用<code>_M_push_back_aux</code> 进而调用 <code>_M_reallocate_map</code> 进行map的空间配置，如果初始的map不为空，还需要对map进行“分配新空间，复制，释放元空间”的操作，如果从头部插入同样的道理，这是就是map的配置逻辑（实际中，还有一种情况，就是map的前后剩余的node数不同，例如前部分都空着，而后面插入后溢出了，这时可以考虑在map内部移动，即将后半部分整体往前移动一定距离）。其中<code>_M_reallocate_map</code>的实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>void deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add, bool __add_at_front){
</span><span class='line'>  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;
</span><span class='line'>  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
</span><span class='line'>  _Map_pointer __new_nstart;
</span><span class='line'>  if (_M_map_size &gt; 2 * __new_num_nodes) { // map的size足够，在map内部移动
</span><span class='line'>    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
</span><span class='line'>    if (__new_nstart &lt; _M_start._M_node)
</span><span class='line'>      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
</span><span class='line'>    else
</span><span class='line'>      copy_backward(_M_start._M_node, _M_finish._M_node + 1, __new_nstart + __old_num_nodes);
</span><span class='line'>  } else { // map的size不够，重新分配
</span><span class='line'>    size_type __new_map_size = _M_map_size + max(_M_map_size, __nodes_to_add) + 2;
</span><span class='line'>    _Map_pointer __new_map = _M_allocate_map(__new_map_size); // 重新分配map
</span><span class='line'>    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
</span><span class='line'>    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart); // 复制原map到新的map中
</span><span class='line'>    _M_deallocate_map(_M_map, _M_map_size); // 释放原map
</span><span class='line'>    _M_map = __new_map;
</span><span class='line'>    _M_map_size = __new_map_size;
</span><span class='line'>  }
</span><span class='line'>  _M_start._M_set_node(__new_nstart);
</span><span class='line'>  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>那么每个连续的缓冲区buffer（或node）是在什么时候配置呢？它是在map中实际使用到的最后一个node不够用时但map还可以继续在这个node后面加入node时（即map非满而node满时），在 <code>_M_push_back_aux</code> 中调用 <code>_M_allocate_node</code> 来分配，相关函数都比较简单，这里就不贴了。<br/>
以上主要是空间分配相关的，那么在 <code>pop</code> 的时候，空间的释放又是怎样的呢？这里也需要判断是否当前node全部被 <code>pop</code> 了，如果是的则需要释放这个node所占用的空间。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void pop_back() { // deque内部实现的成员函数，inline的
</span><span class='line'>    if (_M_finish._M_cur != _M_finish._M_first) { // 整个node还没有pop完
</span><span class='line'>      --_M_finish._M_cur;
</span><span class='line'>      destroy(_M_finish._M_cur); // 析构当前元素
</span><span class='line'>    } else  _M_pop_back_aux();
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>void deque&lt;_Tp,_Alloc&gt;::_M_pop_back_aux() { // 整个node被pop完了的情况
</span><span class='line'>  _M_deallocate_node(_M_finish._M_first); // 释放整个node的空间
</span><span class='line'>  _M_finish._M_set_node(_M_finish._M_node - 1); // node前移
</span><span class='line'>  _M_finish._M_cur = _M_finish._M_last - 1; // 当前元素为最后一个node的最后一个元素
</span><span class='line'>  destroy(_M_finish._M_cur); // 释放当前元素
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. deque 的迭代器</h2>

<p>deque是分段连续空间，前面也提到了deque使用的是Bidirectional Iterators，因此deque的迭代器主要需要实现<code>operator++</code>和<code>operator--</code>。要实现这两个操作，需要考虑当前指针是否处于buffer的头/尾，如果在buffer的头部而需要前移（或尾部需要后移），就需要将buffer往前/后移一个，在SGI中是通过调用 <code>_M_set_node</code> 来实现的。具体代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Ref, class _Ptr&gt; struct _Deque_iterator {
</span><span class='line'>  typedef _Tp** _Map_pointer;
</span><span class='line'>  _Tp* _M_cur; // 几个成员变量
</span><span class='line'>  _Tp* _M_first;
</span><span class='line'>  _Tp* _M_last;
</span><span class='line'>  _Map_pointer _M_node;
</span><span class='line'>  _Self& operator++() { // ++ 操作符重载，后移
</span><span class='line'>    ++_M_cur;
</span><span class='line'>    if (_M_cur == _M_last) { // 到了buffer的最后一个
</span><span class='line'>      _M_set_node(_M_node + 1); // 将当前node指针_M_node指向下一个node
</span><span class='line'>      _M_cur = _M_first; // 当前指针指向新node的第一个元素
</span><span class='line'>    }
</span><span class='line'>    return *this; 
</span><span class='line'>  }
</span><span class='line'>  void _M_set_node(_Map_pointer __new_node) {
</span><span class='line'>    _M_node = __new_node; // map pointer后移
</span><span class='line'>    _M_first = *__new_node; // first指向新node
</span><span class='line'>    _M_last = _M_first + difference_type(_S_buffer_size()); // last指向下一个node
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>使用 <code>--</code> 操作符向前移动的同理，这里就不赘述了。</p>

<h2>5. deque 的常用操作</h2>

<p>deque中最常用的莫过于 <code>push</code> 和 <code>pop</code> 操作了，这些操作在前面的空间配置中基本已经介绍了，这里就主要介绍一下 <code>clear</code>、 <code>erase</code> 和 <code>insert</code> 操作吧。<br/>
<strong>（1）clear</strong><br/>
该函数的作用是清除整个deque，释放所有空间而只保留一个缓冲区：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; void deque&lt;_Tp,_Alloc&gt;::clear() {
</span><span class='line'>  for (_Map_pointer __node = _M_start._M_node + 1; __node &lt; _M_finish._M_node; ++__node) { // 从第二个node开始，遍历每个缓冲区（node）
</span><span class='line'>    destroy(*__node, *__node + _S_buffer_size()); // 析构每个元素
</span><span class='line'>    _M_deallocate_node(*__node); // 释放缓冲区
</span><span class='line'>  }
</span><span class='line'>  if (_M_start._M_node != _M_finish._M_node) { // 还剩下头尾两个node
</span><span class='line'>    destroy(_M_start._M_cur, _M_start._M_last); // 析构头node中的每个元素
</span><span class='line'>    destroy(_M_finish._M_first, _M_finish._M_cur); // 析构尾node中的每个元素
</span><span class='line'>    _M_deallocate_node(_M_finish._M_first); // 释放尾node的空间
</span><span class='line'>  } else destroy(_M_start._M_cur, _M_finish._M_cur); // 只有一个node，析构这个node中的所有元素
</span><span class='line'>  _M_finish = _M_start;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（2）erase</strong><br/>
该函数的作用是清除 [first,last) 间的所有元素：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typename deque&lt;_Tp,_Alloc&gt;::iterator 
</span><span class='line'>deque&lt;_Tp,_Alloc&gt;::erase(iterator __first, iterator __last) {
</span><span class='line'>  if (__first == _M_start && __last == _M_finish) { // erase 所有元素，直接调用clear
</span><span class='line'>    clear();
</span><span class='line'>    return _M_finish;
</span><span class='line'>  } else { // erase 部分元素
</span><span class='line'>    difference_type __n = __last - __first; // 待擦出的区间长度
</span><span class='line'>    difference_type __elems_before = __first - _M_start; // 擦出区间前的元素个数
</span><span class='line'>    if (__elems_before &lt; difference_type((this-&gt;size() - __n) / 2)) { // 前面的元素个个数小于擦除后剩余总数的一半，将这部分后移
</span><span class='line'>      copy_backward(_M_start, __first, __last); // 后移
</span><span class='line'>      iterator __new_start = _M_start + __n; 
</span><span class='line'>      destroy(_M_start, __new_start);
</span><span class='line'>      _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
</span><span class='line'>      _M_start = __new_start;
</span><span class='line'>    } else { // 前面剩余的元素较多，将后面的前移
</span><span class='line'>      copy(__last, _M_finish, __first); // 前移
</span><span class='line'>      iterator __new_finish = _M_finish - __n;
</span><span class='line'>      destroy(__new_finish, _M_finish);
</span><span class='line'>      _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);
</span><span class='line'>      _M_finish = __new_finish;
</span><span class='line'>    }
</span><span class='line'>    return _M_start + __elems_before;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（3）insert</strong><br/>
该函数的作用是在某个位置插入一个元素：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>iterator insert(iterator position, const value_type& __x) {
</span><span class='line'>  if (position._M_cur == _M_start._M_cur) { // 在头部插入，用push_front
</span><span class='line'>    push_front(__x);
</span><span class='line'>    return _M_start;
</span><span class='line'>  } else if (position._M_cur == _M_finish._M_cur) { // 在尾部插入
</span><span class='line'>    push_back(__x);
</span><span class='line'>    iterator __tmp = _M_finish;
</span><span class='line'>    --__tmp;
</span><span class='line'>    return __tmp; // 返回插入位置
</span><span class='line'>  } else { // 在中间插入
</span><span class='line'>    return _M_insert_aux(position, __x);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>deque&lt;_Tp,_Alloc&gt;::_M_insert_aux(iterator __pos, const value_type& __x) {
</span><span class='line'>  difference_type __index = __pos - _M_start; // 插入点之前的元素个数
</span><span class='line'>  value_type __x_copy = __x;
</span><span class='line'>  if (size_type(__index) &lt; this-&gt;size() / 2) { // 前面的元素个数较小
</span><span class='line'>    push_front(front()); // 在头部插入与头部相同的元素，然后从第二个元素开始到插入位置整体前移一步
</span><span class='line'>    iterator __front1 = _M_start; ++__front1;
</span><span class='line'>    iterator __front2 = __front1; ++__front2;
</span><span class='line'>    __pos = _M_start + __index;
</span><span class='line'>    iterator __pos1 = __pos; ++__pos1;
</span><span class='line'>    copy(__front2, __pos1, __front1);
</span><span class='line'>  } else { // 插入点后面的元素较少，从后面插入，然后插入点到尾部整体往后移一步
</span><span class='line'>    push_back(back());
</span><span class='line'>    iterator __back1 = _M_finish; --__back1;
</span><span class='line'>    iterator __back2 = __back1;  --__back2;
</span><span class='line'>    __pos = _M_start + __index;
</span><span class='line'>    copy_backward(__pos, __back2, __back1);
</span><span class='line'>  }
</span><span class='line'>  *__pos = __x_copy;
</span><span class='line'>  return __pos;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>deque原本只能在头部或尾部插入元素的，提供了insert之后，就可以任何位置插入元素了。</p>

<h2>6. 基于deque 的 stack 和 queue</h2>

<p>由于deque可以从首位两端插入或剔除元素，所以只需要对其进行简单的封装就可以分别实现先进先出（FIFO）的stack和先进后出（FILO）的queue了。stack和queue中都有一个deque类型的成员，用做数据存储的容器，然后对deque的部分接口进行简单的封装，例如stack只提供从末端插入和删除的接口以及获取末端元素的接口，而queue则只提供从尾部插入而从头部删除的接口以及获取首位元素的接口。像这样具有“修改某物接口，形成另一种风貌”的性质的，称为配接器（adapter），因此STL中stack和queue往往不被归类为容器（container），而被归类为容器配接器（container adapter）。（关于配接器后面文章还会具体介绍）<br/>
下面只给出stack的基本实现，并加以注解。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque&lt;_Tp&gt;) &gt;
</span><span class='line'>class stack; // 原型声明
</span><span class='line'>template &lt;class _Tp, class _Sequence&gt; class stack {
</span><span class='line'>protected:
</span><span class='line'>  _Sequence c; // _Sequence为deque&lt;_Tp&gt;，c为实际存储数据的容器
</span><span class='line'>public: // 向外部提供的接口，都是调用deque的接口来实现的
</span><span class='line'>  stack() : c() {}
</span><span class='line'>  explicit stack(const _Sequence& __s) : c(__s) {}
</span><span class='line'>  bool empty() const { return c.empty(); }
</span><span class='line'>  size_type size() const { return c.size(); }
</span><span class='line'>  reference top() { return c.back(); }
</span><span class='line'>  const_reference top() const { return c.back(); }
</span><span class='line'>  void push(const value_type& __x) { c.push_back(__x); }
</span><span class='line'>  void pop() { c.pop_back(); }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，stack和queue都没有迭代器，因此不能对stack或queue进行遍历。但他们提供了 <code>operator ==</code> 和 <code>operator&lt;</code> 这两个比较大小的操作符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Seq&gt;
</span><span class='line'>bool operator==(const stack&lt;_Tp,_Seq&gt;& __x, const stack&lt;_Tp,_Seq&gt;& __y) {
</span><span class='line'>  return __x.c == __y.c;
</span><span class='line'>}
</span><span class='line'>template &lt;class _Tp, class _Seq&gt;
</span><span class='line'>bool operator&lt;(const stack&lt;_Tp,_Seq&gt;& __x, const stack&lt;_Tp,_Seq&gt;& __y) {
</span><span class='line'>  return __x.c &lt; __y.c;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外，除了使用默认的deque作为stack和queue的容器之外，我们还可以使用list或其他自定义的容器，只需要实现了stack或queue需要的接口，使用方法很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stack&lt;int,vector&lt;int&gt; &gt; ist;
</span><span class='line'>queue&lt;char,list&lt;char&gt; &gt; cq;</span></code></pre></td></tr></table></div></figure>


<p>即只需要指定模板中第二个参数即可。<br/>
关于deque的内容就介绍到这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.2) 序列式容器之list]]></title>
    <link href="http://ibillxia.github.io/blog/2014/07/06/stl-source-insight-3-sequential-containers-2-list/"/>
    <updated>2014-07-06T22:03:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/07/06/stl-source-insight-3-sequential-containers-2-list</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>list</code>、<code>stl_list.h</code>、<code>list.h</code> 等几个文件。</p>

<h2>1. list 和 slist</h2>

<p>STL中也实现了链表这种数据结构，list是STL标准的双向链表，而slit是SGI的单链表。相比于vector的连续线性空间而言，list即有有点也有缺点：优点是空间分配更灵活，对任何位置的插入删除操作都是常数时间；缺点是排序不方便。list和vector是比较常用的线性容器，那么什么时候用哪一种容器呢，需要视元素的多少、元素构造的复杂度（是否为POD数据）以及元素存取行为的特性而定。限于篇幅，本文主要介绍list的内容，关于单链表slist可以参见源码和侯捷的书。</p>

<h2>2. list 的数据结构</h2>

<p>在数据结构中，我们知道链表的节点node和链表list本身是不同的数据结构，以下分别是node和list的数据结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct _List_node_base {
</span><span class='line'>  _List_node_base* _M_next;
</span><span class='line'>  _List_node_base* _M_prev;
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp&gt;
</span><span class='line'>struct _List_node : public _List_node_base {  // node 的定义
</span><span class='line'>  _Tp _M_data;
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>class _List_base {
</span><span class='line'>protected:
</span><span class='line'>  _List_node&lt;_Tp&gt;* _M_node; // 只要一个指针就可以表示整个双向链表
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;
</span><span class='line'>class list : protected _List_base&lt;_Tp, _Alloc&gt; {
</span><span class='line'>public:
</span><span class='line'>  typedef _List_node&lt;_Tp&gt; _Node;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>在list中的 <code>_M_node</code> 其实指向一个空白节点，该空白节点的 <code>_M_data</code> 成员是没有被初始化的，实际上该节点是链表的尾部，后面将list的迭代器还会提到这样做的好处。</p>

<h2>3. list 的配置器</h2>

<p>list缺省使用 alloc （即 <code>__STL_DEFAULT_ALLOCATOR</code>） 作为空间配置器，并据此定义了另外一个 <code>list_node_allocator</code> ，并定义了<code>_M_get_node</code>和<code>_M_put_node</code>  两个函数，分别用于分配和释放空间，为的是更方便的以节点大小为配置单位。除此之外，还定义了两个<code>_M_create_node</code> 函数，在分配空间的同时调用元素的构建函数对其进行初始化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; 
</span><span class='line'>class _List_base {
</span><span class='line'>protected:
</span><span class='line'>  typedef simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type; // 专属配置器，每次配置一个节点
</span><span class='line'>  _List_node&lt;_Tp&gt;* _M_get_node() { return _Alloc_type::allocate(1); } // 分配一个节点
</span><span class='line'>  void _M_put_node(_List_node&lt;_Tp&gt;* __p) { _Alloc_type::deallocate(__p, 1); }  // 释放一个节点
</span><span class='line'>};
</span><span class='line'>template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt; // 缺省使用 __STL_DEFAULT_ALLOCATOR 配置器
</span><span class='line'>class list : protected _List_base&lt;_Tp, _Alloc&gt; { 
</span><span class='line'>protected:
</span><span class='line'>  _Node* _M_create_node(const _Tp& __x){ // 分配空间并初始化
</span><span class='line'>    _Node* __p = _M_get_node();
</span><span class='line'>    __STL_TRY {  _Construct(&__p-&gt;_M_data, __x);  }
</span><span class='line'>    __STL_UNWIND(_M_put_node(__p));
</span><span class='line'>    return __p;
</span><span class='line'>  }
</span><span class='line'>  _Node* _M_create_node(){
</span><span class='line'>    _Node* __p = _M_get_node();
</span><span class='line'>    __STL_TRY {  _Construct(&__p-&gt;_M_data);  }
</span><span class='line'>    __STL_UNWIND(_M_put_node(__p));
</span><span class='line'>    return __p;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在list的构造和析构函数、插入、删除等操作中设计到空间的配置。由于list不涉及同时分配多个连续元素的空间，因此用不到SGI的第二层配置器。</p>

<h2>4. list 的迭代器</h2>

<p>由于list的节点在内存中不一定连续存储，其迭代器不能像vector那样使用普通指针了，由于list是双向的链表，迭代器必须具备前移、后移的能力，所以它的迭代器是BidirectionalIterators，即双向的可增可减的，以下是list的迭代器的设计：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct _List_iterator_base {
</span><span class='line'>  typedef bidirectional_iterator_tag iterator_category;
</span><span class='line'>  _List_node_base* _M_node;
</span><span class='line'>  _List_iterator_base(_List_node_base* __x) : _M_node(__x) {}
</span><span class='line'>  _List_iterator_base() {}
</span><span class='line'>  void _M_incr() { _M_node = _M_node-&gt;_M_next; }
</span><span class='line'>  void _M_decr() { _M_node = _M_node-&gt;_M_prev; }
</span><span class='line'>};
</span><span class='line'>template&lt;class _Tp, class _Ref, class _Ptr&gt;
</span><span class='line'>struct _List_iterator : public _List_iterator_base {
</span><span class='line'>  _Self& operator++() { this-&gt;_M_incr(); return *this; }
</span><span class='line'>  _Self operator++(int) { _Self __tmp = *this; this-&gt;_M_incr(); return __tmp; }
</span><span class='line'>  _Self& operator--() { this-&gt;_M_decr(); return *this; }
</span><span class='line'>  _Self operator--(int) { _Self __tmp = *this; this-&gt;_M_decr(); return __tmp; }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>list有一个重要性质，插入操作（insert）和接合操作（splice）都不会造成原有list迭代器失效，而list的删除操作（erase）也只对“指向被删除元素”的那个迭代器失效，其他迭代器不受任何影响。</p>

<h2>5. list 的常用操作</h2>

<p>list的常用操作有很多，例如最基本的<code>push_front</code>、<code>push_back</code>、<code>pop_front</code>、<code>pop_back</code> 等，这里主要介绍一下<code>clear</code>、<code>remove</code>、<code>unique</code>、<code>transfer</code> 这几个。<br/>
<strong>（1）clear</strong><br/>
clear 函数的作用是清楚整个list的所有节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void clear() { _Base::clear(); }
</span><span class='line'>void _List_base&lt;_Tp,_Alloc&gt;::clear() {
</span><span class='line'>  _List_node&lt;_Tp&gt;* __cur = (_List_node&lt;_Tp&gt;*) _M_node-&gt;_M_next;
</span><span class='line'>  while (__cur != _M_node) {
</span><span class='line'>    _List_node&lt;_Tp&gt;* __tmp = __cur;
</span><span class='line'>    __cur = (_List_node&lt;_Tp&gt;*) __cur-&gt;_M_next; // 后移
</span><span class='line'>    _Destroy(&__tmp-&gt;_M_data); // 析构当前节点的对象
</span><span class='line'>    _M_put_node(__tmp); // 释放当前节点的空间
</span><span class='line'>  }
</span><span class='line'>  _M_node-&gt;_M_next = _M_node; // 置为空list
</span><span class='line'>  _M_node-&gt;_M_prev = _M_node;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（2）remove</strong><br/>
remove 函数的作用是将数值为value的所有元素移除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void list&lt;_Tp, _Alloc&gt;::remove(const _Tp& __value) {
</span><span class='line'>  iterator __first = begin();
</span><span class='line'>  iterator __last = end();
</span><span class='line'>  while (__first != __last) { // 遍历list
</span><span class='line'>    iterator __next = __first;
</span><span class='line'>    ++__next;
</span><span class='line'>    if (*__first == __value) erase(__first); // 值与 value 相等就移除
</span><span class='line'>    __first = __next;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（3）unique</strong><br/>
unique函数的作用是移除相同的<strong>连续</strong>元素，只有“连续而且相同”的元素，才回被移除到只剩一个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void list&lt;_Tp, _Alloc&gt;::unique() {
</span><span class='line'>  iterator __first = begin();
</span><span class='line'>  iterator __last = end();
</span><span class='line'>  if (__first == __last) return;
</span><span class='line'>  iterator __next = __first;
</span><span class='line'>  while (++__next != __last) {
</span><span class='line'>    if (*__first == *__next) // 连续连个节点的值相同
</span><span class='line'>      erase(__next);
</span><span class='line'>    else
</span><span class='line'>      __first = __next;
</span><span class='line'>    __next = __first;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>（4）transfer</strong><br/>
transfer的作用是将 [first, last) 内的所有元素移动到 position 之前。它是一个私有函数，它为其他常用操作如 splice、sort、merge 等的实现提供了便利。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protected:
</span><span class='line'>  void transfer(iterator __position, iterator __first, iterator __last) {
</span><span class='line'>    if (__position != __last) {
</span><span class='line'>      // Remove [first, last) from its old position.
</span><span class='line'>      __last._M_node-&gt;_M_prev-&gt;_M_next     = __position._M_node;
</span><span class='line'>      __first._M_node-&gt;_M_prev-&gt;_M_next    = __last._M_node;
</span><span class='line'>      __position._M_node-&gt;_M_prev-&gt;_M_next = __first._M_node; 
</span><span class='line'>      // Splice [first, last) into its new position.
</span><span class='line'>      _List_node_base* __tmp      = __position._M_node-&gt;_M_prev;
</span><span class='line'>      __position._M_node-&gt;_M_prev = __last._M_node-&gt;_M_prev;
</span><span class='line'>      __last._M_node-&gt;_M_prev     = __first._M_node-&gt;_M_prev; 
</span><span class='line'>      __first._M_node-&gt;_M_prev    = __tmp;
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>关于list的内容就介绍到这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(3.1) 序列式容器之vector]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/29/stl-source-insight-3-sequential-containers-1-vector/"/>
    <updated>2014-06-29T23:26:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/29/stl-source-insight-3-sequential-containers-1-vector</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有<code>vector</code>、<code>stl_vector.h</code>、<code>vector.h</code> 等几个文件。</p>

<h2>1. 容器</h2>

<p>在数据结构的课程中，我们主要研究数据的特定排列方式，以利于搜索、排序等算法，几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL 容器即由一个个特定的数据结构组成，例如向量（vector），链表（list），堆栈（stack），队列（queue），树（tree），哈希表（hash table），集合（set），映射（map）等，根据数据在容器中的排列特性，这些数据接口分为序列式容器（sequence container）和关联式容器（association container）两种，本文主要解读SGI STL中的序列式容器。</p>

<p>所谓序列式容器，其中的元素可序（ordered），但未必有序（sorted）。C++ 本身提供了一个序列式容器——数组（array），STL中还提供了向量（vector），链表（list），堆栈（stack），队列（queue），优先队列（priority queue）等，其中stack和queue只是将deque（双端队列）设限而得到的，技术上可以被归为一种配接器（adaptor）。本系列文章将依次解读SGI STL各容器的关键实现细节。</p>

<h2>2. vector 及其数据结构</h2>

<p>在STL中，vector的空间在物理上就是连续的，而且是可以动态扩展的，这里的动态扩展，不需要用户去处理溢出的问题，而只需要关心上层逻辑。vector连续物理空间的动态扩展技术是该容器的关键，它主要分为三个步骤：配置新空间，数据移动，释放旧空间。这三个步骤执行的次数以及每次执行时的效率是影响最终 vector 效率的关键因素。为了减少执行的次数，就需要未雨绸缪，每次扩充空间时，成倍增长。而每次执行的效率，就主要是数据移动的效率了。下面，我们依次介绍vector的数据结构，使用的空间配置器和迭代器，以及常用操作。<br/>
<strong>vector 的数据结构</strong><br/>
vector的数据结构很简单，就是一段连续的物理空间，包含起止地址以及已用到的空间的末尾地址这三个成员：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt;
</span><span class='line'>class _Vector_base {
</span><span class='line'>protected:
</span><span class='line'>  _Tp* _M_start;
</span><span class='line'>  _Tp* _M_finish;
</span><span class='line'>  _Tp* _M_end_of_storage;
</span><span class='line'>};
</span><span class='line'>class vector : protected _Vector_base&lt;_Tp, _Alloc&gt;{
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>其中 <code>_M_finish</code> 是当前使用到的空间的结束地址，而 <code>_M_end_of_storage</code> 是可用空间的结束地址，前者小于等于后者，当新加入元素使得前者大于后者之后，就需要进行空间扩充了。</p>

<h2>3. vector 的配置器</h2>

<p>vector的空间配置器 STL 默认的 <code>alloc</code> 即 <code>__default_alloc_template</code> 配置器，即第二级配置器，它对于 POD(plain old data) 类型数据使用内建内存池来应对内存碎片问题，关于该默认配置器的更多介绍请参见本系列第2篇文章 <a href="http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator/">深入理解STL源码(1) 空间配置器</a> . 除此之外，SGI vector 还定义了一个 <code>data_allocator</code>，为的是更方便的以元素大小为配置单位：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _Alloc&gt; 
</span><span class='line'>class _Vector_base  // vector 继承了该基类
</span><span class='line'>protected:
</span><span class='line'>    typedef simple_alloc&lt;_Tp, _Alloc&gt; _M_data_allocator;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于 <code>simple_alloc</code> 的内容见前面的文章，它其实就是简单的对 <code>malloc</code> 等的加一层封装。
vector的内存是在vector的构造或析构、插入元素而容量不够等情况下，需要进行配置。vector 提供了很多的构造函数，具体可见源代码，而更详细的列表并涉及各个版本的说明的列表可以参见C++的文档：<a href="http://en.cppreference.com/w/cpp/container/vector/vector">cpp references</a>.</p>

<h2>4. vector 的迭代器</h2>

<p>由于vector使用的物理连续的空间，需要支持随机访问，所以它使用的随机访问迭代器（Random Access Iterators）。也正由于vector使用连续物理空间，所以不论其元素类型为何，使用普通指针就可以作为它的迭代器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public:
</span><span class='line'>  typedef _Tp value_type;
</span><span class='line'>  typedef value_type* iterator;
</span><span class='line'>  typedef const value_type* const_iterator;</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>：vector中所谓的动态增加大小，并不是在原空间之后接连续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后再在其后构造新元素，最后释放原空间。因此，对于vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就失效了，这是vector使用中的一个大坑，务必小心。</p>

<h2>5. vector 的常用操作</h2>

<p>vector所提供的元素操作很多，这里选取几个常用操作介绍一下。<br/>
<strong>（1）push_back</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public  void push_back(const _Tp& __x) {
</span><span class='line'>if (_M_finish != _M_end_of_storage) {
</span><span class='line'>    construct(_M_finish, __x);
</span><span class='line'>    ++_M_finish;
</span><span class='line'>}
</span><span class='line'>else
</span><span class='line'>    _M_insert_aux(end(), __x); // auxiliary insert
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中辅助的insert函数的基本逻辑为：按原空间大小的两倍申请新空间，复制原数据到新空间，释放原空间，更新新vector的数据结构的成员变量。<br/>
<strong>（2）insert</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public  iterator insert(iterator __position, const _Tp& __x) {
</span><span class='line'>    size_type __n = __position - begin();
</span><span class='line'>    if (_M_finish != _M_end_of_storage && __position == end()) {
</span><span class='line'>      construct(_M_finish, __x);
</span><span class='line'>      ++_M_finish;
</span><span class='line'>    }
</span><span class='line'>    else
</span><span class='line'>      _M_insert_aux(__position, __x);
</span><span class='line'>    return begin() + __n;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>与<code>push_back</code>类似，只是<code>push_back</code> 在最后插入，更为简单。insert 首先判断是否为在最后插入且容量足够，如果是最后插入且容量足够就就直接内部实现了。否则还是调用上面的辅助插入函数，该函数中首先判断容量是否足够，容量足的话，先构造一个新元素并以当前vector的最后一个元素的值作为其初始值，然后从倒数第二个元素开始从后往前拷贝，将前一元素的值赋给后一元素，知道当前插入位置。<br/>
<strong>(3)erase</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public  iterator erase(iterator __first, iterator __last) {
</span><span class='line'>    iterator __i = copy(__last, _M_finish, __first);
</span><span class='line'>    destroy(__i, _M_finish);
</span><span class='line'>    _M_finish = _M_finish - (__last - __first);
</span><span class='line'>    return __first;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>与insert相反，该函数将某些连续的元素从vector中删除，所以不存在容量不足等问题，但也不会将没有使用的空间归还给操作系统。这里只有简单的元素拷贝（copy）和元素的析构（destroy）。另外，需要说明的是，对于vector而言clear函数和erase函数是等同的，都只清空对应内存块的值，而不将空间归还给操作系统，所以vector的容量是只增不减的。而对于其他一些容器就有所不同了，比如list之类以node为单位的数据结构。<br/>
关于vector的内容就介绍到这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(2) 迭代器(Iterators)和Traits]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits/"/>
    <updated>2014-06-21T21:46:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有 <code>iterator.h</code>, <code>stl_iterator_base.h</code>, <code>concept_checks.h</code>, <code>stl_iterator.h</code>, <code>type_traits.h</code>, <code>stl_construct.h</code>, <code>stl_raw_storage_iter.h</code> 等7个文件。</p>

<h2>1. 迭代器的设计思维</h2>

<p>迭代器（iterators）是一种抽象的设计概念，显示程序中并没有直接对应于这个概念的实体。在 <em>Design Patterns</em> 一书中，对 iterators 模式的定义如下：提供一种方法，使之能够依序遍历某个聚合物（容器）所包含的各个元素，而又无需暴露该聚合物内部的表述方式。</p>

<p>在STL中迭代器扮演着重要的角色。STL的中心思想在于：将数据容器（container）和算法（algorithm）分开，彼此独立设计，最后再通过某种方式将他们衔接在一起。容器和算法的泛型化，从技术的角度来看并不困难，C++ 的 class template 和 function template 可以分别达到目标，难点在于如何设计二者之间的衔接器。</p>

<p>在STL中，起者这种衔接作用的是迭代器，它是一种行为类似指针的对象。指针的各种行为中最常见也最重要的便是内容获取（dereference）和成员访问（member access），因此迭代器最重要的工作就是对 <code>operator*</code> 和 <code>operator-&gt;</code> 进行重载。然而要对这两个操作符进行重载，就需要对容器内部的对象的数据类型和存储结构有所了解，于是在 STL 中迭代器的最终实现都是由容器本身来实现的，每种容器都有自己的迭代器实现，例如我们使用vector容器的迭代器的时候是这样用的 <code>vector&lt;int&gt;::iterator it;</code> 。而本文所讨论的迭代器是不依存于特定容器的迭代器，它在STL中主要有以下两个方面的作用（我自己的理解和总结）：</p>

<blockquote><ul>
<li>规定容器中需要实现的迭代器的类型及每种迭代器的标准接口</li>
<li>通过Traits编程技巧实现迭代器相应型别的获取，弥补 C++ 模板参数推导的不足，为配置器提供可以获取容器中对象型别的接口</li>
</ul>
</blockquote>

<p>其中前一个没啥好解释的。关于第二个，后面第3节会详细介绍，那就是Traits编程技巧。</p>

<!-- more -->


<h2>2. STL 迭代器的分类与标准接口</h2>

<h3>2.1 STL 迭代器的分类</h3>

<p>在SGI STL中迭代器按照移动特性与读写方式分为 <code>input_iterator</code>, <code>output_iterator</code>, <code>forward_iterator</code>, <code>bidirectional_iterator</code>, <code>random_access_iterator</code> 这5种，他们的定义都在 <code>stl_iterators_base.h</code> 文件中。这5种迭代器的特性如下：</p>

<blockquote><p>input_iterator:  这种迭代器所指对象只允许读取，而不允许改变，是只读的（read only）。
output_iterator:  与上面的相反，只能写（write only）。
forward_iterator: 同时允许读和写，适用于 <code>replace()</code> 等算法。
bidirectional_iterator: 可双向移动，即既可以按顺序访问，也可以按逆序访问。
random_access_iterator: 前4种只提供一部分指针运算功能，如前3种只支持 <code>operator++</code>, 而第4种还支持 <code>operator--</code>, 但这种随机访问迭代器还支持 <code>p+n</code>, <code>p-n</code>, <code>p[n]</code>, <code>p1-p2</code>, <code>p1+p2</code> 等。</p></blockquote>

<p>从以上的特性可以看出，<code>input_iterator</code> 和 <code>output_iterator</code> 都是特殊的 <code>forward_iterator</code>, 而 <code>forward_iterator</code> 是特殊的 <code>bidirectional_iterator</code>, <code>bidirectional_iterator</code> 是特殊的 <code>random_access_iterator</code> 。在 <code>stl_iterator_base.h</code> 文件中，他们的定义中我们并不能看到这种特性的表达，而只是规定了这几种迭代器类型及应该包含的成员属性，真正表达这些迭代器不同特性的代码在 <code>stl_iterator.h</code> 文件中。在 <code>stl_iterator_base.h</code> 文件中，除了对这几种迭代器类型进行规定之外，还提供了获取迭代器类型的接口、获取迭代器中的 <code>value_type</code> 类型、获取迭代器中的 <code>distance_type</code> 、获取两个迭代器的距离（<code>distance</code> 函数）、将迭代器向前推进距离 n （<code>advance</code> 函数）等标准接口。</p>

<h3>2.2 STL迭代器的标准接口</h3>

<p>在 <code>stl_iterator.h</code> 文件中，设计了 <code>back_insert_iterator</code>, <code>front_insert_iterator</code>, <code>insert_iterator</code>, <code>reverse_bidirectional_iterator</code>, <code>reverse_iterator</code>, <code>istream_iterator</code>, <code>ostream_iterator</code>,  等标准的迭代器，其中前3中都使用 <code>output_iterator</code> 的只写特性（只进行插入操作，只是插入的位置不同而已），而第4种使用的是 <code>bidirectional_iterator</code> 的双向访问特性，第5种使用的是 <code>random_access_iterator</code> 的随机访问特性。而最后两种标准迭代器分别是使用 <code>input_iterator</code> 和 <code>output_iterator</code> 特性的迭代器。从这几个标准的迭代器的定义中可以看出，主要是实现了 <code>operator=</code>, <code>operator*</code>, <code>operator-&gt;</code>, <code>operator==</code>, <code>operator++</code>, <code>operator--</code>, <code>operator+</code>, <code>operator-</code>, <code>operator+=</code>, <code>operator-=</code> 等指针操作的标准接口。根据定义的操作符的不同，就是不同类型的迭代器了。</p>

<p>例如，下面是 <code>back_insert_iterator</code> 的标准定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Container&gt;
</span><span class='line'>class back_insert_iterator {
</span><span class='line'>protected:
</span><span class='line'>  _Container* container;
</span><span class='line'>public:
</span><span class='line'>  // member variables
</span><span class='line'>  typedef _Container          container_type;
</span><span class='line'>  typedef output_iterator_tag iterator_category;
</span><span class='line'>  typedef void                value_type;
</span><span class='line'>  typedef void                difference_type;
</span><span class='line'>  typedef void                pointer;
</span><span class='line'>  typedef void                reference;
</span><span class='line'>  // member functions, mainly about operator overloading
</span><span class='line'>  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;&
</span><span class='line'>  operator=(const typename _Container::value_type& __value) { 
</span><span class='line'>    container-&gt;push_back(__value);
</span><span class='line'>    return *this;
</span><span class='line'>  }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator*() { return *this; }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator++() { return *this; }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator++(int) { return *this; }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>3. 迭代器相应型别与Traits编程技巧</h2>

<h3>3.1 迭代器相应型别</h3>

<p>在算法中运用迭代器是，很可能需要获取器相应型别，即迭代器所指对象的类型。此时需要使用到 function template 的参数推导（argument deducation）机制，在传入迭代器模板类型的同时，传入迭代器所指对象的模板类型，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template&lt;class I, class T&gt;
</span><span class='line'>void func_impl(I iter, T t){
</span><span class='line'>    // TODO: Add your code here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里不仅要传入类型 <code>class I</code>, 还要传入类型 <code>class T</code>。然而，迭代器的相应型别并不仅仅只有 “迭代器所指对象的类型” 这一种，例如在STL中就有如下5种：</p>

<blockquote><p>value_type: 迭代器所指对象的类型。<br/>
difference_type: 表示两个迭代器之间的距离，因此也可以用来表示一个容器的最大容量。例如一个提供计数功能的泛型算法 <code>count()</code> ，其返回值的类型就是迭代器的 <code>difference_type</code> .<br/>
reference_type: 从迭代器所指内容是否允许修改来看，迭代器分为 constant iterator 和 mutable iterator，如果传回一个可以修改的对象，一般是以 reference 的方式，因此需要传回引用时，使用此类型。<br/>
pointer_type: 在需要传回迭代器所指对象的地址时，使用这种类型。
iterator_category: 即前面提到5种的迭代器的类型。</p></blockquote>

<p>而且实际当中，并不是所有情况都可以通过以上的 template 的参数推导机制来实现（例如算法返回值的类型是迭代器所指对象的类型，template参数推导机制无法推导返回值类型），因此需要更一般化的解决方案，在STL中，这就是Traits编程技巧。</p>

<h3>3.2 Traits 编程技巧</h3>

<p>在STL的每个标准迭代器中，都定义了5个迭代器相应型别的成员变量，在STL定义了一个统一的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// In file stl_iterator_base.h
</span><span class='line'>template &lt;class _Category, class _Tp, class _Distance = ptrdiff_t,
</span><span class='line'>          class _Pointer = _Tp*, class _Reference = _Tp&&gt;
</span><span class='line'>struct iterator {
</span><span class='line'>  typedef _Category  iterator_category;
</span><span class='line'>  typedef _Tp        value_type;
</span><span class='line'>  typedef _Distance  difference_type;
</span><span class='line'>  typedef _Pointer   pointer;
</span><span class='line'>  typedef _Reference reference;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其他的迭代器都可以继承这个标注类，由于后面3个模板参数都有默认值，因此新的迭代器只需提供前两个参数即可（但在SGI STL中并没有使用继承机制）。这样在使用该迭代器的泛型算法中，可以返回这5种类型中的任意一种，而不需要依赖于 template 参数推导的机制。</p>

<p>在SGI STL中，如果启用 <code>__STL_CLASS_PARTIAL_SPECIALIZATION</code> 这个宏定义，还有这样一个标准的 <code>iterator_traits</code> ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// In file stl_iterator_base.h
</span><span class='line'>template &lt;class _Iterator&gt;
</span><span class='line'>struct iterator_traits {
</span><span class='line'>  typedef typename _Iterator::iterator_category iterator_category;
</span><span class='line'>  typedef typename _Iterator::value_type        value_type;
</span><span class='line'>  typedef typename _Iterator::difference_type   difference_type;
</span><span class='line'>  typedef typename _Iterator::pointer           pointer;
</span><span class='line'>  typedef typename _Iterator::reference         reference;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，这些类型不仅可以是泛型算法的返回值类型，还可以是传入参数的类型。例如 <code>iterator_category</code> 可以作为迭代器的接口 <code>advance()</code> 和 <code>distance()</code>  的传入参数之一。 不同类型的迭代器实现同一算法的方式可能不同，可以通过这个参数类型来区分不同的重载函数。</p>

<h2>4. SGI 中的 __type_traits</h2>

<p>traits 编程技巧非常赞，适度弥补了 C++ template 本身的不足。 STL 只对迭代器加以规范，设计了 <code>iterator_traits</code> 这样的东西，SGI进一步将这种技法扩展到了迭代器之外，于是有了所谓的 <code>__type_traits</code>。</p>

<p>在SGI中， <code>__type_traits</code> 可以获取一些类型的特殊属性，如该类型是否具备 trivial default ctor？是否具备 trivial copy ctor？是否具备 trivial assignment operator？是否具备 tivial dtor？是否是 plain old data（POD）？ 如果答案是肯定的，那么我们对这些类型进行构造、析构、拷贝、赋值等操作时，就可以采用比较有效的方法，如不调用该类型的默认构造、析构函数，而是直接调用 <code>malloc()</code>, <code>free()</code>, <code>memcpy()</code> 等等，这对于大量而频繁的操作容器，效率有显著的提升。</p>

<p>SGI中 <code>__type_traits</code> 的特性的实现都在 <code>type_traits.h</code> 文件中。其中将 <code>bool</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code> 等基本的数据类型及其相应的指针类型的这些特性都定义为 <code>__true_type</code>，这以为着，这些对基本类型进行构造、析构、拷贝、赋值等操作时，都是使用系统函数进行的。而除了这些类型之外的其他类型，除非用户指定了它的这些特性为 <code>__true_type</code>，默认都是 <code>__false_type</code> 的，不能直接调用系统函数来进行内存配置或赋值等，而需要调用该类型的构造函数、拷贝构造函数等。</p>

<p>另外，用户在自定义类型时，究竟一个 class 什么时候应该是 <code>__false_type</code> 的呢？一个简单的判断标准是：如果 class 内部有指针成员并需要对其进行动态配置内存是，这个 class 就需要定义为 <code>__false_type</code>的，需要给该类型定义构造函数、拷贝构造函数、析构函数等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(1) 空间配置器(allocator)]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator/"/>
    <updated>2014-06-13T22:04:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator</id>
    <content type="html"><![CDATA[<p>在STL中，Memory Allocator 处于最底层的位置，为一切的 Container 提供存储服务，是一切其他组件的基石。对于一般使用 STL 的用户而言，Allocator 是不可见的，如果需要对 STL 进行扩展，如编写自定义的容器，就需要调用 Allocator 的内存分配函数进行空间配置。本文涉及到的 SGI STL 源代码文件有 <code>alloc.h</code>, <code>stl_config.h</code>, <code>stl_alloc.h</code>, <code>stl_threads.h</code> 这4个。</p>

<p>在C++中，一个对象的内存配置和释放一般都包含两个步骤，对于内存的配置，首先是调用operator new来配置内存，然后调用对象的类的构造函数进行初始化；而对于内存释放，首先是调用析构函数，然后调用 operator delete进行释放。 如以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Foo { ... };
</span><span class='line'>Foo* pf = new Foo;
</span><span class='line'>...
</span><span class='line'>delete pf;</span></code></pre></td></tr></table></div></figure>


<p>Allocator 的作用相当于operator new 和operator delete的功能，只是它考虑得更加细致周全。SGI STL 中考虑到了内存分配失败的异常处理，内置轻量级内存池（主要用于处理小块内存的分配，应对内存碎片问题）实现， 多线程中的内存分配处理（主要是针对内存池的互斥访问）等，本文就主要分析 SGI STL 中在这三个方面是如何处理的。在介绍着三个方面之前，我们先来看看 Allocator的标准接口。</p>

<!-- more -->


<h2>1. Allocator 的标准接口</h2>

<p>在 SGI STL 中，Allocator的实现主要在文件<code>alloc.h</code> 和 <code>stl_alloc.h</code> 文件中。根据 STL 规范，Allocator 需提供如下的一些接口（见 <code>stl_alloc.h</code> 文件的第588行开始的class template allocator）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 标识数据类型的成员变量，关于中间的6个变量的涵义见后续文章（关于Traits编程技巧）
</span><span class='line'>typedef alloc _Alloc;
</span><span class='line'>typedef size_t     size_type;
</span><span class='line'>typedef ptrdiff_t  difference_type;
</span><span class='line'>typedef _Tp*       pointer;
</span><span class='line'>typedef const _Tp* const_pointer;
</span><span class='line'>typedef _Tp&       reference;
</span><span class='line'>typedef const _Tp& const_reference;
</span><span class='line'>typedef _Tp        value_type;
</span><span class='line'>template &lt;class _Tp1&gt; struct rebind {
</span><span class='line'>  typedef allocator&lt;_Tp1&gt; other;
</span><span class='line'>}; // 一个嵌套的class template，仅包含一个成员变量 other
</span><span class='line'>// 成员函数
</span><span class='line'>allocator() __STL_NOTHROW {}  // 默认构造函数，其中__STL_NOTHROW 在 stl_config.h中定义，要么为空，要么为 throw()
</span><span class='line'>allocator(const allocator&) __STL_NOTHROW {}  // 拷贝构造函数
</span><span class='line'>template &lt;class _Tp1&gt; allocator(const allocator&lt;_Tp1&gt;&) __STL_NOTHROW {} // 泛化的拷贝构造函数
</span><span class='line'>~allocator() __STL_NOTHROW {} // 析构函数
</span><span class='line'>pointer address(reference __x) const { return &__x; } // 返回对象的地址
</span><span class='line'>const_pointer address(const_reference __x) const { return &__x; }  // 返回const对象的地址
</span><span class='line'>_Tp* allocate(size_type __n, const void* = 0) {
</span><span class='line'>  return __n != 0 ? static_cast&lt;_Tp*&gt;(_Alloc::allocate(__n * sizeof(_Tp))) : 0; 
</span><span class='line'>  // 配置空间，如果申请的空间块数不为0，那么调用 _Alloc 也即 alloc 的 allocate 函数来分配内存，
</span><span class='line'>} //这里的 alloc 在 SGI STL 中默认使用的是__default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt;这个实现（见第402行）
</span><span class='line'>void deallocate(pointer __p, size_type __n) { _Alloc::deallocate(__p, __n * sizeof(_Tp)); } // 释放空间
</span><span class='line'>size_type max_size() const __STL_NOTHROW  // max_size() 函数，返回可成功配置的最大值
</span><span class='line'>    { return size_t(-1) / sizeof(_Tp); }  //这里没看懂，这里的size_t(-1)是什么意思？
</span><span class='line'>void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); } // 调用 new 来给新变量分配空间并赋值
</span><span class='line'>void destroy(pointer __p) { __p-&gt;~_Tp(); } // 调用 _Tp 的析构函数来释放空间</span></code></pre></td></tr></table></div></figure>


<p>在SGI STL中设计了如下几个空间分配的 class template：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;int __inst&gt; class __malloc_alloc_template // Malloc-based allocator.  Typically slower than default alloc
</span><span class='line'>typedef __malloc_alloc_template&lt;0&gt; malloc_alloc
</span><span class='line'>template&lt;class _Tp, class _Alloc&gt; class simple_alloc
</span><span class='line'>template &lt;class _Alloc&gt; class debug_alloc
</span><span class='line'>template &lt;bool threads, int inst&gt; class __default_alloc_template // Default node allocator.
</span><span class='line'>typedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc
</span><span class='line'>typedef __default_alloc_template&lt;false, 0&gt; single_client_alloc
</span><span class='line'>template &lt;class _Tp&gt;class allocator
</span><span class='line'>template&lt;&gt;class allocator&lt;void&gt;
</span><span class='line'>template &lt;class _Tp, class _Alloc&gt;struct __allocator
</span><span class='line'>template &lt;class _Alloc&gt;class __allocator&lt;void, _Alloc&gt;</span></code></pre></td></tr></table></div></figure>


<p>其中<code>simple_alloc</code> , <code>debug_alloc</code> , <code>allocator</code> 和 <code>__allocator</code>  的实现都比较简单，都是对其他适配器的一个简单封装（因为实际上还是调用其他配置器的方法，如 <code>_Alloc::allocate</code> ）。而真正内容比较充实的是 <code>__malloc_alloc_template</code> 和 <code>__default_alloc_template</code> 这两个配置器，这两个配置器就是 SGI STL 配置器的精华所在。其中 <code>__malloc_alloc_template</code> 是SGI STL 的第一层配置器，只是对系统的 <code>malloc</code> , <code>realloc</code> 函数的一个简单封装，并考虑到了分配失败后的异常处理。而 <code>__default_alloc_template</code> 是SGI STL 的第二层配置器，在第一层配置器的基础上还考虑了内存碎片的问题，通过内置一个轻量级的内存池。下文将先介绍第一级配置器的异常处理机制，然后介绍第二级配置器的内存池实现，及在多线程环境下内存池互斥访问的机制。</p>

<h2>2. SGI STL 内存分配失败的异常处理</h2>

<p>内存分配失败一般是由于out-of-memory(oom)，SGI STL 本身并不会去处理oom问题，而只是提供一个 private 的函数指针成员和一个 public 的设置该函数指针的方法，让用户来自定义异常处理逻辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private:
</span><span class='line'>#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
</span><span class='line'>  static void (* __malloc_alloc_oom_handler)();  // 函数指针
</span><span class='line'>#endif
</span><span class='line'>public:
</span><span class='line'>  static void (* __set_malloc_handler(void (*__f)()))() // 设置函数指针的public方法
</span><span class='line'>  {
</span><span class='line'>    void (* __old)() = __malloc_alloc_oom_handler;
</span><span class='line'>    __malloc_alloc_oom_handler = __f;
</span><span class='line'>    return(__old);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>如果用户没有调用该方法来设置异常处理函数，那么就不做任何异常处理，仅仅是想标准错误流输出一句out of memory并退出程序（对于使用new和C++特性的情况而言，则是抛出一个<code>std::bad_alloc()</code>异常）， 因为该函数指针的缺省值为0，此时对应的异常处理是 <code>__THROW_BAD_ALLOC</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// line 152 ~ 155
</span><span class='line'>#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
</span><span class='line'>template &lt;int __inst&gt;
</span><span class='line'>void (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = 0;
</span><span class='line'>#endif
</span><span class='line'>// in _S_oom_malloc and _S_oom_realloc
</span><span class='line'>__my_malloc_handler = __malloc_alloc_oom_handler;
</span><span class='line'>if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
</span><span class='line'>// in preprocess, line 41 ~ 50
</span><span class='line'>#ifndef __THROW_BAD_ALLOC
</span><span class='line'>#  if defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)
</span><span class='line'>#    include &lt;stdio.h&gt;
</span><span class='line'>#    include &lt;stdlib.h&gt;
</span><span class='line'>#    define __THROW_BAD_ALLOC fprintf(stderr, "out of memory\n"); exit(1)
</span><span class='line'>#  else /* Standard conforming out-of-memory handling */
</span><span class='line'>#    include &lt;new&gt;
</span><span class='line'>#    define __THROW_BAD_ALLOC throw std::bad_alloc()
</span><span class='line'>#  endif
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>SGI STL 内存配置失败的异常处理机制就是这样子了，提供一个默认的处理方法，也留有一个用户自定义处理异常的接口。</p>

<h2>3. SGI STL 内置轻量级内存池的实现</h2>

<p>第一级配置器 <code>__malloc_alloc_template</code> 仅仅只是对 <code>malloc</code> 的一层封装，没有考虑可能出现的内存碎片化问题。内存碎片化问题在大量申请小块内存是可能非常严重，最终导致碎片化的空闲内存无法充分利用。SGI 于是在第二级配置器 <code>__default_alloc_template</code> 中 内置了一个轻量级的内存池。 对于小内存块的申请，从内置的内存池中分配。然后维护一些空闲内存块的链表（简记为空闲链表，free list），小块内存使用完后都回收到空闲链表中，这样如果新来一个小内存块申请，如果对应的空闲链表不为空，就可以从空闲链表中分配空间给用户。具体而言SGI默认最大的小块内存大小为128bytes，并设置了128/8=16 个free list，每个list 分别维护大小为 8, 16, 24, &#8230;, 128bytes 的空间内存块（均为8的整数倍），如果用户申请的空间大小不足8的倍数，则向上取整。</p>

<p>SGI STL内置内存池的实现请看 <code>__default_alloc_template</code> 中被定义为 private 的这些成员变量和方法（去掉了部分预处理代码和互斥处理的代码）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private:
</span><span class='line'>#if ! (defined(__SUNPRO_CC) || defined(__GNUC__))
</span><span class='line'>    enum {_ALIGN = 8}; // 对齐大小
</span><span class='line'>    enum {_MAX_BYTES = 128}; // 最大有内置内存池来分配的内存大小
</span><span class='line'>    enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN  // 空闲链表个数
</span><span class='line'># endif
</span><span class='line'>  static size_t  _S_round_up(size_t __bytes) // 不是8的倍数，向上取整
</span><span class='line'>    { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }
</span><span class='line'>__PRIVATE:
</span><span class='line'>  union _Obj { // 空闲链表的每个node的定义
</span><span class='line'>        union _Obj* _M_free_list_link;
</span><span class='line'>        char _M_client_data[1];   };
</span><span class='line'>  static _Obj* __STL_VOLATILE _S_free_list[]; // 空闲链表数组
</span><span class='line'>  static size_t _S_freelist_index(size_t __bytes) { // __bytes 对应的free list的index
</span><span class='line'>        return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);
</span><span class='line'>  }
</span><span class='line'>  static void* _S_refill(size_t __n); // 从内存池中申请空间并构建free list，然后从free list中分配空间给用户
</span><span class='line'>  static char* _S_chunk_alloc(size_t __size, int& __nobjs); // 从内存池中分配空间
</span><span class='line'>  static char* _S_start_free;  // 内存池空闲部分的起始地址
</span><span class='line'>  static char* _S_end_free; // 内存池结束地址
</span><span class='line'>  static size_t _S_heap_size; // 内存池堆大小，主要用于配置内存池的大小</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>_S_refill</code> 和 <code>_S_chunk_alloc</code> 这两个函数是该内存池机制的核心。 <code>__default_alloc_template</code> 对外提供的 public 的接口有 <code>allocate</code>, <code>deallocate</code> 和 <code>reallocate</code> 这三个，其中涉及内存分配的 <code>allocate</code> 和 <code>reallocate</code> 的逻辑思路是，首先看申请的size（已round up）对应的free list是否为空，如果为空，则调用 <code>_S_refill</code> 来分配，否则直接从对应的free list中分配。而 <code>deallocate</code> 的逻辑是直接将空间插入到相应free list的最前面。</p>

<p>函数 <code>_S_refill</code> 的逻辑是，先调用 <code>_S_chunk_alloc</code> 从内存池中分配20块小内存（而不是用户申请的1块），将这20块中的第一块返回给用户，而将剩下的19块依次链接，构建一个free list。这样下次再申请同样大小的内存就不用再从内存池中取了。有了 <code>_S_refill</code> ，用户申请空间时，就不是直接从内存池中取了，而是从 free list 中取。因此 <code>allocate</code> 和 <code>reallocate</code> 在相应的free list为空时都只需直接调用 <code>_S_refill</code> 就行了。</p>

<p>这里默认是依次申请20块，但如果内存池空间不足以分配20块时，会尽量分配足够多的块，这些处理都在 <code>_S_chunk_alloc</code> 函数中。该函数的处理逻辑如下（源代码这里就不贴了）：</p>

<blockquote><p>1) 能够分配20块</p>

<blockquote><p>从内存池分配20块出来，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>2) 不足以分配20块，但至少能分配一块</p>

<blockquote><p>分配经量多的块数，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>3) 一块也分配不了</p>

<blockquote><p>首先计算新内存池大小 <code>size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4)</code><br/>
将现在内存池中剩余空间插入到适当的free list中<br/>
调用 <code>malloc</code> 来获取一大片空间作为新的内存池：<br/>
&#8211; 如果分配成功，则调整 <code>_S_end_free</code> 和 <code>_S_heap_size</code> 的值，并重新调用自身，从新的内存池中给用户分配空间；
&#8211; 否则，分配失败，考虑从比当前申请的空间大的free list中分配空间，如果无法找不到这样的非空free list，则调用第一级配置器的allocate，看oom机制能否解决问题</p></blockquote></blockquote>

<p>SGI STL的轻量级内存池的实现就是酱紫了，其实并不复杂。</p>

<h2>4. SGI STL 内存池在多线程下的互斥访问</h2>

<p>最后，我们来看看SGI STL中如何处理多线程下对内存池互斥访问的（实际上是对相应的free list进行互斥访问，这里访问是只需要对free list进行修改的访问操作）。在SGI的第二级配置器中与内存池互斥访问相关的就是 <code>_Lock</code> 这个类了，它仅仅只包含一个构造函数和一个析构函数，但这两个函数足够了。在构造函数中对内存池加锁，在析构函数中对内存池解锁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//// in __default_alloc_template
</span><span class='line'># ifdef __STL_THREADS
</span><span class='line'>    static _STL_mutex_lock _S_node_allocator_lock; // 互斥锁变量
</span><span class='line'># endif
</span><span class='line'>class _Lock {
</span><span class='line'>    public:
</span><span class='line'>        _Lock() { __NODE_ALLOCATOR_LOCK; }
</span><span class='line'>        ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }
</span><span class='line'>};
</span><span class='line'>//// in preprocess
</span><span class='line'>#ifdef __STL_THREADS
</span><span class='line'># include &lt;stl_threads.h&gt; // stl 的线程，只是对linux或windows线程的一个封装
</span><span class='line'># define __NODE_ALLOCATOR_THREADS true
</span><span class='line'># ifdef __STL_SGI_THREADS
</span><span class='line'>#   define __NODE_ALLOCATOR_LOCK if (threads && __us_rsthread_malloc) \
</span><span class='line'>                { _S_node_allocator_lock._M_acquire_lock(); }  // 获取锁
</span><span class='line'>#   define __NODE_ALLOCATOR_UNLOCK if (threads && __us_rsthread_malloc) \
</span><span class='line'>                { _S_node_allocator_lock._M_release_lock(); }  // 释放锁
</span><span class='line'># else /* !__STL_SGI_THREADS */
</span><span class='line'>#   define __NODE_ALLOCATOR_LOCK \
</span><span class='line'>        { if (threads) _S_node_allocator_lock._M_acquire_lock(); }
</span><span class='line'>#   define __NODE_ALLOCATOR_UNLOCK \
</span><span class='line'>        { if (threads) _S_node_allocator_lock._M_release_lock(); }
</span><span class='line'># endif
</span><span class='line'>#else /* !__STL_THREADS */
</span><span class='line'>#   define __NODE_ALLOCATOR_LOCK
</span><span class='line'>#   define __NODE_ALLOCATOR_UNLOCK
</span><span class='line'>#   define __NODE_ALLOCATOR_THREADS false
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>由于在 <code>__default_alloc_template</code> 的对外接口中，只有 <code>allocate</code> 和 <code>deallocate</code> 中直接涉及到对free list进行修改的操作，所以在这两个函数中，在对free list进行修改之前，都要实例化一个 <code>_Lock</code> 的对象 <code>__lock_instance</code> ，此时调用构造函数进行加锁，当函数结束时，的对象 <code>__lock_instance</code> 自动析构，释放锁。这样，在多线程下，可以保证free list的一致性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(0) STL简介]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/08/stl-source-insight-0-stl-overview/"/>
    <updated>2014-06-08T21:39:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/08/stl-source-insight-0-stl-overview</id>
    <content type="html"><![CDATA[<h2>0. 两个问题</h2>

<p>在介绍 STL 之前，先讨论两个问题：为什么要剖析 STL 源代码？如何剖析 STL 源代码？</p>

<p>首先是为什么要剖析 STL 源代码呢？ 有人会说，会使用 STL 不就性了，为什么一定要知道其内部的机制呢？ 对于大多数程序猿来说，确实没有必要去阅读或分析 STL 的源代码，但如果要想提升自己的编程修养，要相让自己编码的思想境界提升一个档次，还是很有必要读读 STL 这样的大师制作。阅读和分析之后，你会明白STL是如何分配和管理内存的（特别是对vector、string、deque等动态数据结构），是如何实现各种数据结构（特别是红黑树等比较复杂的数据结构）和相关算法的，又是如何将这些组件融合起来实现高内聚低耦合的。或许用《洋葱》的几句歌词获取最能表达你的明白这些问题之后的心情：</p>

<blockquote><p>如果你愿意一层一层<br/>
一层的剥开我的心<br/>
你会发现<br/>
你会讶异<br/>
你是我<br/>
最压抑<br/>
最深处的秘密</p>

<p>如果你愿意一层一层<br/>
一层的剥开我的心<br/>
你会鼻酸<br/>
你会流泪<br/>
只要你能<br/>
听到我<br/>
看到我的全心全意</p></blockquote>

<p>那么，如何剖析源代码呢？其实歌词中已经蕴含这答案了，那就是“一层一层一层的剥开”。当然，我这里说的一层一层不是说要一个函数step in 到底，而是说要按层次解读：首先从最外层结构框架着手，从整体上把握；然后从细处着笔，一个组件一个组件的来分析；在分析每个组件时，也是先把握改组件的全貌及其与其他组件的关联关系，然后在深入组件内部，了解其实现。在阅读和分析源码的过程中，首先要理解其功能，然后在看它是如何实现的。切忌纠缠于代码的细节或陷入源码而不能自拔，即坠入“不识庐山真面目，只缘身在此山中”的深渊！</p>

<p>因此，本文的目的在于，站在STL这座大山的山顶，一窥其全貌。随后的文章则深入每个组件，细细观赏每一处的风景。</p>

<!-- more -->


<h2>1. STL 简史</h2>

<p>声明：这里的内容主要来自<a href="http://zh.wikipedia.org/">Wiki中文网</a>，这里尽量简化其描述，虽然是尽量剪裁，但可能还是有些罗嗦，而且大段copy，掩面 ~(@&and;-&and;@)~</p>

<p>STL 是 Standard Template Library（标准模板库）的缩写。Standard 是指STL是C++标准程序库的一部分，Template是指STL是一套模板，这也是STL最本质的特征。标准模板库使得C++编程语言在有了同Java一样强大的类库的同时，保有了更大的可扩展性。</p>

<p>标准模板库系由 <a href="http://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a> 创造于1979年前后，这也正是 <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a> 创造C++的年代（非常巧的是，这两为大师都出生于1950年）。</p>

<p>Stepanov早期从事教育工作，在20世纪70年代就开始研究泛型程序设计了。1983年，Stepanov先生转至Polytechnic大学教书，继续研究泛型程序设计，同时写了许多Scheme的程序，应用在graph与network的算法上。1985年又转至GE公司专门教授高级程序设计，并将graph与network的Scheme程序，改用Ada写，用了Ada以后，他发现到一个动态（dynamically）类型的程序（如Scheme）与强制（strongly）类型的程序（如Ada）有多么的不同。在动态类型的程序中，所有类型都可以自由的转换成别的类型，而强制类型的程序却不能。但是，强制类型在出错时较容易发现程序错误。</p>

<p>1988年Stepanov先生转至HP公司运行开发泛型程序库的工作。此时，他已经认识C语言中指针(pointer)的威力，他表示一个程序员只要有些许硬件知识，就很容易接受C语言中指针的观念，同时也了解到C语言的所有数据结构均可以指针间接表示，这点是C与Ada、Scheme的最大不同。Stepanov认为，虽然C++中的继承功能可以表示泛型设计，但终究有个限制。虽然可以在基础类型（superclass）定义算法和接口，但不可能要求所有对象皆是继承这些，而且庞大的继承体系将降低虚拟（virtual）函数的运行效率，这便违反了所谓的“效率”原则。</p>

<p>在C++标准及C++模板概念的标准化过程中，Stepanov参加了许多有关的研讨会，并与C++之父Bjarne讨论模板的设计细节。Stepanov认为C++的函数模板（function template）应该像Ada一样，在声明其函数原型后，应该显式的声明一个函数模板之实例（instance）；Bjarne则不然，他认为可以通过C++的重载（overloading）功能来表达。几经争辩，Stepanov发现Bjarne是对的。</p>

<p>事实上，C++的模板，本身即是一套复杂的宏语言（macro language），宏语言最大的特色为：所有工作在编译时期就已完成。显式的声明函数模板之实例，与直接通过C++的重载功能隐式声明，结果一样，并无很大区别，只是前者加重程序员的负担，使得程序变得累赘。</p>

<p>1992年Meng Lee加入Alex的项目，成为另一位主要贡献者。1992年，HP泛型程序库计划退出，小组解散，只剩下Stepanov先生与Meng Lee小姐（她是东方人，标准模板库的英文名称其实是取STepanov与Lee而来），Lee先前研究的是编译器的制作，对C++的模板很熟，第一版的标准模板库中许多程序都是Lee的杰作。</p>

<p>1993年，Andy Koenig到斯坦福演讲，Stepanov便向他介绍标准模板库，Koenig听后，随即邀请Stepanov参加1993年11月的ANSI/ISO C++标准化会议，并发表演讲。Bell实验室的Andrew Koenig于1993年知道标准模板库研究计划后，邀请Alex于是年11月的ANSI/ISO C++标准委员会会议上展示其观念。并获得与会者热烈的回应。</p>

<p>1994年1月6日，Koenig寄封电子邮件给Stepanov，表示如果Stepanov愿意将标准模板库的说明文件撰写齐全，在1月25日前提出，便可能成为标准C++的一部份。</p>

<p>Alex于是在次年夏天在Waterloo举行的会议前完成其正式的提案，并以百分之八十压倒性多数，一举让这个巨大的计划成为C++ Standard的一部份。</p>

<p>标准模板库于1994年2月年正式成为ANSI/ISO C++的一部份，它的出现，促使C++程序员的思维方式更朝向泛型编程（generic program）发展。</p>

<p>目前，常见的STL实现版本有HP(Hewlett-Packard Company) STL，P.J Plauger版，Rouge Wave版，STLport版，SGI(Silicon Graphics Computer System .Inc) STL版等。</p>

<h2>2. STL 六大组件</h2>

<p>STL的官方文档将STL划分成了五个主要部分，分别是Containers（容器）、Iterators（迭代器）、Algorithms（算法）、函数对象（Function Objects）、空间分配（Memory Allocation）。而在侯姐的《STL源码剖析》中，还有一个组成部分是Adaptors（适配器）。本文也按照侯姐的规范将STL分为六个部分，而且介绍的顺序也按照他的书中的顺序来介绍。（PS：这里只是简要介绍六大组件的主要功能，真的很简要哦）</p>

<h4>2.1 Memory Allocation</h4>

<p>负责空间配置与管理，本质是实现动态空间配置、空间管理、空间释放的一系列class template。它是容器的底层接口，实际使用STL的用户是看不到Allocation的。</p>

<h4>2.2 Iterators</h4>

<p>迭代器扮演容器与算法之间的胶合剂，可以形象的理解为“泛型指针”。从实现的角度看，迭代器是一种将operator*、operator->、operator++、operator&#8211;等指针相关操作进行重载的class template。所有的STL容器都有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素，原生指针（Native pointer）也是一迭代器。</p>

<h4>2.3 Containers</h4>

<p>容器可以理解为各种数据结构，如vector、list、deque、set、map等用来存放特定结构的数据的容器，也是一系列的class template。对于普通用户而言，容器是最熟悉不过了，我们最经常使用的容器主要有 vector, queue, stack, deque, map。相信很多人对 STL 的接触是从使用容器开始的，也有很多人对 STL 印象最深刻的就是容器了。</p>

<h4>2.4 Algorithm</h4>

<p>主要是各种常用的算法，如sort、search、copy、erase、unique等。从实现的角度看，STL算法是一种function template。其中 sort 相信很多人并不陌生，在很多算法中我们都需要对数据进行排序。</p>

<h4>2.5 Function Objects</h4>

<p>函数对象的行为类似函数，但可作为算法的某种策略（policy）。从实现的角度看，函数对象是一种重载了operator()（函数调用操作符）的class或class template。</p>

<h4>2.6 Adaptors</h4>

<p>适配器是一种用来修饰容器或函数对象或迭代器的东西。例如，STL 提供queue和stack，虽然他们看似容器，但其实只能算是一种容器适配器，因为他们的底层实现完全借助于deque，所有的操作都由底层deque提供。改变functor/container/iterator的接口者称为functor/container/iterator adaptor。</p>

<h2>3. STL 各组件间的关系</h2>

<p>STL 六大组件间的关系如下图（来自侯姐《STL源码剖析》一书 p6）：<br/>
<img src="http://ibillxia.github.io/images/2014/IMAG2014060801.jpg">
其中 Container 通过 Allocator 取得数据存储空间，Alogrithm 通过 Iterator 存取 Container 内容，Functor 可以协助 Algorithm 完成不同的策略变化，Adapter 可以修饰或套接 Functor。这里的描述有些抽象，等详细了解了每个组件的功能职责后，就比较好懂了。</p>

<h2>4. SGI STL源码结构</h2>

<p>最后，这里简单介绍一下SGI STL 源码的结构。我下载的是<a href="https://www.sgi.com/tech/stl/download.html">SGI-STL-v3.3</a>， 它是基于1994年HP版STL改造而成的，最新版本v3.3的更新时间是2000年6月8日，共91个文件（SGI-STL官网文档中只列出了90个文件，少列了<code>vector.h</code>这个文件），1.1M大小（其实总代码量并不是很大，非常轻量级 (*&and;-&and;*) ，比较适合拿来彻底分析一遍 ）。</p>

<p>在这91个文件中，有<strong>37个</strong>以 <code>stl_</code> 开头的文件，这些都是STL内部实现文件。有<strong>23个</strong>无扩展名的文件，这些都是STL对外提供的标准接口。 有<strong>11个</strong>与无扩展名文件同名的.h文件，这是对应的old-style形式的头文件（至于为什么不是每个无扩展名（new-style）头文件都有对应的 <code>.h</code> 文件，我也不太清楚）。 还有<strong>20个</strong>文件，主要是为 <code>stl_</code> 开头的文件提供比较 common 的功能，如 <code>algobase.h</code>、<code>hashtable.h</code> 等，或者是对 <code>stl_</code> 开头的文件进行一次内部封装，还有其他一些杂项功能等。</p>

<h2>5. 参考及推荐</h2>

<h3>推荐阅读</h3>

<p>介绍STL模板的书，有两本比较经典：<br/>
一本是《Generic Programming and the STL》，中文翻译为《泛型编程与STL模板》，这本书由STL开发者 Matthew H.Austern编著，由STL之父Alexander Stepanov等大师审核的，介绍STL思想及其使用技巧，适合初学者使用。<br/>
另一本书是《STL源码剖析》，是《深入浅出MFC》的作者侯捷编写的，介绍STL源代码的实现，适合深入学习STL，不适合初学者。</p>

<h3>源码阅读与分析工具</h3>

<p>能在Linux下用熟练使用vim最好了，实在不行用 Code::Blocks 也挺不错的，可以查找函数原型、定义、调用等。在Windows下用Source Insight最好了，可惜不是免费的，但同样也可以用Code::Blocks 或 Visual C++ Express 等 IDE。<br/>
原本想用一个UML建模工具来分析一下STL中的类之间的关系的，但是看了看源代码，基本没有太多的继承之类的关系，而且很多UML工具对C++源码自动生成类图的功能支持得并不好，就放弃了。</p>

<h3>参考</h3>

<p>[1] <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">Wiki: Standard Template Library</a> <br/>
[2] <a href="http://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93">Wiki: 标准模板库</a> <br/>
[3] <a href="https://www.sgi.com/tech/stl/">Standard Template Library Programmer&#8217;s Guide</a> <br/>
[4] <a href="http://www.cnblogs.com/todototry/archive/2009/06/21/1507760.html">如何看懂源代码&#8211;(分析源代码方法)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言函数指针与C++函数调用操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/"/>
    <updated>2014-05-24T21:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在编程过程中，一些特殊的时候，我们需要向一个函数传递另一个函数的地址（比如在快速排序中，我们需要传入两个元素大小比较的函数的地址），此时在C语言中一般是通过传递一个函数指针来实现。最近在看《STL源码剖析》一书，上面提到，在C++中其实可以通过另一种方式实现，那就是函数调用操作符<code>()</code> 。本文首先介绍一下C语言中函数指针的用法，然后再介绍C++中函数调用操作符的用法。</p>

<h2>C语言中的函数指针</h2>

<p>我们先直接看一个例子吧。这个例子比较全面而且简单，其中的函数指针是带参数且有返回值的函数指针，而且还有把函数指针作为参数来传递的代码。这个例子来自 <a href="http://blog.jobbole.com/44639/">jobbole伯乐在线</a>，代码如下：</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'> 
</span><span class='line'>// 函数原型
</span><span class='line'>int add(int x, int y);
</span><span class='line'>int subtract(int x, int y);
</span><span class='line'>int domath(int (*mathop)(int, int), int x, int y);
</span><span class='line'> 
</span><span class='line'>// 加法 x+ y
</span><span class='line'>int add(int x, init y) {
</span><span class='line'>    return x + y;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 减法 x - y
</span><span class='line'>int subtract(int x, int y) {
</span><span class='line'>    return x - y;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 根据输入执行函数指针
</span><span class='line'>int domath(int (*mathop)(int, int), int x, int y) {
</span><span class='line'>    return (*mathop)(x, y);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main() {
</span><span class='line'>  // 用加法调用domath
</span><span class='line'>  int a = domath(add, 10, 2);
</span><span class='line'>  printf("Add gives: %d\n", a);
</span><span class='line'>   
</span><span class='line'>  // 用减法调用domath
</span><span class='line'>  int b = domath(subtract, 10, 2);
</span><span class='line'>  printf("Subtract gives: %d\n", b);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在函数 <code>domath</code> 中，我们可以根据传入的 <code>mathop</code> 函数指针来做不同的计算操作。另外，在该文中，最后提到函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名，解引用符 <code>*</code> 和取地址符 <code>&amp;</code> 用在函数名之前基本上都是多余的。这个之前还真不知道，新技能get，哈哈</p>

<h4>使用typedef</h4>

<p>在C语言中，对于函数指针，我们可以使用 <code>typedef</code> 将其定义为一种数据类型，这样我们就可以定义这种类型的变量了，就像使用普通的变量类型一样。下面是一个具体的定义（来自<a href="http://stackoverflow.com/questions/4295432/typedef-function-pointer">stackoverflow</a>）：</p>

<blockquote><p>typedef   void      (*FunctionFunc)  ( );
//         ^                ^         ^
//     return type      type name  arguments</p></blockquote>

<p>这里 <code>typedef</code> 的使用方法与一般的 <code>typedef A B</code> 的使用方式不不大一样的，如果没有接触过这种用法，可能开起来很别扭（在很多开源库中可能经常会碰到）。下面是其具体使用的实例（不完整代码）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FunctionFunc x;
</span><span class='line'>void doSomething() { printf("Hello there\n"); }
</span><span class='line'>x = &doSomething;
</span><span class='line'>x(); //prints "Hello there"</span></code></pre></td></tr></table></div></figure>


<p>根据上面提到的隐式转换，这里的取址符其实是没有必要的。关于C语言的函数指针就介绍到这儿了，接下来介绍一下C++的函数调用操作符。</p>

<h2>C++中的函数调用操作符</h2>

<p>在C++中，函数调用操作符是指左右小括弧 <code>()</code> ，该操作符是可以重载的。许多 STL 算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时按照使用者自定义的大小关系进行排序）。 上面讲了，在C语言中使用者是通过传递函数指针的方式来实现的。然而，函数指针有一些缺点，最重要的是它无法持有自己的状态（这里指局部状态，local states，具体可以通过后面的例子来理解），也无法达到组件技术中的可适配性 —— 也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>

<p>在C++中，对应于C中函数指针的东西是仿函数（functor），使用起来就像函数一样。其实现方法是对某个 class 进行 <code>operator()</code> 重载，他就成为一个仿函数。而要成为一个可适配（adaptable）的仿函数，还需要其他的一些努力（在《STL源码剖析》一书的第8章，关于适配器（adaptor）的内容）。这里，我们只拿书中的那个例子来简单的看一下仿函数的定义和使用方法吧。代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>
</span><span class='line'>// 对plus进行operator() 重载，使得 plus 变成了一个仿函数
</span><span class='line'>template&lt;class T&gt;
</span><span class='line'>struct plus{
</span><span class='line'>  T operator() (const T &x, const T &y) const {return x+y;}
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>// 对 minus 进行operator() 重载，使得 minus 变成了一个仿函数
</span><span class='line'>template&lt;class T&gt;
</span><span class='line'>struct minus{
</span><span class='line'>  T operator() (const T &x, const T &y) const {return x-y;}
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>int main(){
</span><span class='line'>  // 以下产生仿函数对象
</span><span class='line'>  plus&lt;int&gt; plusObj;
</span><span class='line'>  minus&lt;int&gt; minusObj;
</span><span class='line'>  // 以下使用仿函数，就像使用一般函数一样
</span><span class='line'>  cout&lt;&lt;plusObj(3,5)&lt;&lt;endl;
</span><span class='line'>  cout&lt;&lt;minusObj(3,5)&lt;&lt;endl;
</span><span class='line'>  // 也可以这样使用，通过临时对象（匿名对象）
</span><span class='line'>  cout&lt;&lt;plus&lt;int&gt;()(3,5)&lt;&lt;endl;
</span><span class='line'>  cout&lt;&lt;minus&lt;int&gt;()(3,5)&lt;&lt;endl;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的 <code>plus&lt;T&gt;</code> 和 <code>minus&lt;T&gt;</code> 已经非常接近 STL 的实现了，唯一的差别是它缺乏“可适配能力”，关于 STL 中的适配器（adaptor），我现在也还没看完该书，也还不太了解，在后续文章中应该会介绍到。读者可以自行google。</p>

<h2>在快排中使用函数调用操作符</h2>

<p>为了加深对函数调用操作符的理解，并将其真正用到实际中，这里拿快排这个非常典型的例子，并充分利用C++及STL的特性。下面是核心代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template&lt;typename InIt,typename FuncType&gt;
</span><span class='line'>void myqsort(InIt begin, InIt end, FuncType cmp){
</span><span class='line'>  if(begin==end||begin==end-1)return;
</span><span class='line'>  InIt it = mysplit(begin,end,cmp);
</span><span class='line'>  if(it!=end){
</span><span class='line'>      myqsort(begin,it,cmp);
</span><span class='line'>      myqsort(it+1,end,cmp);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>template&lt;typename InIt,typename FuncType&gt;
</span><span class='line'>InIt mysplit(InIt begin, InIt end, FuncType cmp){
</span><span class='line'>  InIt itl,itr;
</span><span class='line'>  itl=begin;
</span><span class='line'>  itr=end-1;
</span><span class='line'>  while(itl != itr){
</span><span class='line'>      while(itl != itr && cmp(*itr,*begin)&gt;0)itr--;
</span><span class='line'>      if(itl==itr)break;
</span><span class='line'>      while(itl != itr && cmp(*begin,*itl)&gt;0)itl++;
</span><span class='line'>      if(itl==itr)break;
</span><span class='line'>      swap(*itl,*itr);
</span><span class='line'>      itr--;
</span><span class='line'>  }
</span><span class='line'>  return itl;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Test{
</span><span class='line'>public:
</span><span class='line'>  double m_lf;
</span><span class='line'>  string m_str;
</span><span class='line'>
</span><span class='line'>public:
</span><span class='line'>  void set(){
</span><span class='line'>      cin&gt;&gt;m_lf;
</span><span class='line'>      cin&gt;&gt;m_str;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  void print(){
</span><span class='line'>      cout&lt;&lt;m_lf&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;m_str&lt;&lt;endl;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct cmpd{
</span><span class='line'>  int operator()(Test a,Test b){
</span><span class='line'>      if(abs(a.m_lf - b.m_lf)&lt;INF)return 0;
</span><span class='line'>      if(a.m_lf &gt; b.m_lf)return 1;
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct cmps{
</span><span class='line'>  int operator()(Test a,Test b){
</span><span class='line'>      return a.m_str.compare(b.m_str);
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>完整的代码及测试输入可以通过以下链接打包下载：<a href="https://ibillxia.github.io/upload/code/20140525.tar.gz">code-2014-05-25</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解C语言的define和内联函数]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c/"/>
    <updated>2014-05-17T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在 <code>Robert C.Searcord</code> 的 <em>The</em> <em>Cert</em> <em>C</em> <em>Secure</em> <em>Coding</em> <em>Standard</em> 一书中，关于宏定义的规范中第一条就是</p>

<blockquote><p>用内联函数或静态函数替代与函数相似的宏</p></blockquote>

<p>这个规范非常实用。内联函数是C99标准中新增的，当宏定义和内联函数可以互换时，应该优先考虑选择内联函数，这也是为什么在C++标准库函数中 <code>max</code>, <code>min</code>, <code>swap</code> 等都是通过内联函数来实现的原因。 宏定义是完全原封不动的很SB的替换，而内联函数则并非简单的文本替换，而是按函数调用的方式展开。关于内联函数相对于宏替换的优点，在wiki有如下几点的总结：</p>

<ul>
<li>宏调用并不执行类型检查，甚至连正常参数也不检查，但是函数调用却要检查。</li>
<li>C语言的宏使用的是文本替换，可能导致无法预料的后果，因为需要重新计算参数和操作顺序。</li>
<li>在宏中的编译错误很难发现，因为它们引用的是扩展的代码，而不是程序员键入的。</li>
<li>许多结构体使用宏或者使用不同的语法来表达很难理解。内联函数使用与普通函数相同的语言，可以随意的内联和不内联。</li>
<li>内联代码的调试信息通常比扩展的宏代码更有用。</li>
</ul>


<p>其中前面两条很好理解，相信大家应该不陌生，这里主要通过具体讨论一个该书中提到的一个程序实例来感受一下后面几点。</p>

<!-- more -->


<h2>宏定义引起的运行时错误</h2>

<p>下面我们看一个稍微复杂的例子，这个例子是在运行时才出现另我们感到意外的错误（这里的运行时错误并不是指 <code>Runtime Error</code>，么么哒）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int count=0;
</span><span class='line'>
</span><span class='line'>void g(void){
</span><span class='line'>    printf("Called g, count=%d.\n",count);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#define EXEC_BUMP(func) (func(),++count)
</span><span class='line'>typedef void(*exec_func)(void);  // 定义函数指针类型
</span><span class='line'>inline void exec_bump(exec_func f){
</span><span class='line'>    f();
</span><span class='line'>    ++count;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(void)
</span><span class='line'>{
</span><span class='line'>    int count=0;
</span><span class='line'>    while(count++&lt;10){
</span><span class='line'>        //EXEC_BUMP(g);  // (1) 宏定义实现
</span><span class='line'>      exec_bump(g);    // (2) 内联实现
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>使用宏定义的实现得到输出如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=0.</span></code></pre></td></tr></table></div></figure>


<p>这并不是我们想要的结果。而使用内联函数实现得到的输出如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Called g, count=0.
</span><span class='line'>Called g, count=1.
</span><span class='line'>Called g, count=2.
</span><span class='line'>Called g, count=3.
</span><span class='line'>Called g, count=4.
</span><span class='line'>Called g, count=5.
</span><span class='line'>Called g, count=6.
</span><span class='line'>Called g, count=7.
</span><span class='line'>Called g, count=8.
</span><span class='line'>Called g, count=9.</span></code></pre></td></tr></table></div></figure>


<p>这才是我们想要的结果。根据这两个输出结果，我们可以分析宏定义和内联的区别。通过宏定义时，直接使用 <code>(g(),++count);</code> 替换 <code>EXEC_BUMP(g);</code> 即可，这样每次调用 <code>g()</code> 函数时输出的 <code>count</code> 是全局的变量，所以都是0；而调用完 <code>g()</code> 函数之后，对局部变量 <code>count</code> 进行了自加操作，所以循环了5次。然而使用内联函数实现时，是按照函数调用的方式展开的，首先将全局变量和内联函数的传入参数压栈，然后是执行函数体，最后参数出栈；因此，内联函数中调用 <code>g()</code> 函数时输出的 <code>count</code> 也是全局变量，而且在内联函数中的 <code>++count</code> 也是对全局变量的操作，因此每次调用时输出的计数变量是递增的。  由此，我们可以更清楚的理解内联函数的替换原理了，它是由编译器显式地将函数调用中的压栈、函数体、出栈等步骤生成到可执行文件中，而不是像普通函数那样，函数体与调用该函数的代码部分是分离的，在调用内联函数时不需要跳转，因而执行效率会比普通的函数要高。（然而，如果函数本身代码较多，如果使用内联，就会在可执行文件中多个地方有该内联函数的函数体，这样可执行文件的大小就会比不使用内联的大。因此，一般不会将函数体复杂的函数定义为内联函数，除非特殊情况下，为了运行时间性能的考虑）</p>

<h2>宏定义的典型应用场景</h2>

<p>上面主要是对宏定义的贬低和歧视，其实宏定义也并非毫无用武之地，下面几种情况下宏定义还是不可替代的：</p>

<p>（1）用于实现局部函数 <br/>
此时无法用内联函数替代宏定义。因为宏定义代码块中的自动变量可以和引用宏的前后代码块互为使用，即宏引用前的代码快中的自动变量可以在宏中直接使用，而宏中定义的自动变量可以在宏引用的代码块之后使用。例如，比较常见是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#define FOR(i,n) for(int i=0;i&lt;n;i++)  // 宏定义部分
</span><span class='line'>
</span><span class='line'>int main(){
</span><span class='line'>  int a[]={1,2,3,4,5};
</span><span class='line'>  FOR(j,5) // 宏引用，这里j是在宏中才定义的自动变量
</span><span class='line'>      printf("%d ",a[j]);  // 但是可以在宏引用之后的代码中使用
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中对临时变量 <code>j</code> 的声明是在宏中定义的，可以在宏调用完后使用这个变量。同样的，也可以在宏定义前声明临时变量，而直接在宏中使用（不需要作为参数传递给宏）。</p>

<p>（2）宏可以支持某种形式的惰式计算<br/>
例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SELECT(s,v1,v2) ((s)?(v1):(v2))</span></code></pre></td></tr></table></div></figure>


<p>这个是无法用内联实现的。</p>

<p>(3)宏定义可以产生编译时常量<br/>
例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define ADD(a,b) ((a)+(b))</span></code></pre></td></tr></table></div></figure>


<p>调用 <code>ADD(3,4)</code> 会产生一个常量表达式 <code>3+4</code> ，而内联无此效果。</p>

<p>（4）实现类型通用的函数<br/>
如果不借助C++模板这样的机制，C语言内联是无法实现这样的功能的，而只能针对不同的数据类型定义不同名的函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 应用程序性能优化之 new/delete 操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator/"/>
    <updated>2014-05-11T20:33:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>

<p>C++ 程序的存储空间可以分为静态/全局存储区、栈区和堆区。下图展示了一个典型的Linux C/C++ 程序内存空间布局：</p>

<center><img src="http://ibillxia.github.io/images/2014/IMAG2014051101.png"></center>


<p>其中，每一部分的具体涵义如下：<br/>
- <strong>代码段（.text）</strong>：这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是<strong>只读</strong>的，防止程序由于错误而修改自身的指令。<br/>
- <strong>初始化数据段（.data）</strong>：这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=100;</code> 。 需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用 exec 函数启动该程序时从源程序文件中读入。<br/>
- <strong>未初始化数据段（.bss）</strong>：位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：<code>int sum;</code><br/>
- <strong>堆（Heap）</strong>：这个段用于在程序中进行动态内存申请，例如经常用到的 malloc，new 系列函数就是从这个段中申请内存。<br/>
- <strong>栈（Stack）</strong>：函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。<br/>
静态/全局存储区和栈区一般在程序编译阶段决定；而堆区则随着程序的运行而动态变化，每一次程序运行都会有不同的行为，因此动态内存管理对于一个程序在运行过程中占用的内存大小及程序运行性能有非常重要的影响。 本文主要探讨在C++中如何管理动态内存，以及如何使用 C++ 的语言特性来提高动态内存的管理效率，减少错误的发生。</p>

<!-- more -->


<h2>2. new/delete 操作符</h2>

<h4>2.1 C++内置new/delete的原型</h4>

<p>一般来说 C++ 的运行库提供了默认的全局 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的实现，程序也可以用自定义的实现来取代运行库的实现。 下面是 C++ 标准中定义的 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的声明（位于 <code>include/c++/new</code> 文件中）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>namespace std {
</span><span class='line'>  class bad_alloc : public exception {
</span><span class='line'>    public:
</span><span class='line'>      bad_alloc() throw() { }
</span><span class='line'>      virtual ~bad_alloc() throw();
</span><span class='line'>      virtual const char* what() const throw();
</span><span class='line'>  };
</span><span class='line'>  struct nothrow_t { };
</span><span class='line'>  extern const nothrow_t nothrow;
</span><span class='line'>  typedef void (*new_handler)();
</span><span class='line'>  new_handler set_new_handler(new_handler) throw();
</span><span class='line'>} // namespace std
</span><span class='line'>
</span><span class='line'>void* operator new(std::size_t) throw (std::bad_alloc);  // (1)
</span><span class='line'>void* operator new[](std::size_t) throw (std::bad_alloc);
</span><span class='line'>void operator delete(void*) throw();
</span><span class='line'>void operator delete[](void*) throw();
</span><span class='line'>void* operator new(std::size_t, const std::nothrow_t&) throw();  // (2)
</span><span class='line'>void* operator new[](std::size_t, const std::nothrow_t&) throw();
</span><span class='line'>void operator delete(void*, const std::nothrow_t&) throw();
</span><span class='line'>void operator delete[](void*, const std::nothrow_t&) throw();
</span><span class='line'>// Default placement versions of operator new.
</span><span class='line'>inline void* operator new(std::size_t, void* __p) throw() { return __p; }  // (3)
</span><span class='line'>inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
</span><span class='line'>// Default placement versions of operator delete.
</span><span class='line'>inline void  operator delete  (void*, void*) throw() { }
</span><span class='line'>inline void  operator delete[](void*, void*) throw() { }</span></code></pre></td></tr></table></div></figure>


<p>其中最后的 <code>inline</code> 函数是 <code>placement</code> 版本的 new/delete 操作，其特点在于分配的内存块的起始地址由用户给定（通过参数 <code>void* __p</code>）。 而前面两种 <code>new/delete</code> （(1)和(2)处）是系统决定待分配内存块的起始地址，区别在于：第一个在分配失败是会抛出 <code>bad_alloc</code> 异常（这是C++标准要求的）；而第二个则不抛出异常，返回0。 很多应用程序都没有处理内存分配的失败情况，但相对于一个需要长期稳定运行的系统来说，这种处理是必不可少的。 应用程序可以通过捕获 <code>bad_alloc</code> 异常或者检查返回值来检查内存分配是否成功，而更好的方法是使用C++中的 <code>new_handler()</code> 函数。 C++规定 <code>new_handler</code> 要执行如下操作中的一种：</p>

<ul>
<li>使 <code>new</code> 有更多的内存可用，然后返回</li>
<li>抛出一个 <code>bad_alloc</code> 或其派生类的异常</li>
<li>调用 <code>abort()</code> 或者 <code>exit()</code> 退出</li>
</ul>


<h4>2.2 使用 <code>new_handler</code> 自定义异常处理</h4>

<p>下面看一个例子，看看如何使用 <code>new_handler</code> 处理内存分配失败的情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;new&gt;
</span><span class='line'>#include&lt;cstdio&gt;
</span><span class='line'>#include&lt;Windows.h&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>char *gPool = NULL;
</span><span class='line'>void my_new_handler();
</span><span class='line'>
</span><span class='line'>int main(){
</span><span class='line'>    set_new_handler(my_new_handler);
</span><span class='line'>    gPool = new char[512*1024*1024];
</span><span class='line'>    if(gPool!=NULL){
</span><span class='line'>        printf("Preserve 512MB memory at %x.\n",gPool);
</span><span class='line'>    }
</span><span class='line'>    char *p = NULL;
</span><span class='line'>    for(int i=0;i&lt;4;i++){
</span><span class='line'>        p = new char[512*1024*1024];
</span><span class='line'>        printf("%d * 512M, p = %x\n",i+1,p);
</span><span class='line'>        Sleep(5000); // 休眠5s
</span><span class='line'>    }
</span><span class='line'>    printf("Done.\n");
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void my_new_handler(){
</span><span class='line'>    if(gPool!=NULL){
</span><span class='line'>        printf("try to get more memory...\n");
</span><span class='line'>        delete[] gPool; // 释放512MB内存空间
</span><span class='line'>        gPool = NULL;
</span><span class='line'>        return;
</span><span class='line'>    }else{
</span><span class='line'>        printf("I can not help...\n");
</span><span class='line'>        throw bad_alloc();  // 分配失败，抛出异常
</span><span class='line'>    }
</span><span class='line'>    return;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在 Windows 上编译并运行（使用Code::Blocks 13.12 IDE），得到如下输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Preserve 512MB memory at 7e0020.
</span><span class='line'>1 * 512M, p = 207f0020
</span><span class='line'>2 * 512M, p = 40800020
</span><span class='line'>try to get more memory...
</span><span class='line'>3 * 512M, p = 7e0020
</span><span class='line'>I can not help...
</span><span class='line'>terminate called after throwing an instance of 'std::bad_alloc'
</span><span class='line'>  what():  std::bad_alloc
</span><span class='line'>
</span><span class='line'>This application has requested the Runtime to terminate it in an unusual way.
</span><span class='line'>Please contact the application's support team for more information.</span></code></pre></td></tr></table></div></figure>


<p>在 Windows 的 win32 程序中，一个进程可以访问的内存空间是 4GB，但可以用来动态分配的最大内存是 2GB，因而上面的程序执行到第3次（为神马不是第4次？）动态内存分配时由于内存不够，调用了 <code>my_new_handler</code> 获得了内存（可以看到第3次分配的内存的地址和Preserve的内存地址是一样的），而当执行第4次内存分配时，<code>gPool</code> 已被分配，于是 <code>my_new_handler</code> 中抛出了 <code>bad_alloc</code> 异常，导致程序退出。 另外，在程序实际运行过程当中，会发现任务管理器中内存占用不会往上飙，这可能是因为操作系统的动态内存管理策略在作怪，不会说你一申请就立马全部给你，只是建立了一个映射表，只有当你真正用的时候才会给你。</p>

<h4>2.3 使用 placement new</h4>

<p>在 C++ 内置 <code>new/delete</code> 中最后的一种是 placement 形式的 <code>new/delete</code> ，即分配的内存地址有用户给定。下面是一个最简单的实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;cstdio&gt;
</span><span class='line'>#include &lt;new&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    char buffer[100];
</span><span class='line'>    char *p = new(buffer) char[20]; // call placement new
</span><span class='line'>    printf("Address of buffer: %x, and p: %x.\n",buffer,p);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>// output: Address of buffer: 28feb8, and p: 28feb8.</span></code></pre></td></tr></table></div></figure>


<p>可以看到 <code>buffer</code> 和 <code>p</code> 的地址是一样的。在大型应用程序中，我们可以充分利用 <code>placement new</code> 的特性，实现自己管理（分配、释放等）本应用的内存空间，基本思路就是： 首先申请一大片内存，然后对每个小的动态内存分配都使用 <code>placement new</code> 的方式进行申请。</p>

<h4>2.4 重载 placement new</h4>

<p>在 <code>new</code> 操作符中，除了可以使用自定义申请的内存的大小及位置，我们还可以通过重载系统的 <code>new/delete</code> 操作符来加入其它一些附加参数，但仍称之为 <code>placement new</code> 。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;cstdio&gt;
</span><span class='line'>#include&lt;new&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>#define DEBUG
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>// 自定义 new 操作符
</span><span class='line'>void *operator new[](unsigned int n, const char* file, int line){
</span><span class='line'>    printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
</span><span class='line'>    return ::operator new(n);
</span><span class='line'>}
</span><span class='line'>// 自定义 delete 操作符
</span><span class='line'>// void operator delete(void *p,const char *file, int line){
</span><span class='line'>void operator delete[](void *p,const char *file, int line){
</span><span class='line'>    printf("delete at file %s, in line %d\n",file,line);
</span><span class='line'>    ::operator delete(p);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>// 宏定义，必须放在重载函数之后
</span><span class='line'>#define new new(__FILE__, __LINE__)
</span><span class='line'>#define delete delete(__FILE__, __LINE__)
</span><span class='line'>#endif
</span><span class='line'>int main(){
</span><span class='line'>    char *p = new char[10];
</span><span class='line'>    //delete p;  // delete 的重载还有问题 "error: type 'int' argument given to 'delete', expected pointer"
</span><span class='line'>    delete[] p;  // 直接报语法错误，"error: expected primary-expression before ']' token"
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>// output: Alloc size: 10 at file D:\Programs\test\main.cpp, in line 22</span></code></pre></td></tr></table></div></figure>


<p>这在 <code>DEBUG</code> 模式下非常好使。</p>

<p>更新：关于 <code>placement new</code> 的 demo 改为如下代码后就没问题了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;cstdio&gt;
</span><span class='line'>#include&lt;new&gt;
</span><span class='line'>using namespace std;
</span><span class='line'>#define DEBUG
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>// 自定义 new 操作符
</span><span class='line'>void *operator new[](unsigned int n, const char* file, int line){
</span><span class='line'>    printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
</span><span class='line'>    return ::operator new(n);
</span><span class='line'>}
</span><span class='line'>// 自定义 delete 操作符
</span><span class='line'>void operator delete(void *p,char *file, int line){
</span><span class='line'>    printf("Delete at file %s, in line %d\n",file,line);
</span><span class='line'>    ::operator delete(p);
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>// 宏定义，必须放在重载函数之后
</span><span class='line'>#define new new(__FILE__, __LINE__)
</span><span class='line'>#define delete(ptr) delete(ptr,__FILE__, __LINE__)
</span><span class='line'>#endif
</span><span class='line'>int main(){
</span><span class='line'>    char *p = new char[10];
</span><span class='line'>    operator delete(p);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>但是还是不知道之前的代码为什么会出现这个错误，已在 <a href="http://stackoverflow.com/questions/23614215/destructor-error-in-c-type-int-argument-given-to-delete-expected-pointer">StackOverFlow上提问</a>，希望能得到满意的答案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 下 Android NDK 开发入门]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/04/android-ndk-development/"/>
    <updated>2014-05-04T23:53:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/04/android-ndk-development</id>
    <content type="html"><![CDATA[<p>本文首先介绍一下在 Ubuntu 下如何配置 Android NDK 开发环境，然后用一个简单的 hello-jni 项目来介绍 NDK 开发流程，本文的全部代码下载链接：<a href="https://ibillxia.github.io/upload/code/20140504-HelloJni.tar.gz">HelloJni.tar.gz</a>，也可以在我的 <a href="https://github.com/ibillxia/Demo/tree/master/HelloJni">GitHub</a> 上下载。</p>

<h2>1. 简介</h2>

<p>什么是 Android NDK 呢？ NDK(Native Development Kit) 是一个允许开发者用一些本地语言(C/C++)编写 Android App 的部分功能的工具集。对于一些特定的 App，NDK 非常有利于我们直接使用现成的用 C/C++ 编写的代码库（但对于大多数 App 来说，NDK 是没有必要的）。使用 NDK 进行 C/C++ Android 开发的基本结构和流程如下图（来自<a href="http://shihongzhi.com/ndk/">shihongzhi博客</a> ）：</p>

<center> <img src="http://ibillxia.github.io/images/2014/IMAG2014050401.jpg"> </center>


<p>在开始之前，这里要提醒大家：NDK 对大多数 App 而言是不会有太多的好处的，在 Android 上使用原生 C/C++ 代码并不会很明显的提升应用的性能，但却增加了你开发应用的复杂度。所以，仅仅在需要使用 NDK 时才使用它 —— 不要因为你更喜欢用 C/C++。典型的 NDK 应用场景是一些 CPU 操作密集而不需要太多内存的场合，如信号处理、物理模拟等等，很多这些处理过程都已经封装到了 Android 系统内部，所以当你不确定是否要使用本地 C/C++ 代码时，先看看你的需求，以及 Android 框架中的 API 是否已经提供你需要的功能。</p>

<!-- more -->


<h2>2.开发环境配置</h2>

<p>由于 NDK 开发过程中涉及到将 C/C++ 程序编译为动态库(.so文件)，所以首先系统中需要安装 C/C++ 的编译工具 gcc/g++，还要有 make 工具，一般情况下 Linux 系统会默认安装，如果没有安装请先安装这几个工具。然后是 Java 和 Android 开发相关环境的配置。首先需要安装 JDK，并配置 Java 的环境变量，然后是集成开发环境如 Eclipse 的安装和配置，这些也不是本文的重点，如果你没有安装，请自行 google 并安装配置好。</p>

<p>下面重点讲讲 Android 相关 SDK 的安装和配置，主要涉及到 Android SDK，ADT，NDK等。要进行 Android 开发，首先需要安装 Android SDK，要在 Eclipse 中进行开发的话，还需在 Eclipse 中安装 ADT(Android Develop Tools)，在 Android 官网上提供了 SDK 和 包含 ADT 的 Eclipse 的集成开发包，可以一起下载：<a href="http://dl.google.com/android/adt/22.6.2/adt-bundle-linux-x86-20140321.zip">adt-bundle-linux-x86-20140321.zip</a>。另外，还需要安装 NDK，下载地址：<a href="http://dl.google.com/android/ndk/android-ndk-r9d-linux-x86.tar.bz2">android-ndk-r9d-linux-x86.tar.bz2</a>。下载完这两个压缩包后解压并移动到 /usr/local 目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo mv Downloads/adt-bundle-x86-20140321/ /usr/local/adt-x86-20140321 
</span><span class='line'>mv Downloads/android-ndk-r9d/ /usr/local/adt-x86-20140321/ndk-r9d </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后配置环境变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo vim /etc/profile </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在 /etc/profile 最后添加如下两行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PATH=/usr/local/adt-x86-20140321/sdk/tools:/usr/local/adt-x86-20140321/sdk/platform-tools:$PATH 
</span><span class='line'>export PATH=/usr/local/adt-x86-20140321/ndk-r9d:$PATH </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>保存并退出，并用如下命令使设置生效：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source /etc/profile </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>完了可以执行如下命令看看设置是否生效：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo $PATH 
</span><span class='line'>adb --version 
</span><span class='line'>emulator -version 
</span><span class='line'>ndk-build --version </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>至此，开发环境已经配置完成了，接下来我们看一个 hello-jni 的例子。</p>

<h2>3.NDK 开发实例 hello-jni</h2>

<h4>3.1 JNI 简介</h4>

<p>首先我们了解一下什么是JNI。JNI(Java Native Interface)是一种在Java虚拟机控制下执行代码的标准机制。 代码被编写成汇编程序或者C/C++程序，并组装为动态库，从而提供了一个在Java平台上调用C/C++的一种途径。 JNI主要的竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及在某些具体平台上的Java虚拟机兼容性（当谈及JNI，这里并不特别针对Dalvik；JNI由Oracle开发，适用于所有Java虚拟机）。 关于JNI的更多内容可以参见该文：<a href="http://www.importnew.com/8038.html">Android NDK介绍</a>。</p>

<h4>3.2 Eclipse 配置</h4>

<p>下面以参考 Android NDK 自带的 hello-jni 示例程序改写的我自己的 hello-jni 来介绍开发流程。首先打开 Eclipse 并配置 Android SDK 和 NDK 的路径。 选择 Eclipse 的如下菜单：Window =&gt; Preferences =&gt; Android，点击浏览按钮设置 SDK 路径；Window =&gt; Preferences =&gt; Android =&gt; NDK，点击浏览按钮设置 NDK 路径。接下来按照简介中的开发流程图来一步一步介绍 NDK 开发步骤。</p>

<h4>3.3 创建 Android App 并添加 Native Support</h4>

<p>首先用Eclipse 创建一个空的 Android App，命名为 HelloJni。在项目上点击右键，选择 Android Tools =&gt; Add Native Support&#8230; ，在弹出的对话框中填入 HelloJni 并确定，会发现项目中多了一个 jni 目录，并自动生成了 HelloJni.cpp 和 Android.mk 文件，分别是我们需要封装的native C++ 代码和编译它的 Makefile 文件。</p>

<h4>3.4 编写 java API</h4>

<p>原本按照图一中的流程我们需要先编写一些 C/C++ 原生的代码，但实际中，为了简便起见，我们可以使用 jdk 的 javah 工具（如果没有， <code>sudo apt-get update</code> 一下）来根据 java 调用 C/C++ API 的接口类来自动生成 jni 的头文件。因此，我们需要先做第3步的内容，这里编写的 Java API 接口 HelloCal 类（在 <code>src/io.ibillxia.hellojni</code> 路径下）如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//HelloCal.java
</span><span class='line'>package io.ibillxia.hellojni; 
</span><span class='line'>
</span><span class='line'>public class HelloCal { 
</span><span class='line'>  static { 
</span><span class='line'>      System.loadLibrary("HelloJni"); // 加载 jni 动态库 
</span><span class='line'>  } 
</span><span class='line'>  
</span><span class='line'>  public native String helloSay(); // 返回字符串 
</span><span class='line'>  public native int helloAdd(int a,int b); // 两个整数相加 
</span><span class='line'>  public native int helloSub(int a,int b); // 两个整数相减 
</span><span class='line'>  public native int helloMul(int a,int b); // 两个整数相乘 
</span><span class='line'>  public native int helloDiv(int a,int b); // 两个整数相除 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>3.5 使用 javah 生成 jni 格式的 C/C++ API</h4>

<p>编写完 java API 后在 Eclipse 中 build 一下生成对应 .class 文件，然后使用 javah 工具根据该 class 文件自动生成 jni API 的头文件。在 HelloJni App 根目录下执行如下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>javah -classpath ./bin/classes -d jni io.ibillxia.hellojni.HelloCal </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>其中 <code>-classpath ./bin/classes</code> 表示类的路径，<code>-d jni</code> 表示生成的头文件存放的目录， <code>io.ibillxia.hellojni.HelloCal</code> 则是完整类名，如果不出意外，在 <code>~/workspace/HelloJni/jni</code> 目录下生成了 <code>io_ibillxia_hellojni_HelloCal.h</code> 。然后根据这个头文件的内容，编写 <code>HelloCal.cpp</code> 文件实现头文件中声明的接口，具体的头文件和 cpp 源文件内容见源码压缩包。值得一提的是，在 cpp 源文件中，对数据运算后可能产生溢出进行了判断，对于溢出异常这里处理的办法是，如果上溢则返回最大值，下溢则返回最小值。实际中，这样做可能还不是很合理，比较好的做法是，在 cpp 中处理并返回异常值，并在相应的 Java API 中针对返回的异常值进行不同的处理，即在 cpp 中只检查异常，而真正处理异常则由 Java API 来处理。</p>

<p>注意，这里需要添加一下 C/C++ 的包含目录，否则会报错。选中 jni文件夹，右键选择 Properties =&gt; C/C++ General =&gt; Paths and Symbols =&gt; Includes，点击 Add 一个一个添加如下依赖库：</p>

<blockquote><p>/usr/include<br/>
/usr/include/c++/4.8<br/>
/usr/include/c++/4.8/backward<br/>
/usr/include/i386-linux-gnu<br/>
/usr/include/i386-linux-gnu/c++/4.8<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include<br/>
/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed<br/>
/usr/local/include<br/>
/usr/local/adt-x86-20140321/ndk-r9d/platforms/android-19/arch-arm/usr/include</p></blockquote>

<p>添加完后 build 一下，看看是否有错误，如果不出意外，应该在 <code>HelloJni/libs/armeabi/</code> 目录下生成了 <code>libHelloJni.so</code> 文件。</p>

<h4>3.6 编写 Android App</h4>

<p>最后是编写 Android App，并在 App 中调用 Jni 接口函数。在 <code>io.ibillxia.hellojni</code> 包中新建一个 Java 类 HelloJni ，编写如下代码（import 内容省略，具体见源码压缩包）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//HelloJni.java
</span><span class='line'>public class HelloJni extends Activity {
</span><span class='line'>    /** Called when the activity is first created. */
</span><span class='line'>    @Override
</span><span class='line'>    public void onCreate(Bundle savedInstanceState)
</span><span class='line'>    {
</span><span class='line'>        super.onCreate(savedInstanceState);
</span><span class='line'>        setContentView(R.layout.hello_jni);
</span><span class='line'>        
</span><span class='line'>        Button btn = (Button)findViewById(R.id.btn_cal);
</span><span class='line'>        btn.setOnClickListener(new Button.OnClickListener() {
</span><span class='line'>          @Override
</span><span class='line'>          public void onClick(View v) {
</span><span class='line'>              // TODO Auto-generated method stub
</span><span class='line'>              TextView tv1 = (TextView) findViewById(R.id.textView1);
</span><span class='line'>              TextView tv2 = (TextView) findViewById(R.id.textView2);
</span><span class='line'>              TextView tv3 = (TextView) findViewById(R.id.textView3);
</span><span class='line'>
</span><span class='line'>              int a = Integer.parseInt(tv1.getText().toString());
</span><span class='line'>              int b = Integer.parseInt(tv2.getText().toString());
</span><span class='line'>              HelloCal cal = new HelloCal();
</span><span class='line'>              int c = cal.helloAdd(a,b);
</span><span class='line'>              String str = cal.helloSay();  
</span><span class='line'>              tv3.setText(str + Integer.toString(c));
</span><span class='line'>          }
</span><span class='line'>        });
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>另外，还需要设计对应的 layout xml 文件，具体见源码压缩包。 最后上一张运行效果截图：
<img src="http://ibillxia.github.io/images/2014/IMAG2014050402.png">
图中输入的两个数的和超过了 int 能表示的最大值，出现上溢，但返回的是最大值。如果输入的两个数本身就超出范围将出现
<code>Unfortunately, HelloJni has stopped.</code> 的异常的对话框。实际过程中，究竟在哪一步检测并处理异常，还是一个值得商讨的问题。如果是引用第三方的库，可能需要对相应的接口提供充分的测试，对于可以并且方便在 native code 层面解决的异常就在 native code 层面上处理掉，实在不行也要在 Java API 层面上解决掉，比如这里需要在 Java 中判断输入参数本身的合法性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Octopress博客配置Twitter Bootstrap主题]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress/"/>
    <updated>2014-04-28T22:37:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/28/configure-twitter-bootstrap-theme-in-octopress</id>
    <content type="html"><![CDATA[<p>很长一段时间以来就看到各种基于 Twitter Bootstrap 主题的博客很清爽，而且对 Tag 的归档也做得很赞，于是很想将自己的博客也换成 Bootstrap 的主题，随着看到的博客越来越多，自己的 Octopress 主题先得越来越臃肿，而 Tags 归档功能也相形见绌，更换主题的欲望越来越强烈了。于是乎，趁这个周末捣鼓了一番，最终大功告成，在这里分享一下具体过程。</p>

<h2>Bootstrap 主题的安装</h2>

<p>首先下载适用于 Octopress 的 <a href="https://github.com/bkutil/bootstrap-theme">Bootstrap主题</a> 并解压缩到博客的 .theme 目录，然后安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install['bootstrap']</span></code></pre></td></tr></table></div></figure>


<p>安装的过程中可能会提示有 sass 或其他依赖库的语法错误神马的，这是因为 sass 的版本过低，可以通过如下命令来跟新：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bundle update sass</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>其他库的升级类推。升级完这些依赖后，要修改你的 Octopress 博客的根目录下的 Gemfile 中的版本说明。最后再重新运行上上条的 rake install 指令。这样就完成主体的安装了，是不是很简单（实际操作中遇到问题的话，一般都是 jekyll 等各种的库的版本及相互间的依赖问题，通过 bundle update 基本上都能搞定）。安装完了之后，可以运行 rake generate 和 rake preview 来看看效果了。</p>

<h2>配置 Tags 归档</h2>

<p>接下来是配置类似 <a href="http://ibillxia.github.io/blog/tags/">这种显示结果</a> 的 Tags 归档页面了。</p>

<p>首先，需要安装 <a href="https://github.com/plusjade/jekyll-bootstrap">jekyll-bootstrap</a> 的一些东西，请先下载并解压。主要是 <em>includes/JB/ 目录下的内容，将 JB 文件夹拷贝到 $BLOG_HOME/source/</em>includes/ 目录下，还有 jekyll-bootstrap 根目录下的 tags.html 拷贝到你想展示 Tags 的目录，并在 _config.yml 文件中配置 tag_dir 项的值为该目录，例如我这里的配置是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tag_dir: blog/tags</span></code></pre></td></tr></table></div></figure>


<p>所以我的 tags.html 文件放在了 $BLOG_HOME/source/blog/tags 目录下，并将 tags.html 重命名为 index.html。</p>

<p>这些配置好了后，你就可以先运行 rake generate 和 rake preview 来看看效果。可以发现 Tags 归档页的显示还是不太友好。那么我们需要加入一些自己的 css 样式。这里我参考了 pluskid 师兄的博客的 css 代码并略有修改，在我新建的 $BLOG_HOME/source/stylesheets/style.css 文件中加入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* tag_box */
</span><span class='line'>.tag_box {
</span><span class='line'>  list-style:none;
</span><span class='line'>  margin:0;
</span><span class='line'>  padding:2px 0 ;
</span><span class='line'>  overflow:hidden;
</span><span class='line'>}
</span><span class='line'>.tag_box li {
</span><span class='line'>  line-height:20px;
</span><span class='line'>  margin:0;
</span><span class='line'>}
</span><span class='line'>.tag_box.inline li {
</span><span class='line'>  float:left;
</span><span class='line'>  padding:2px 0 ;
</span><span class='line'>}
</span><span class='line'>.tag_box a {
</span><span class='line'>  padding: 2px;
</span><span class='line'>  margin: 2px;
</span><span class='line'>  background: #eee;
</span><span class='line'>  color:#005F6B;
</span><span class='line'>  border-radius: 3px;
</span><span class='line'>  text-decoration:none;
</span><span class='line'>}
</span><span class='line'>.tag_box a span{
</span><span class='line'>  vertical-align:super;
</span><span class='line'>  font-size:0.8em;
</span><span class='line'>}
</span><span class='line'>.tag_box a.active {
</span><span class='line'>  background:#57A957;
</span><span class='line'>  border:1px solid #4C964D;
</span><span class='line'>  color:#FFF;
</span><span class='line'>}
</span><span class='line'>/* tag_box end */</span></code></pre></td></tr></table></div></figure>


<p>注意，这里由于新加了 css 文件，要让其生效，需要在 html 模板中加入引用，具体我是在 $BLOG_HOME/source/_includes/head.html 文件中加入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;link href="http://ibillxia.github.io/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css"&gt;</span></code></pre></td></tr></table></div></figure>


<p>你也可以直接在 html 模板中加入 css 代码而不用新建 css 文件并添加引用。</p>

<p>至此，已经配置完成了 ^_^ 可以运行 rake generate 和 rake preview 来看看最终效果了。</p>

<p>PS：本博客的主题及插件相关文件和代码可以看我的 GitHub Repo：<a href="https://github.com/ibillxia/xoctopress/tree/master">xoctopress</a>. 如有问题，可以参考这些代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全排列及某排列的后继的求解及其STL实现的分析]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation/"/>
    <updated>2014-04-24T23:24:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation</id>
    <content type="html"><![CDATA[<p>在Leetcode上有好几道全排列相关的题，一直以来只是会写基于递归的全排列生成算法，遇到这几道题后，搜了下一些非递归的实现方法，发现其实全排列的生成还是很有规律的有木有！这里就总结一下递归和非递归的全排列生成方法，并分析一下 STL 的实现。</p>

<p>递归和非递归实现全排列生成的方法也分别有多种，递归法有基于交换的，有基于链接的，还有回溯，非递归法有排序、回溯、求模等，关于所有这些方法的具体实现参见 <a href="http://mengliao.blog.51cto.com/876134/824079">全排列的六种算法</a>. 本文只实现一种递归和一种非递归算法，并在最后对 STL 的非递归算法进行分析。</p>

<p>本文的全部代码下载：<a href="http://ibillxia.github.io/upload/code/20140424.cpp">code</a>.</p>

<h2>递归法求全排列</h2>

<p>递归法的基本思路是这样的：</p>

<blockquote><p>首先选一个元素排在第一个（有 n 中选法）；
然后递归的对剩下的所有元素进行全排列；
直到一个元素的全排列是其本身。</p></blockquote>

<p>假设给定的元素序列为 &lt;e1, e2, &#8230;, en>，其全排列表示为 P(e1, e2, &#8230;, en)，则对递归的第一步展开有：</p>

<blockquote><p>P(e1, e2, &#8230;, en) = {
&lt;e1, P(e2, e3, &#8230;, en)>,
&lt;e2, P(e1, e3, &#8230;, en)>,
&#8230; &#8230;
&lt;en, P(e1, e2, &#8230;, e(n-1))> }</p></blockquote>

<!-- more -->


<p> 一个简单的实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void recursive_permute(int A[],int i,int n){
</span><span class='line'>  if(i==n-1){
</span><span class='line'>      for(int j=0;j&lt;n;j++)
</span><span class='line'>          cout&lt;&lt;A[j]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'>  for(int j=i;j&lt;n;j++){
</span><span class='line'>      swap(A[i],A[j]);  // choose A[j] as the ith element
</span><span class='line'>      recursive_permute(A,i+1,n);
</span><span class='line'>      swap(A[i],A[j]);  // reset to enter next for
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个实现非常精简易懂，但却存在一个问题，那就是当数组 A 中存在重复元素时，得到的排列是有重复的，这是因为在第8行的循环中，可能会选取重复的 A[j] 值。 为了去掉重复排列，我们可以在选取第 i 个数 A[j] 之前（即交换 A[i] 和 A[j] 之前），判断值为 A[j] 的元素是否选取过，即要判断在 A[i] 到 A[j-1] 中是否存在与 A[j] 相等的元素，如果出现过，说明 A[i] 选 A[j] 这个排列已经生成过了，可以直接跳过当前的 A[j] 看看是否可以选取 A[j+1] 作为 A[i] 了。比如上面的 e1 = e2，那么无重复的全排列应该是：</p>

<blockquote><p>P(e1, e2, &#8230;, en) = {
&lt;e1, P(e2, e3, &#8230;, en)>,
&lt;e3, P(e1, e2, e4, &#8230;, en)>,
&#8230; &#8230;
&lt;en, P(e1, e2, &#8230;, e(n-1))> }</p></blockquote>

<p>添加这个限制的递归实现代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void recursive_permute2(int A[],int i,int n){
</span><span class='line'>  if(i==n-1){
</span><span class='line'>      for(int j=0;j&lt;n;j++)
</span><span class='line'>          cout&lt;&lt;A[j]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>      return;
</span><span class='line'>  }
</span><span class='line'>  for(int j=i;j&lt;n;j++){
</span><span class='line'>      int k;
</span><span class='line'>      for(k=i;k&lt;j;k++)if(A[k]==A[j])break; // A[j] already used
</span><span class='line'>      if(k&lt;j)continue;
</span><span class='line'>      swap(A[i],A[j]);  // choose A[j] as the ith element
</span><span class='line'>      recursive_permute2(A,i+1,n);
</span><span class='line'>      swap(A[i],A[j]);  // reset to enter next for
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>至此，递归法实现全排列的求解就总结到这儿了，下面来看看非递归怎么实现。</p>

<h2>非递归法求全排列</h2>

<p>非递归法求全排列的一种最常用算法是基于字典序的全排列生成算法，其基本思路为，先解决生成一个序列在字典序下的下一个排列这个问题，然后利用这个来一次求解每一个排列。其中求解给定序列在字典序下的下一个排列序列的基本思想如下：</p>

<blockquote><ol>
<li>对于给定序列 &lt;e1, e2, &#8230;, en> 从右往左找到第一个非递增点，设下标为 i；</li>
<li>从右往左查找第一个比 e[i] 大的数，设其下标为 j;</li>
<li>交换 e[i] 和 e[j] 的值；</li>
<li>将序列 e[i+1..n] 逆置。</li>
</ol>
</blockquote>

<p>举个例子，如下图（修改自 <a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html">Next Permutation 解题报告</a> ）所示：</p>

<center><img src="http://ibillxia.github.io/images/2014/IMAG2014042401.png"></center>


<p>上面的说明已经很接近伪代码了，具体实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bool next_permute(int A[],int n){
</span><span class='line'>  int i,j;
</span><span class='line'>  // step .1
</span><span class='line'>  if(n&lt;2)return false;
</span><span class='line'>  for(i=n-2;i&gt;=0;i--){
</span><span class='line'>      if(A[i]&lt;A[i+1])break;
</span><span class='line'>  }
</span><span class='line'>  if(i&lt;0)return false; // A[0] is maximum, no next permute for it
</span><span class='line'>  // step .2
</span><span class='line'>  for(j=n-1;j&gt;i;j--){
</span><span class='line'>      if(A[j]&gt;A[i])break;
</span><span class='line'>  }
</span><span class='line'>  // step .3
</span><span class='line'>  swap(A[i],A[j]);
</span><span class='line'>  // step .4
</span><span class='line'>  while(++i &lt; --n){
</span><span class='line'>      swap(A[i],A[n]);
</span><span class='line'>  }
</span><span class='line'>  return true;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里将其返回值定义为 bool 类型，可以方便后面求解全排列时调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void non_recursive_permute(int A[],int n){
</span><span class='line'>  sort(A,A+n);
</span><span class='line'>  int i;
</span><span class='line'>  do{
</span><span class='line'>      for(i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
</span><span class='line'>      cout&lt;&lt;endl;
</span><span class='line'>  }while(next_permute(A,n));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面这个函数即实现了按字典序生成全排列的功能，而且对于输入含有重复值的情况，不会生成重复的排列。对于非递归实现，很容易分析其时间复杂度，next_permute 的时间复杂度为 O(n)，而 non_recursive_permute 的时间复杂度为 O(n*n!)。</p>

<h2>STL 中 next permute 的实现</h2>

<p>下面来分析一下 STL 中是如何实现 next permute 的，在 stl_algo.h 中我们可以找到 next_permutation 的实现，基本思路也是按照上面的四步走来实现的，具体见如下代码及注释：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  @brief  Permute range into the next @a dictionary ordering.
</span><span class='line'> *  @ingroup sorting_algorithms
</span><span class='line'> *  @param  first  Start of range.
</span><span class='line'> *  @param  last   End of range.
</span><span class='line'> *  @return  False if wrapped to first permutation, true otherwise.
</span><span class='line'> *
</span><span class='line'> *  Treats all permutations of the range as a set of @a dictionary sorted
</span><span class='line'> *  sequences.  Permutes the current sequence into the next one of this set.
</span><span class='line'> *  Returns true if there are more sequences to generate.  If the sequence
</span><span class='line'> *  is the largest of the set, the smallest is generated and false returned.
</span><span class='line'>*/
</span><span class='line'>template&lt;typename _BidirectionalIterator&gt;
</span><span class='line'>bool
</span><span class='line'>next_permutation(_BidirectionalIterator __first,
</span><span class='line'>                 _BidirectionalIterator __last)
</span><span class='line'>{
</span><span class='line'>    // concept requirements
</span><span class='line'>    __glibcxx_function_requires(_BidirectionalIteratorConcept&lt;
</span><span class='line'>                                _BidirectionalIterator&gt;)
</span><span class='line'>    __glibcxx_function_requires(_LessThanComparableConcept&lt;
</span><span class='line'>                                typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;)
</span><span class='line'>    __glibcxx_requires_valid_range(__first, __last);
</span><span class='line'>
</span><span class='line'>    if (__first == __last)  // 容器中没有元素，没有 next permute
</span><span class='line'>        return false;
</span><span class='line'>    _BidirectionalIterator __i = __first;
</span><span class='line'>    ++__i;
</span><span class='line'>    if (__i == __last)  // 容器中只有一个元素，同没有
</span><span class='line'>        return false;
</span><span class='line'>    __i = __last;
</span><span class='line'>    --__i;  // 将 __i 指向最后一个元素
</span><span class='line'>
</span><span class='line'>    for(;;) {
</span><span class='line'>        _BidirectionalIterator __ii = __i;  
</span><span class='line'>        --__i;
</span><span class='line'>        if (*__i &lt; *__ii) {  // step .1, 这里的 __i 就相当于上面step 1中的i
</span><span class='line'>            _BidirectionalIterator __j = __last;
</span><span class='line'>            while (!(*__i &lt; *--__j)) {  // step .2, 这里的 __j 就相当上面 step 2中的j
</span><span class='line'>            }
</span><span class='line'>            std::iter_swap(__i, __j);  // step .3 交换
</span><span class='line'>            std::reverse(__ii, __last);  // step .4 逆置
</span><span class='line'>            return true;
</span><span class='line'>        }
</span><span class='line'>        if (__i == __first) {  // 直到 __i = __first 还是没有 *__i &lt; *__ii ，说明序列是递减排列的
</span><span class='line'>            std::reverse(__first, __last); // 本应该没有下一个排列，但这里将字典序中第一个排列作为最后一个排列的 next permute
</span><span class='line'>            return false; // 这里返回 false 而不是 true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里是用双向迭代器对容器中的元素进行操作的，一个调用的实例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &num) {
</span><span class='line'>  vector&lt;vector&lt;int&gt; &gt; ans;
</span><span class='line'>  sort(num.begin(),num.end());
</span><span class='line'>  do{
</span><span class='line'>      ans.push_back(num);
</span><span class='line'>  }while(next_permutation(num.begin(),num.end()));
</span><span class='line'>  return ans;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，其实 STL 的 next permute 的实现跟我们的非递归算法是一致的。但这里有两个问题：一是，这里看似有二重循环（在 for 中套 while ），但实际上复杂度是 n+n =》 O(n) 的（可以为什么要写成这种二重循环的形式捏？不解）；二是，我们可以看到在 for 循环中，对 __ii 这个变量进行了多次声明，为什么不将其声明放在 for 外面捏？（虽然待排列的元素数 n 不会很大，但这样多次声明一个迭代器变量，虽不会占用过多内存，但在声明时调用构造函数和析构函数也是有一定的时间开销的吧，虽然相对于求全排列的复杂度 O(n*n!) 几乎可以忽略不计）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[原地交换两个变量的值]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place/"/>
    <updated>2014-04-11T22:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/11/swap-two-variables-in-place</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>在码代码的过程中，不经意间就会遇到需要交换两个变量的情况，一般情况下都是通过新定义一个同类型的变量来中转，但自己也知道可以不用定义新变量直接原地交换，但具体如何原地交换以及其中可能隐藏的bug却了解得不是很清楚，于是乎google了一下，发现这里面还真是有很多学问呢，这里整理和总结一下。</p>

<p>原地交换两个变量，最主要有加减法和异或法。</p>

<p>本文完整代码链接：<a href="../upload/code/20140411.cpp">20140411.cpp</a></p>

<h2>加减法</h2>

<p>加减法最简单、最好理解了，设待交换的两个变量分别为 a 和 b ，首先将两者的和赋给 a ；然后将 a 与 b的差赋给 b ，这样 b 就是 a 原来的值了；最后再将 a 与 b 的差赋给 a ，这样 a 就是 b 原来的值了。具体代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inline template &lt;class T&gt;
</span><span class='line'>void xswap(T &a,T &b){
</span><span class='line'>    a=a+b;
</span><span class='line'>  //printf("a=%u\n",a);
</span><span class='line'>    b=a-b;
</span><span class='line'>    a=a-b;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>当然也可以先减后加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>inline template &lt;class T&gt;
</span><span class='line'>void xswap2(T &a,T &b){
</span><span class='line'>    a=a-b;
</span><span class='line'>  //printf("a=%u\n",a);
</span><span class='line'>    b=a+b;
</span><span class='line'>    a=b-a;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里实现的原理与先加后减类似。粗一看，这样实现两个变量的原地交换很简单有效。但是，这其中有一个很隐秘的bug，就是溢出的问题，在先加后减的实现中，如果 a 与 b 的和大于该类型的能表示的最大值，会发生神马捏？我写了一个 main 函数来简单的测试了一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    unsigned char a=255,b=1;
</span><span class='line'>    printf("a=%u,b=%u\n",a,b);
</span><span class='line'>    xswap(a,b);
</span><span class='line'>    printf("a=%u,b=%u\n",a,b);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>将上面的 xswap 函数中的注释取消，编译运行后（使用Code::Blocks 13.12 MinGW g++编译），得到如下输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a=255,b=1
</span><span class='line'>a=0
</span><span class='line'>a=1,b=255</span></code></pre></td></tr></table></div></figure>


<p>可以看到其中第2行输出的 a 的值为 0，产生了上溢（如果 a , b 同为负，可能产生下溢）。虽然最后交换的结果还是对的，但溢出的部分可能对内存中其他变量产生不可预测的后果。因此，不建议这么实现原地交换两个变量，如果实在需要用这种方法，一定要在进行加或减之前，判断时候回产生溢出。</p>

<h2>异或法</h2>

<p>异或法的基本原理类似，但还利用了异或的如下两个特性： a ^ 0 = a, a ^ a = 0. 用异或来实现两个变量的交换如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class T&gt;
</span><span class='line'>inline void xswap3(T &a,T &b){
</span><span class='line'>    a=a^b;
</span><span class='line'>    b=a^b;
</span><span class='line'>    a=b^a;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>由于异或是按位运算的，所以不存在溢出问题。因此，如果一定要原地实现两个变量的交换的话，建议用异或的方法。</p>

<h2>原地交换多个变量</h2>

<p>实际上，我们还可以利用上面的思想，将两个变量扩展到多个变量的原地交换，例如三个变量的交换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class T&gt;
</span><span class='line'>inline void swap3(T &a,T &b,T &c){
</span><span class='line'>    a=a^b;
</span><span class='line'>    b=a^b;
</span><span class='line'>    a=b^a;
</span><span class='line'>    b=b^c;
</span><span class='line'>    c=b^c;
</span><span class='line'>    b=b^c;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>即先交换 a 和 b，再交换 b (=a) 和 c。另外，上面的式子可以简化和压缩到一个式子，具体的技巧读者可以自行google，这里不提倡这么做。</p>

<h2>STL是如何实现swap的</h2>

<p>最后，我们来看看STL标准库是如何实现swap的（这里的实现版本是 move.h 文件中的一个，在 STL 中还有针对 vector, string, tree, map, multimap, deque 的 swap 函数）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>*  @brief Swaps two values.
</span><span class='line'>*  @ingroup mutating_algorithms
</span><span class='line'>*  @param  __a  A thing of arbitrary type.
</span><span class='line'>*  @param  __b  Another thing of arbitrary type.
</span><span class='line'>*  @return   Nothing.
</span><span class='line'>*/
</span><span class='line'>template&lt;typename _Tp&gt;
</span><span class='line'>inline void
</span><span class='line'>swap(_Tp& __a, _Tp& __b)
</span><span class='line'>{
</span><span class='line'>  // concept requirements
</span><span class='line'>  __glibcxx_function_requires(_SGIAssignableConcept&lt;_Tp&gt;)
</span><span class='line'>
</span><span class='line'>  _Tp __tmp = _GLIBCXX_MOVE(__a);
</span><span class='line'>  __a = _GLIBCXX_MOVE(__b);
</span><span class='line'>  __b = _GLIBCXX_MOVE(__tmp);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，这里新声明了一个变量 __tmp 来中转。至于为什么没有原地进行交换，一个可能的解释是：对于 inline 函数来说，函数调用的代码会直接被改函数体替换，再经过编译优化，最后可能只需要借助一个寄存器变量就可以实现两个变量的交换了，这是非常快的，与通过按位的异或运算的实现，在性能上区别不是太大。</p>

<h2>update</h2>

<p>关于溢出的更深入的讨论，可以看看陈浩的最新博文 <a href="http://coolshell.cn/articles/11466.html">C语言的整型溢出问题</a> . 这里面有提到溢出的几个危害，还有关于 C 语言标准、编译器对溢出是如何处理和对待的，以及如何写代码实现预先判断溢出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go并发编程初探]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try/"/>
    <updated>2014-03-16T23:35:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/16/go-concurrent-programming-first-try</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>最近在做的一个项目，需要对大量数据进行一些基本的统计和处理，整个程序的思路很简单，但处理起来却很慢，特别是有二重循环的地方，龟速前进，眼看着16核32线程
的服务器只有一个线程被利用，束手无策。之前一直听说Go是一门对并发编程有很好的支持的语言，七牛的许牛大力推崇Go语言，于是就开始了对Go并行编程的探索之旅。</p>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031601.jpg"></center>




<!--more-->




<h2>一些准备工作</h2>


<p>在正式开始Go并行编程之前，首先我们需要准备Go的编程开发环境：Go编译器、Go编辑器。</br>
在<a href="http://golang.org/">golang的官网</a>上有go的下载链接：</br>
<a href="http://code.google.com/p/go/downloads/list">http://code.google.com/p/go/downloads/list</a></br>
我选择的是go1.2.1.windows-amd64.msi安装包，下载完后直接点击该安装包，按照默认选项安装即可。安装完后，可以在命令行中查看go版本以检查是否安装成功：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\Users\Bill&gt;go version
</span><span class='line'>go version go1.2.1 windows/amd64</span></code></pre></td></tr></table></div></figure>

然后，我们需要安装一个用于Go开发的IDE。当然也可以用通用的文本编辑器就可以，比如notepad、vi等，但这都是一些轻量级的，对于初学者来说还是不太合适的。
网上有很多推荐的IDE，主要有LiteIDE、Eclipse+Goclipse、GoIde等，以及vim/emacs搭配go插件等，这里我选择的是LiteIDE，下载地址：</br>
<a href="http://sourceforge.net/projects/liteide/files/x21/">http://sourceforge.net/projects/liteide/files/x21/</a></br>
下载安装后，我们就可以开始go编程了。可以先运行一个Hello world程序，这里就不演示了，具体见：<a href="http://tour.golangtc.com/#1">Go 指南</a>
</p>




<p>关于Go的一些特性的介绍这里也不讲了，有兴趣的可以移步酷壳的这两篇文章<a href="http://coolshell.cn/articles/8460.html">Go 语言简介（上）— 语法</a> 
和 <a href="http://coolshell.cn/articles/8489.html">Go 语言简介（下）— 特性</a>。下面我们直接进入Go并发编程。</p>




<h2>Go并发编程</h2>


<h4>#0x01.goroutine</h4>


<p>优雅的并发编程范式，完善的并发支持，出色的并发性能是Go语言区别于其他语言的一大特色。在Go中，通过一种叫做goroutine的go协程这种轻量级线程来支持
并发编程范式。协程是比进程和线程更轻量级的线程，go语言标准库提供的所有系统调用操作都会出让CPU给其他goroutine，协程的切换管理不依赖于系统的线程和
进程，也不依赖于CPU的核心数量。下面我们来看一个简单的goroutine的实例。

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import "fmt"
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  arr := [10]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      fmt.Print("Result of ", i, ":")
</span><span class='line'>      go func() {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          fmt.Println(arr[i])
</span><span class='line'>      }()
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

Go从main package的main()函数开始执行，这段代码的功能是计算arr[i]=i+i*i，其中i取值从0到9，每一个i计算完后立即输出。其中go为golang的关键字，启动
一个协程（goroutine）。程序的运行的结果是什么呢？我们期望的结果应该是这样的吧：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of 0:0
</span><span class='line'>Result of 1:2
</span><span class='line'>Result of 2:6
</span><span class='line'>Result of 3:12
</span><span class='line'>Result of 4:20
</span><span class='line'>Result of 5:30
</span><span class='line'>Result of 6:42
</span><span class='line'>Result of 7:56
</span><span class='line'>Result of 8:72
</span><span class='line'>Result of 9:90
</span><span class='line'>Done</span></code></pre></td></tr></table></div></figure>

可是在LiteIDE中运行后，却会发现结果是这样子的：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:Done</span></code></pre></td></tr></table></div></figure>

这是为神马捏？怎么第9~12行的go func(){&#8230;}() 这段代码好像更笨就没有执行嘛？！莫非这是golang的bug？</p>




<p>其实，这与golang的程序执行顺序有关。go程序从初始化main package并执行main()函数开始，当main()函数返回时，程序退出，且程序并不等待其他goroutine
（非主goroutine）结束。于是上面的程序中，主函数虽然启动了10gegoroutine，但都没来得及执行，程序就已经退出了。那么怎么解决这个问题捏？很显然，我们
在退出程序之前，需要判断这些创建的goroutine执行完了没。我们可以用一个全局变量来计数执行了的协程数，如果计数变量小于10，我们就等待或sleep。</p>




<h4>#0x02.并发通讯</h4>


<p>等一等，多个协程读写同一个变量，我们是不是需要对这个变量枷锁呀？答案是肯定的，我们可以采用类似与C/C++的线程通讯、数据共享的思路来实现，如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "runtime"
</span><span class='line'>  "sync"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  var cnt int = 0  // 全局计数器
</span><span class='line'>  mylock := &sync.Mutex{}  // 互斥锁
</span><span class='line'>  arr := [10]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      fmt.Print("Result of ", i, ":")
</span><span class='line'>      go func() {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          fmt.Println(arr[i])
</span><span class='line'>          mylock.Lock() // 写之前枷锁
</span><span class='line'>          cnt++
</span><span class='line'>          mylock.Unlock() // 写之后释放锁
</span><span class='line'>      }()
</span><span class='line'>  }
</span><span class='line'>  for {
</span><span class='line'>      mylock.Lock() // 读之前枷锁
</span><span class='line'>      temp := cnt
</span><span class='line'>      mylock.Unlock() // 读之后释放锁
</span><span class='line'>      runtime.Gosched() // 协程切换
</span><span class='line'>      if temp &gt;= 10 {
</span><span class='line'>          break
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

执行以上程序，应该能够得到我们之前预期的那样的结果吧？可以运行之后，我们发现，结果却是这样的：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of 0:Result of 1:Result of 2:Result of 3:Result of 4:Result of 5:Result of 6:Result of 7:Result of 8:Result of 9:panic: runtime error: index out of range
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>

出现了运行时错误，数组下表越界了？！第17行还是没有输出？！经过一番修改，得到如下代码：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "runtime"
</span><span class='line'>  "sync"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  var cnt int = 0  // 全局计数器
</span><span class='line'>  mylock := &sync.Mutex{}  // 互斥锁
</span><span class='line'>  arr := [11]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      go func() {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          mylock.Lock() // 写之前枷锁
</span><span class='line'>          cnt++
</span><span class='line'>          mylock.Unlock() // 写之后释放锁
</span><span class='line'>      }()
</span><span class='line'>  }
</span><span class='line'>  for {
</span><span class='line'>      mylock.Lock() // 读之前枷锁
</span><span class='line'>      temp := cnt
</span><span class='line'>      mylock.Unlock() // 读之后释放锁
</span><span class='line'>      runtime.Gosched() // 协程切换
</span><span class='line'>      if temp &gt;= 10 {
</span><span class='line'>          break
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  for i := 0; i &lt; 11; i++ {
</span><span class='line'>      fmt.Println("Result of ", i, ":", arr[i])
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

这下应该能得到预期的结果了吧。可以运行程序后，有傻眼了，结果是：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Result of  0 : 0
</span><span class='line'>Result of  1 : 0
</span><span class='line'>Result of  2 : 0
</span><span class='line'>Result of  3 : 0
</span><span class='line'>Result of  4 : 0
</span><span class='line'>Result of  5 : 0
</span><span class='line'>Result of  6 : 0
</span><span class='line'>Result of  7 : 0
</span><span class='line'>Result of  8 : 0
</span><span class='line'>Result of  9 : 0
</span><span class='line'>Result of  10 : 110
</span><span class='line'>Done</span></code></pre></td></tr></table></div></figure>

神马？arr[0]~arr[9]肿么都是0，肿么会冒出一个arr[10]=110？！即使把第15、16行顺序互换，得到的结果还是一样！！！这真是一场噩梦啊！！！仔细对比许书上的例子，
我们发现，这里使用的是匿名函数创建协程，匿名函数中使用了全局的变量，而每次使用go关键字创建协程后，程序不是继续往下执行，而是继续返回到for这一行来执行，首先i++，
然后判断i<10，成立就继续执行并创建协程，10个协程创建完了之后，才真正开始匿名函数的执行，而此时i已经是10了，对于每一个协程i都是10，因此最终只计算了一个arr[10]=110，
这也是为什么申请10个单位的数组时会出现运行时错误。而这完全不是我们所要的结果，那么怎么办呢？我们不妨用带参数的匿名函数来试试？如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "runtime"
</span><span class='line'>  "sync"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  var cnt int = 0  // 全局计数器
</span><span class='line'>  mylock := &sync.Mutex{}  // 互斥锁
</span><span class='line'>  arr := [11]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      go func(i int) { // 这里的i是形参
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          mylock.Lock() // 写之前枷锁
</span><span class='line'>          cnt++
</span><span class='line'>          mylock.Unlock() // 写之后释放锁
</span><span class='line'>      }(i) // 这里的i是实参
</span><span class='line'>  }
</span><span class='line'>  for {
</span><span class='line'>      mylock.Lock() // 读之前枷锁
</span><span class='line'>      temp := cnt
</span><span class='line'>      mylock.Unlock() // 读之后释放锁
</span><span class='line'>      runtime.Gosched() // 协程切换
</span><span class='line'>      if temp &gt;= 10 {
</span><span class='line'>          break
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  for i := 0; i &lt; 11; i++ {
</span><span class='line'>      fmt.Println("Result of ", i, ":", arr[i])
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

终于，我们总算得到了想要的结果了，经过不懈努力终于大功告成。这里没创建一个协程，都有一个实参值传给形参，在匿名函数中就不存在共享的全局变量i了。
然而，在让我们回头看看我们的代码，却会发现，这与一般的多线程程序有什么区别的，而且写起来会感觉更麻烦，有过之而无不及啊！</p>




<p>想象一下，在一个大的系统中具有无数的锁、无数的共享变量、无数的业务逻辑与错误处理分支，那将是一场噩梦。这噩梦就是众多C/C++开发者正在经历的，其实Java和C#开发
者也好不到哪里去。Go语言既然以并发编程作为语言的最核心优势，当然不至于将这样的问题用这么无奈的方式来解决。Go语言提供的是另一种通信模型，即以消息机制而非共享
内存作为通信方式。</p>




<h4>#0x03.channel</h4>


<p>Go语言提供的消息通信机制被称为channel，接下来我们将详细介绍channel。现在，让我们用Go语言社区的那句著名的口号来开始这一小节： </br>
<blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p></blockquote>
channel是Go语言在语言级别提供的goroutine间的通信方式，可以使用channel在两个或多个goroutine之间传递消息。channel是进程内的通信方式，因此通过channel传递
对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，建议用分布式系统的方法来解决，比如使用Socket或者HTTP等通信协议。
channel是类型相关的。也就是说，一个channel只能传递一种类型的值，这个类型需要在声明channel时指定。我们先看下用channel的方式重写上面的例子是什么样子的

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import "fmt"
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  chs := make([]chan int, 10) // 申请一个10维的channel数组
</span><span class='line'>  arr := [11]int{}
</span><span class='line'>  for i := 0; i &lt; 10; i++ {
</span><span class='line'>      chs[i] = make(chan int) // 对每个channel初始化
</span><span class='line'>      go func(ch chan int, i int) {
</span><span class='line'>          arr[i] = i + i*i
</span><span class='line'>          ch &lt;- 1  // 写channel，应该在函数体的最后一行，许书（P94，代码清单4-4）上有bug
</span><span class='line'>      }(chs[i], i)
</span><span class='line'>  }
</span><span class='line'>  for _, ch := range chs {
</span><span class='line'>      &lt;-ch // 读channel
</span><span class='line'>  }
</span><span class='line'>  for i := 0; i &lt; 11; i++ {
</span><span class='line'>      fmt.Println("Result of ", i, ":", arr[i])
</span><span class='line'>  }
</span><span class='line'>  fmt.Println("Done")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

在这段代码中，我们给每个goroutine分配了一个channel，在每个goroutine执行完时对该goroutine的channel进行写操作，而在第16行进行读操作，对于每个channel，
只有完成了写操作之后，才可以进行读取，否则会处于阻塞状态。因此在10个goroutine没有执行完之前，main函数是不会退出的。这样是不是比共享内存的方式更简单
而优雅呢？其实，我们还可以对代码继续进行简化，可以将匿名函数的传递的channel参数省去，而在匿名函数内部直接使用全局的chs[i]，匿名函数可以修改为如下：

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>go func(i int) {
</span><span class='line'>  arr[i] = i + i*i
</span><span class='line'>  chs[i] &lt;- 1  // 写channel
</span><span class='line'>}(i)</span></code></pre></td></tr></table></div></figure>

</p>




<p>到这里，go的并行编程基本已经入门了，关于channel的更多详细的用法可以参见参考资料。</p>




<h2>参考资料</h2>


<p>[1] golang 官方主页：<a href="http://golang.org/">http://golang.org/</a></br>
[2] go语言编程，许世伟
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TOP 10开源的推荐系统简介]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/10/top-10-open-source-recommendation-systems/"/>
    <updated>2014-03-10T22:29:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/10/top-10-open-source-recommendation-systems</id>
    <content type="html"><![CDATA[<p>最近这两年推荐系统特别火，本文搜集整理了一些比较好的开源推荐系统，即有轻量级的适用于做研究的SVDFeature、LibMF、LibFM等，也有重量级的适用于工业系统的
Mahout、Oryx、EasyRecd等，供大家参考。PS：这里的top 10仅代表个人观点。</p>


<h2>#1.SVDFeature</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031001.png"></center>


<p>主页：<a href="http://svdfeature.apexlab.org/wiki/Main_Page">http://svdfeature.apexlab.org/wiki/Main_Page</a> 语言：C++</br>
一个feature-based协同过滤和排序工具，由上海交大Apex实验室开发，代码质量较高。在KDD Cup 2012中获得第一名，KDD Cup 2011中获得第三名，相关论文
发表在2012的JMLR中，这足以说明它的高大上。</br>
SVDFeature包含一个很灵活的Matrix Factorization推荐框架，能方便的实现SVD、SVD++等方法, 是单模型推荐算法中精度最高的一种。SVDFeature代码精炼，可以用
相对较少的内存实现较大规模的单机版矩阵分解运算。另外含有Logistic regression的model，可以很方便的用来进行ensemble。</p>




<!--more-->




<h2>#2.LibMF</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031002.gif"></center>


<p>主页：<a href="http://www.csie.ntu.edu.tw/~cjlin/libmf/">http://www.csie.ntu.edu.tw/~cjlin/libmf/</a> 语言：C++</br>
作者<a href="http://www.csie.ntu.edu.tw/~cjlin/">Chih-Jen Lin</a>来自大名鼎鼎的台湾国立大学，他们在机器学习领域享有盛名，近年连续多届KDD Cup竞赛上均
获得优异成绩，并曾连续多年获得冠军。台湾大学的风格非常务实，业界常用的LibSVM， Liblinear等都是他们开发的，开源代码的效率和质量都非常高。</br>
LibMF在矩阵分解的并行化方面作出了很好的贡献，针对SGD（随即梯度下降）优化方法在并行计算中存在的locking problem和memory discontinuity问题，提出了一种
矩阵分解的高效算法FPSGD（Fast Parallel SGD），根据计算节点的个数来划分评分矩阵block，并分配计算节点。系统介绍可以见这篇
<a href="http://www.csie.ntu.edu.tw/~cjlin/papers/libmf.pdf">论文</a>（ACM Recsys 2013的 Best paper Award）。</p>




<h2>#3.LibFM</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031003.jpg"></center>


<p>主页：<a href="http://www.libfm.org/">http://www.libfm.org/</a> 语言：C++</br>
作者是德国Konstanz大学的Steffen Rendle，他用LibFM同时玩转KDD Cup 2012 Track1和Track2两个子竞赛单元，都取得了很好的成绩，说明LibFM是非常管用的利器。</br>
LibFM是专门用于矩阵分解的利器，尤其是其中实现了MCMC（Markov Chain Monte Carlo）优化算法，比常见的SGD优化方法精度要高，但运算速度要慢一些。当然LibFM中还
实现了SGD、SGDA（Adaptive SGD）、ALS（Alternating Least Squares）等算法。</p>




<h2>#4.Lenskit</h2>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031004.png"></center>


<p>主页：<a href="http://lenskit.grouplens.org/">http://lenskit.grouplens.org/</a> 语言Java</br>
<p>这个Java开发的开源推荐系统，来自美国的明尼苏达大学的GroupLens团队，也是推荐领域知名的测试数据集Movielens的作者。</br>
该源码托管在GitHub上，<a href="https://github.com/grouplens/lenskit">https://github.com/grouplens/lenskit</a>。主要包含lenskit-api,lenskit-core,
lenskit-knn,lenskit-svd,lenskit-slopone,lenskit-parent,lenskit-data-structures,lenskit-eval,lenskit-test等模块，主要实现了k-NN，SVD，Slope-One等
典型的推荐系统算法。</p>

<h2>#5.GraphLab</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031005.png"></center>
<p>主页：<a href="http://docs.graphlab.org/collaborative_filtering.html">GraphLab - Collaborative Filtering</a> 语言：C++</br>
Graphlab是基于C++开发的一个高性能分布式graph处理挖掘系统，特点是对迭代的并行计算处理能力强（这方面是hadoop的弱项），由于功能独到，GraphLab在业界名声很响。
用GraphLab来进行大数据量的random walk或graph-based的推荐算法非常有效。Graphlab虽然名气比较响亮（CMU开发），但是对一般数据量的应用来说可能还用不上。</br>
GraphLab主要实现了ALS，CCD++，SGD，Bias-SGD，SVD++，Weighted-ALS，Sparse-ALS，Non-negative Matrix Factorization，Restarted Lanczos Algorithm等算法。</p>

<h2>#6.Mahout</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031006.png"></center>
<p>主页：<a href="http://mahout.apache.org/">http://mahout.apache.org/</a> 语言：Java</br>
Mahout 是 Apache Software Foundation (ASF) 开发的一个全新的开源项目，其主要目标是创建一些可伸缩的机器学习算法，供开发人员在 Apache 在许可下免费
使用。Mahout项目是由 Apache Lucene社区中对机器学习感兴趣的一些成员发起的，他们希望建立一个可靠、文档翔实、可伸缩的项目，在其中实现一些常见的用于
聚类和分类的机器学习算法。该社区最初基于 Ngetal. 的文章 “Map-Reduce for Machine Learning on Multicore”，但此后在发展中又并入了更多广泛的机器学习
方法，包括Collaborative Filtering（CF），Dimensionality Reduction，Topic Models等。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。</br>
在Mahout的Recommendation类算法中，主要有User-Based CF，Item-Based CF，ALS，ALS on Implicit Feedback，Weighted MF，SVD++，Parallel SGD等。</p>

<h2>#7.Myrrix</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031007.png"></center>
<p>主页：<a href="http://myrrix.com/">http://myrrix.com/</a> 语言：Java</br>
Myrrix最初是Mahout的作者之一Sean Owen基于Mahout开发的一个试验性质的推荐系统。目前Myrrix已经是一个完整的、实时的、可扩展的集群和推荐系统，主要
架构分为两部分：服务层：在线服务，响应请求、数据读入、提供实时推荐；计算层：用于分布式离线计算，在后台使用分布式机器学习算法为服务层更新机器学习
模型。Myrrix使用这两个层构建了一个完整的推荐系统，服务层是一个HTTP服务器，能够接收更新，并在毫秒级别内计算出更新结果。服务层可以单独使用，无需
计算层，它会在本地运行机器学习算法。计算层也可以单独使用，其本质是一系列的Hadoop jobs。目前Myrrix以被 Cloudera 并入Oryx项目。</p>

<h2>#8.EasyRec</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031008.png"></center>
<p>主页：<a href="http://easyrec.org/">http://easyrec.org/</a> 语言：Java</br>
EasyRec是一个易集成、易扩展、功能强大且具有可视化管理的推荐系统，更像一个完整的推荐产品，包括了数据录入模块、管理模块、推荐挖掘、离线分析等。
EasyRec可以同时给多个不同的网站提供推荐服务，通过tenant来区分不同的网站。架设EasyRec服务器，为网站申请tenant，通过tenant就可以很方便的集成到
网站中。通过各种不同的数据收集（view,buy.rating）API收集到网站的用户行为，EasyRec通过离线分析，就可以产生推荐信息，您的网站就可以通过
Recommendations和Community Rankings来进行推荐业务的实现。</p>

<h2>#9.Waffles</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031009.png"></center>
<p>主页：<a href="http://waffles.sourceforge.net/">http://waffles.sourceforge.net/</a> 语言：C++</br>
Waffles英文原意是蜂蜜甜饼，在这里却指代一个非常强大的机器学习的开源工具包。Waffles里包含的算法特别多，涉及机器学习的方方面面，推荐系统位于
其中的Waffles_recommend tool，大概只占整个Waffles的1/10的内容，其它还有分类、聚类、采样、降维、数据可视化、音频处理等许许多多工具包，估计
能与之媲美的也就数Weka了。</p>

<h2>#10.RapidMiner</h2>
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014031010.png"></center>
<p>主页：<a href="http://rapidminer.com/">http://rapidminer.com/</a> 语言：Java</br>
RapidMiner（前身是Yale）是一个比较成熟的数据挖掘解决方案，包括常见的机器学习、NLP、推荐、预测等方法（推荐只占其中很小一部分），而且带有GUI的
数据分析环境，数据ETL、预处理、可视化、评估、部署等整套系统都有。另外RapidMiner提供commercial license，提供R语言接口，感觉在向着一个商用的
数据挖掘公司的方向在前进。</br>
======================================分割线======================================</p>

<p>开源的推荐系统大大小小的还有很多，以上只是介绍了一些在学术界和工业界比较流行的TOP 10，而且基本上都是用C++/Java实现的，在参考资料[1]、[2]中还提
到的有Crab（Python）、CofiRank（C++）、MyMediaLite（.NET/C#）、PREA（Java）、Python-recsys（Python）、Recommendable（Ruby）、Recommenderlab（R）、
Oryx（Java）、recommendify（Ruby）、RecDB（SQL）等等，当然GitHub上还有更多。。。即有适合单机运行的，也有适合集群的。虽然使用的编程语言不同，但实现
的算法都大同小异，主要是SVD、SGD、ALS、MF、CF及其改进算法等。</p>

<h2>参考资料</h2>
<p>[1]<a href="http://blog.csdn.net/cserchen/article/details/14231153">推荐系统开源软件列表汇总和点评</a></br>
[2]<a href="http://www.oschina.net/search?scope=project&tag1=0&tag2=0&lang=0&os=0&q=%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F">开源中国社区 - 搜索：推荐系统</a>
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Koding——一个惊艳的在线编程开发平台]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/01/koding-an-amazing-online-development-environment/"/>
    <updated>2014-03-01T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/01/koding-an-amazing-online-development-environment</id>
    <content type="html"><![CDATA[<p>最近在v2ex上发现了一个非常酷的云编程发开平台——Koding，与大家分享一下，主要介绍一下它的基本功能和操作。</p>


<h2>What is Koding?</h2>


<p>Koding是一个在线的编程开发平台，致力于简化全球化的合作项目开发，并为每个人提供免费计算和开发资源。它已不仅仅是一个在线的编辑器那么简单，
而是通过提供免费的虚拟机（vm），上面安装了ubuntu操作系统，有真实的终端，允许开发者进行go、nodejs、ruby、python、php、js、C/C++等语言的开发，
可以安装各种工具和应用，。更主要的是，它是完全在线的，可以从世界上的任何地方访问，只需要一个浏览器。不仅如此，他还具有完美的社交功能，
可以和团队成员在线协作。</p>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014030101.png"></center>


<!--more-->




<h2>Activity Feed</h2>


<p>在Koding的<a href="https://koding.com/Activity">Activity面板</a>，是用户间交流的媒介，在这里可以看到一系列的状态更新、代码片段或用户动态。在这里你可以
创建主题，参与某些主题的讨论，可以关注他人，基本的社交功能都一应俱全。</p>




<h2>Development on Koding</h2>


<p>这是Koding的主体部分。在这里你可以像在本地计算机进行开发一样，当然这个可以在线操作，可以实现云同步，随时随地都可以访问，有木有很高大上？
在这里你可以导入自己的GitHub项目，在浏览器中进行项目开发，可以向GitHub push你的项目更新。这里有在线终端，有在线文本编辑器，还有内置浏览器。
除了和在本地编程开发一样的功能以外，还可以自行配置和添加vm，设置自己的独立域名等。下面我们来看看vm的一些硬件参数，主要是cpu、内存、硬盘、网络等。</p>


<p>硬件信息概要，要加sudo使用根权限并输入密码，不加short参数可以查看详细信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ sudo lshw -short 
</span><span class='line'>[sudo] password for ibillxia:         
</span><span class='line'>H/W path    Device   Class      Description
</span><span class='line'>===========================================
</span><span class='line'>                     system     Computer
</span><span class='line'>/0                   bus        Motherboard
</span><span class='line'>/0/0                 memory     15GiB System memory
</span><span class='line'>/0/1                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/2                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/3                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/4                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/5                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/6                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/7                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/8                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>/0/100               bridge     440FX - 82441FX PMC [Natoma]
</span><span class='line'>/0/100/1             bridge     82371SB PIIX3 ISA [Natoma/Triton II]
</span><span class='line'>/0/100/1.1           storage    82371SB PIIX3 IDE [Natoma/Triton II]
</span><span class='line'>/0/100/1.2           bus        82371SB PIIX3 USB [Natoma/Triton II]
</span><span class='line'>/0/100/1.3           bridge     82371AB/EB/MB PIIX4 ACPI
</span><span class='line'>/0/100/2             display    GD 5446
</span><span class='line'>/0/100/3             network    Virtio network device
</span><span class='line'>/0/100/4             storage    Virtio block device
</span><span class='line'>/0/100/5             memory     RAM memory
</span><span class='line'>/1          eth0     network    Ethernet interface
</span><span class='line'>/2          gretap0  network    Ethernet interface</span></code></pre></td></tr></table></div></figure>


<p>查看cpu信息，E5-2630 8核2.30GHz，本文只摘取第1个核的信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ cat /proc/cpuinfo 
</span><span class='line'>processor       : 0
</span><span class='line'>vendor_id       : GenuineIntel
</span><span class='line'>cpu family      : 6
</span><span class='line'>model           : 45
</span><span class='line'>model name      : Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
</span><span class='line'>stepping        : 7
</span><span class='line'>microcode       : 0x1
</span><span class='line'>cpu MHz         : 2299.998
</span><span class='line'>cache size      : 4096 KB
</span><span class='line'>physical id     : 0
</span><span class='line'>siblings        : 1
</span><span class='line'>core id         : 0
</span><span class='line'>cpu cores       : 1
</span><span class='line'>apicid          : 0
</span><span class='line'>initial apicid  : 0
</span><span class='line'>fpu             : yes
</span><span class='line'>fpu_exception   : yes
</span><span class='line'>cpuid level     : 13
</span><span class='line'>wp              : yes
</span><span class='line'>flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt aes xsave avx hyperv
</span><span class='line'>isor lahf_lm xsaveopt
</span><span class='line'>bogomips        : 4599.99
</span><span class='line'>clflush size    : 64
</span><span class='line'>cache_alignment : 64
</span><span class='line'>address sizes   : 40 bits physical, 48 bits virtual
</span><span class='line'>power management:</span></code></pre></td></tr></table></div></figure>


<p>查看内存信息，共16GB内存</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ cat /proc/meminfo                                                                                                                                                                                                                             
</span><span class='line'>MemTotal:       16433708 kB
</span><span class='line'>MemFree:         8506472 kB
</span><span class='line'>Buffers:          332884 kB
</span><span class='line'>Cached:          5334908 kB
</span><span class='line'>SwapCached:            0 kB
</span><span class='line'>Active:          3936496 kB
</span><span class='line'>Inactive:        2222980 kB
</span><span class='line'>Active(anon):    2093920 kB
</span><span class='line'>Inactive(anon):    10856 kB
</span><span class='line'>Active(file):    1842576 kB
</span><span class='line'>Inactive(file):  2212124 kB
</span><span class='line'>Unevictable:        5552 kB
</span><span class='line'>Mlocked:            5552 kB
</span><span class='line'>SwapTotal:             0 kB
</span><span class='line'>SwapFree:              0 kB
</span><span class='line'>Dirty:                 0 kB
</span><span class='line'>Writeback:             8 kB
</span><span class='line'>AnonPages:        482832 kB
</span><span class='line'>Mapped:            41668 kB
</span><span class='line'>Shmem:           1623556 kB
</span><span class='line'>Slab:            1522048 kB
</span><span class='line'>SReclaimable:    1225180 kB
</span><span class='line'>SUnreclaim:       296868 kB
</span><span class='line'>KernelStack:        6312 kB
</span><span class='line'>PageTables:        84660 kB
</span><span class='line'>NFS_Unstable:          0 kB
</span><span class='line'>Bounce:                0 kB
</span><span class='line'>WritebackTmp:          0 kB
</span><span class='line'>CommitLimit:     8216852 kB
</span><span class='line'>Committed_AS:    5225664 kB
</span><span class='line'>VmallocTotal:   34359738367 kB
</span><span class='line'>VmallocUsed:       45688 kB
</span><span class='line'>VmallocChunk:   34359561000 kB
</span><span class='line'>HardwareCorrupted:     0 kB
</span><span class='line'>AnonHugePages:     18432 kB
</span><span class='line'>HugePages_Total:       0
</span><span class='line'>HugePages_Free:        0
</span><span class='line'>HugePages_Rsvd:        0
</span><span class='line'>HugePages_Surp:        0
</span><span class='line'>Hugepagesize:       2048 kB
</span><span class='line'>DirectMap4k:      245748 kB
</span><span class='line'>DirectMap2M:     7094272 kB
</span><span class='line'>DirectMap1G:     9437184 kB</span></code></pre></td></tr></table></div></figure>


<p>硬盘测速，才219kB/s，不是一般的慢啊</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ dd if=/dev/zero of=test bs=64k count=2k oflag=dsync
</span><span class='line'>2048+0 records in
</span><span class='line'>2048+0 records out
</span><span class='line'>134217728 bytes (134 MB) copied, 612.942 s, 219 kB/s</span></code></pre></td></tr></table></div></figure>


<p>网速测试，一般般</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ ping www.github.com  # 测试1
</span><span class='line'>PING github.com (192.30.252.129) 56(84) bytes of data.
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=1 ttl=54 time=73.2 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=2 ttl=54 time=75.9 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=3 ttl=54 time=72.4 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=4 ttl=54 time=72.3 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=5 ttl=54 time=66.2 ms
</span><span class='line'>64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=6 ttl=54 time=66.1 ms
</span><span class='line'>^C
</span><span class='line'>--- github.com ping statistics ---
</span><span class='line'>6 packets transmitted, 6 received, 0% packet loss, time 5001ms
</span><span class='line'>rtt min/avg/max/mdev = 66.117/71.077/75.947/3.656 ms
</span><span class='line'>ibillxia@vm-0:~$ ping www.stackoverflow.com    # 测试2
</span><span class='line'>PING stackoverflow.com (198.252.206.140) 56(84) bytes of data.
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=1 ttl=49 time=76.1 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=2 ttl=49 time=88.4 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=3 ttl=49 time=75.1 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=4 ttl=49 time=75.1 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=5 ttl=49 time=75.3 ms
</span><span class='line'>64 bytes from stackoverflow.com (198.252.206.140): icmp_req=6 ttl=49 time=82.6 ms
</span><span class='line'>^C
</span><span class='line'>--- stackoverflow.com ping statistics ---
</span><span class='line'>6 packets transmitted, 6 received, 0% packet loss, time 5005ms
</span><span class='line'>rtt min/avg/max/mdev = 75.130/78.813/88.437/5.061 ms
</span><span class='line'>ibillxia@vm-0:~$ ping www.facebook.com     # 测试3
</span><span class='line'>PING star.c10r.facebook.com (31.13.77.81) 56(84) bytes of data.
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=1 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=2 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=3 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=4 ttl=81 time=153 ms
</span><span class='line'>64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=5 ttl=81 time=153 ms
</span><span class='line'>^C
</span><span class='line'>--- star.c10r.facebook.com ping statistics ---
</span><span class='line'>6 packets transmitted, 5 received, 16% packet loss, time 5006ms
</span><span class='line'>rtt min/avg/max/mdev = 153.577/153.740/153.951/0.449 ms</span></code></pre></td></tr></table></div></figure>




<p>再来看看一些系统和软件信息。</p>


<p>查看linux内核版本、系统体系结构及预安装软件版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ uname -a 
</span><span class='line'>Linux vm-0.ibillxia.koding.kd.io 3.13.0-5-generic #20 SMP Mon Jan 20 19:56:12 PST 2014 x86_64 x86_64 x86_64 GNU/Linux
</span><span class='line'>ibillxia@vm-0:~$ git --version
</span><span class='line'>git version 1.8.1.2
</span><span class='line'>ibillxia@vm-0:~$ mysql --version
</span><span class='line'>mysql  Ver 14.14 Distrib 5.5.32, for debian-linux-gnu (x86_64) using readline 6.2
</span><span class='line'>ibillxia@vm-0:~$ apache2 -v
</span><span class='line'>Server version: Apache/2.2.22 (Ubuntu)
</span><span class='line'>Server built:   Jul 12 2013 13:18:14</span></code></pre></td></tr></table></div></figure>


<p>常用编程语言版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ibillxia@vm-0:~$ gcc --version
</span><span class='line'>gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
</span><span class='line'>Copyright (C) 2012 Free Software Foundation, Inc.
</span><span class='line'>This is free software; see the source for copying conditions.  There is NO
</span><span class='line'>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</span><span class='line'>
</span><span class='line'>ibillxia@vm-0:~$ g++ --version
</span><span class='line'>g++ (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
</span><span class='line'>Copyright (C) 2012 Free Software Foundation, Inc.
</span><span class='line'>This is free software; see the source for copying conditions.  There is NO
</span><span class='line'>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</span><span class='line'>
</span><span class='line'>ibillxia@vm-0:~$ java -version
</span><span class='line'>java version "1.7.0_25"
</span><span class='line'>OpenJDK Runtime Environment (IcedTea 2.3.10) (7u25-2.3.10-1ubuntu0.13.04.2)
</span><span class='line'>OpenJDK 64-Bit Server VM (build 23.7-b01, mixed mode)
</span><span class='line'>ibillxia@vm-0:~$ go version  
</span><span class='line'>go version go1.1.1 linux/amd64
</span><span class='line'>ibillxia@vm-0:~$ ruby --version
</span><span class='line'>ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
</span><span class='line'>ibillxia@vm-0:~$ php --version
</span><span class='line'>PHP 5.4.9-4ubuntu2.3 (cli) (built: Sep  4 2013 19:32:25) 
</span><span class='line'>Copyright (c) 1997-2012 The PHP Group
</span><span class='line'>Zend Engine v2.4.0, Copyright (c) 1998-2012 Zend Technologies
</span><span class='line'>ibillxia@vm-0:~$ python --version                                                                                                                                                                                                                                     
</span><span class='line'>Python 2.7.4
</span><span class='line'>ibillxia@vm-0:~$ perl --version
</span><span class='line'> 
</span><span class='line'>This is perl 5, version 14, subversion 2 (v5.14.2) built for x86_64-linux-gnu-thread-multi
</span><span class='line'>(with 80 registered patches, see perl -V for more detail)
</span><span class='line'> 
</span><span class='line'>Copyright 1987-2011, Larry Wall
</span><span class='line'> 
</span><span class='line'>Perl may be copied only under the terms of either the Artistic License or the
</span><span class='line'>GNU General Public License, which may be found in the Perl 5 source kit.
</span><span class='line'> 
</span><span class='line'>Complete documentation for Perl, including FAQ lists, should be found on
</span><span class='line'>this system using "man perl" or "perldoc perl".  If you have access to the
</span><span class='line'>Internet, point your browser at http://www.perl.org/, the Perl Home Page.</span></code></pre></td></tr></table></div></figure>




<h2>Installing and Using KDApps</h2>


<p>除了系统已安装的基本应用外，用户还可以在<a href="https://koding.com/Apps">Koding/Apps</a>上选择一些官方的apps安装到自己的vm上。可以
在线绘图、编辑照片等等。</p>




<h2>Online Teamwork</h2>


<p>Koding还具有团退协作功能，你可以创建自己的group或参加到别人的group中。加入到一个team后，系统会分配你一个Session ID，通过这个ID你可以进入
到队友的vm当中，然后你们相互之间都可以看到对方的编码动态。</p>




<p>关于Koding的更多内容，请戳<a href="http://learn.koding.com/getting-started/">Learn Koding</a>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[互联网引发的制造业革命——读《创客》]]></title>
    <link href="http://ibillxia.github.io/blog/2014/02/23/makers-the-new-industrial-evolution/"/>
    <updated>2014-02-23T22:07:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/02/23/makers-the-new-industrial-evolution</id>
    <content type="html"><![CDATA[<p>其实很早之前就买了这本书，是在13年6月份和『看见』、『黑客与画家』等一起买的吧，看完这两本书后也就开始看『创客』了，
但都是断断续续的看，没有花比较集中的时间，而且感觉前面几章将的内容没有那么大的吸引力。后来双11做活动，又买了10来本书，
其中有雷军、周鸿祎等IT大佬的传记，还有几本成功励志类、文学类的书，就又跳着去看这些书了。开学初闲着无聊就又拿起这本书
来看了，看到了第二部分后，才发现原来这本书是如此之好，特别是开源硬件、众筹、云工厂等新兴工业和商业模式，让人印象深刻。</p>




<h2>作者&内容简介</h2>


<p>这本书的作者是克里斯•安德森，一个很多人耳熟能详的名字。现任『连线』杂志主编，是3D Robotics和DIY Drones的联合创始人，
也是『纽约时报』畅销书『长尾理论』及『免费：商业的未来』的作者。</p>


<center><img src="http://ibillxia.github.io/images/2014/IMAG2014022301.jpg"></center>


<p>『创客：新工业革命』一书以独特的视角分析了传统的制造业在汹涌澎湃的互联网浪潮中发生的翻天覆地的变化。在互联网这个广阔媒介的
笼罩下，每个人都可以分享自己的idea、设计方案和产品原型，也可以评论和完善他人的idea、方案和产品，每个人都可以DIY，都可以自己动手
创造出新的东西。只要你敢想敢做，nothing is impossible！在长尾效应无法避免的情况下，每个人都可以设计个性化的产品，解决个性化的
问题，新发明不断涌现。3D打印的兴起，使得新产品的制造更加模块化，更加便捷。硬件设计的开源，又加剧了产品的分化和个性化，也使得其
更新换代和性能提升更快。云工厂又使得发明者可以不用白手起家建立加工厂，从而更加便捷的将自己的设计付诸实践。而众筹这种新的集资模式
又解决了发明者自尽缺乏的后顾之忧，而且提前为之提供了市场需求情况。所有的这些因素，使得制造业空前的繁荣，一场新的工业革命正在萌发。</p>


<!--more-->




<h2>长尾效应&DIY&发明革命</h2>


<p>长尾（The Long Tail），或译长尾效应，最初由克里斯·安德森（Chris Anderson）于2004年发表于自家的<a href="http://www.wired.com/wired/archive/12.10/tail.html">杂志</a>，
用来描述诸如亚马逊公司、Netflix和Real.com/Rhapsody之类的网站之商业和经济模式。是指那些不受到重视的、销量小但种类多的产品或服务
由于总量巨大，累积起来的总收益超过主流产品的现象。下图中纵轴为“人气”，横轴为“产品”，黄色部分即为长尾。
<center><img src="http://ibillxia.github.io/images/2014/IMAG2014022302.png"></center>
在互联网领域，长尾效应尤为显著。比如亚马逊上的书籍的销售情况，<a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=400940">Erik</a>等
用指数曲线研究了亚马逊网站的书本销售量和销售排名的关系，并发现亚马逊40%的书本销售来自于**本地书店里不卖**的书本。在亚马逊这个案例上，
可应用“长尾”概念解释：它一半左右的销售来自于比较热门的商品，而另一半却来自相对不那么热门的商品。这跟传统
的“<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%AB%E5%AE%9A%E5%BE%8B">二八定律</a>”完全相反。这使得我们可以逆向的思考，不再紧盯着
那20%的大众化产品，而去关注后80%的“长尾巴”，同样也可以很有前途。</p>


<p>在小众产品市场中，DIY（即do it yourself）可谓独树一帜，占据着举足轻重的地位。在这个充满个性化的时代里，个性就是时尚，独一无二
永远是时尚一族的追求。虽然DIY已经有半个多世纪的历史，但在如今的互联网环境下，DIY更是发挥到了极致：DIY电脑、音箱、手机，DIY网站、个人博客，
DIY首饰、工艺品，DIY家具、房屋，DIY台历、杯子、布偶、玩具。。。可以自己设计个性化的服装图案，可以自己组装各种硬件设备。书中作者
的外公DIY了自家的garden的灌溉系统，使之自动化甚至可以远程遥控，并将系统申请了专利。书中还有对玩具DIY、对乐高机器人DIY的例子。</p>


<p>互联网的存在，使得DIY的产品无论从数量还是质量上，都产生了很大的飞跃，很多新的设计方法和实现方式都具有申请专利或发明的资质，
每个人都可以成为名副其实的发明家，只要你敢于发现、敢于创造。互联网的资源与idea分享的开放环境，使得发明创造的空间急剧膨胀，而时间逐渐
缩短，各种新技术不断涌现，创业的浪潮居高不下，创业和发明甚至已成为一种时尚。</p>




<h2>3D打印&开源软硬件</h2>


<p>最近两年3D打印还挺火的，只需要向3D打印机输入三维的设计模型，即可打印出一个三维的产品。随着技术的更新、新材料的研制，3D打印机能够
制作的东西越来越多、越来越复杂，各种小型的装饰品、日用品、玩具模型等，都是小case，在不远的未来连汽车都可以打印了，多么神奇！3D打印的
兴起，使得产品的设计者们只需要使用CAD软件，对产品进行三维建模，然后将数字化的模型输入到打印机，即可得到成型的产品，不用另外话时间去
组装。对产品进行改进，只需要在CAD软件中对模型设计进行修改和优化，产品的生产周期大大压缩。</p>


<p>在书中，作者将开源硬件单独设立了一张，篇幅还不小。现如今，硬件电路都可以用计算机代码（如硬件描述语言VHDL等）和图文来描述和设计，
硬件的设计方案都数字化、信息化了，开源出它的设计方案在互联网上，人们可以随意对其进行添加新模块或删改或组合，形成新的硬件，实现新的
应用场景。书中提到的比较典型的开源硬件要数Arduino了，这是包含很多常见功能模块的硬件开发板，有很多可自选的组件（甚至可以和智能手机互联），
可以编程，从而可以实现各种很酷的功能，比如爬行机器人、小飞行器、智能垃圾桶、音乐魔方等等，比如Arduino中文社区中展示的一个非常酷的
<a href="http://www.arduino.cn/article-3-1.html">万向轴语音机器人</a>。</p>




<h2>云工厂&众筹</h2>


<p>也许我们要DIY的产品还无法用3D打印机来制造，也许我们要hack的东西也不是通过现成的开源软硬件就能实现，现在我们不用担心这些了，因为
现在的互联网可谓无所不能，我们可以通过云工厂来为我们生产定制的产品。互联网的存在，使得我们不用亲临工厂，在网络上就可以寻找合适的代
工厂，无论它在国内还是海外。网上开店开工厂，早已不是什么新鲜事了。早在90年代末，互联网才刚刚兴起的时候，本书的作者就认识了当今中国
网上商城的大佬——马云，当时马云就开始将各种公司信息搬到网上。而现如今，很多网上商城不仅可以提供现成的产品，而且可以接受私人定制的产
品。</p>


<p>也许我们没有资金来购买昂贵原材料，也许我们没有能力去做产品的市场调查，因为现在我们有了众筹这种新的互联网集资模式。众筹的思路是，
发明者在网络上发布自己的产品方案和原型，寻求需要该产品的网友的支持，无论是对你进行资金支持，还是对你进行精神鼓励。有需求者还可以提前
以优惠的价格预定，提前支付。现在网上这样的众筹平台已经有很多了，作者在书中提到了Kickstarter等，国内有点名时间(demotime)等等，上面有
很多很有意思的项目，大家可以去看看。在众筹平台上，创意的发布者需要提供产品的方案及可行性，需要筹集的资金量，以及筹集周期，然后让网友
来投票，提供意见，预定产品。如果在筹集结束前能够达到预定的金额，那么就可以顺利进入实质生产阶段了。人们不用再去寻找非常困难而且风险
很大的贷款或风险投资。</p>


<p>有了云工厂和众筹这些完美的平台，创意的实现可谓零门槛，所有你需要做的就是展开思维的翅膀，在生活中去发现、去创造。</p>




<h2>未来</h2>


<p>互联网的普及，新技术、新思维的不断涌现，互联网正在对传统制造业产生巨大的冲击，特别是处于80%的长尾部分的传统制造业。“创客运动”的
天平偏向于最佳创新模式，而非最廉价的劳动力，人才与创新对企业的发展越来越重要，制造业正在发生深刻的变革，未来充满着机遇和挑战！Are you READY？！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如果长颈鹿哭了，它会不会要哽咽好久]]></title>
    <link href="http://ibillxia.github.io/blog/2013/12/24/if-giraffe-cried-would-it-choking-so-long/"/>
    <updated>2013-12-24T19:29:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/12/24/if-giraffe-cried-would-it-choking-so-long</id>
    <content type="html"><![CDATA[<p>一篇很唯美的文章，来自豆瓣相册：<a href="http://www.douban.com/photos/album/63673280/?start=0">如果长颈鹿哭了，它会不会要哽咽好久</a>，有微小删改。<br/>
在酷我调频的莫萱日记“<a href="http://www.kuwo.cn/yinyue/3619660/">关于我爱你这件小事</a>”这一期中听到的，分享给大家，顺祝大家圣诞快乐！</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122401.jpg"></center>


<p>长颈鹿的脖子那么长 哽咽的时候是不是很难受<br/>
我没有长长的脖子 却哽咽的说不出话<br/>
章鱼有三颗心脏 心痛的时候是不是很疼<br/>
我没有三颗心脏 体会不到无法忍受的痛再多三倍<br/>
乌鸦可以学人说话 尴尬的时候会不会装咳嗽<br/>
我假装咳嗽 假装被沙子迷了眼 你也没有看我一眼<br/>
骆驼有长长的睫毛 想哭的时候能不能说眼睛进了沙<br/>
我假装咳嗽 假装被沙子迷了眼 你也没有看我一眼<br/>
蛇没有宽宽的肩膀 她累的时候给不了能够依靠的温暖<br/>
是因为我太弱小 没有很可靠的肩膀么<br/>
小强有两个大脑 孤单的时候会不会一起想着谁<br/>
无时无刻的清澈的想念 一定比两个大脑一起想你还多吧<br/>
蜉蝣只能活很短 可能一辈子都来不及和心里珍藏的那个人说一些想说的话<br/>
我又能活多久 时间会不会给我可以开口的勇气<br/>
把人生看做是自己独一无二的创作 便不会频频回首<br/>
你会不会忽然地出现 在旧时光的风景里 成为珍藏一生的美丽</p>

<!--more-->




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122402.jpg"></center>


<p>夏天过去　你没有消息<br/>
说会再见终究我相信了你<br/>
秋天来临，我想等下去<br/>
你最爱的叶子花语是关心<br/>
咖啡色的鞋子 灰色毛衣 从以前到现在的玩具<br/>
你的表情 太没志气　说我很想你<br/>
把握太轻，却让人沉重地无法逃离<br/>
我只是觉得 这种牵挂放着无趣丢了可惜</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122403.jpg"></center>


<p>两个人一起是为了快乐，分手是为了减轻痛苦<br/>
你无法再令我快乐，我也唯有离开<br/>
我离开的时候，也很痛苦<br/>
只是，你肯定比我痛苦<br/>
因为我首先说再见，首先追求快乐的是我。<br/>
爱上一个人的时候，总会有点害怕<br/>
怕得到他，怕失掉他<br/>
有时候，我们愿意原谅一个人<br/>
并不是我们真的愿意原谅他<br/>
而是我们不想失去他<br/>
不想失去他，唯有假装原谅他<br/>
恨，也是一种爱<br/>
岁月漫长，装着装着也许真的就能够原谅与遗忘。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122404.jpg"></center>


<p>所有单向的爱情，是不是终归也会有悄然落幕的一天？<br/>
所有寂寞的影子，是不是终究走不出黑夜之后的黎明？<br/>
我爱你，可以跟你无关<br/>
可是，我希望它是跟你有关的。<br/>
单恋也是爱情吧？<br/>
只是，这种爱情与人无尤<br/>
爱你是我一个人的事<br/>
我自己回答自己，自己荣耀自己，自己呼应自己<br/>
在我悄悄单恋着的那个人身后，我多么像个寂寞的影子？<br/>
时而甜蜜，时而苦涩<br/>
那不是懦弱，那只是不被允许的爱情<br/>
于是，我只能选择沉默。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122405.jpg"></center>


<p>一段爱情，两个人成长<br/>
无论是否能够和你终老<br/>
那么投入地爱过彼此<br/>
流过那么多的眼泪，我们都长大了。<br/>
因为曾经那样喜欢一个人，<br/>
所以无法接受自己稍微不喜欢的人。</p>

<p>为什么要急着长大呢？正如你不会急着老去<br/>
总有一天，你会长大<br/>
要是可以一直不长大<br/>
不需要面对人生汹涌的波涛<br/>
不需要把棱角磨平<br/>
也是一种幸福啊！</p>

<p>我以为爱情可以克服一切<br/>
谁知道它有时毫无力量<br/>
我以为爱情可以填满人生的遗憾<br/>
然而，制造更多遗憾的，偏偏是爱情本身<br/>
阴晴圆缺，在一段爱情里不断重演<br/>
换一个人，也不会天色常蓝。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122406.jpg"></center>


<p>既然未曾拥有，又怎知道它有多好？<br/>
因为错过了<br/>
所以，当我们觉得不幸福的时候<br/>
总会为那段错过了的感情和那个错过了的人加入许多幻想和诗意<br/>
念念不忘的，不过是自己想象的画面。</p>

<p>那个长夜，漫天星宿<br/>
得睹芳容，魂摧魄折<br/>
想认识你，想爱你，想守护你<br/>
换几声欢笑，一场热泪，告别飘摇无根的生活<br/>
我不是暗影，我是归人<br/>
我，终究是爱你的</p>

<p>曾经，你苦苦以为<br/>
没有了这个人，也就活不成了<br/>
到了后来，不是活得好好的吗？<br/>
一个不爱你的人，决不会比你的生命重要<br/>
一个爱你的人，会告诉你，你的生命比你对他的爱情重要。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122407.jpg"></center>


<p>&#8220;你问我喜欢那声音不───若是现在，我一定说喜欢了。&#8221;<br/>
你说过这是你高中时最爱的新诗<br/>
岁暮总是无故想起，无由来地感动<br/>
又到岁暮了，我想把它送你<br/>
尘世的声音很多<br/>
亲人的、爱人的、知己的、幸福的、悲伤的<br/>
到后来又有哪些永留心中却或许有一天再也听不到了？<br/>
你的声音是我的天籁，会一直在我心头。</p>

<p>假如想念是一张地图<br/>
打开想念的地图<br/>
你也许会发现<br/>
不管这张地图有多么复杂<br/>
想念的起点也是终点<br/>
小孩子想念的是亲人<br/>
长大了，想念的是恋人<br/>
后来的后来，想念的对象又变成了亲人<br/>
人生最初和最后的想念几乎是一样的</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122408.jpg"></center>


<p>对男人来说<br/>
旧情人所生的女儿都是漂亮的<br/>
因为她长得像她妈妈<br/>
旧情人所生的儿子却很难看，因为他长得像他爸爸。──《想念》</p>

<p>每个人都带着童年故事和许多过去去爱上一个人<br/>
被渴求、被迁就、被照顾、被荣耀<br/>
也许都是一个过程<br/>
千回百转，直到不年轻了<br/>
才终于学会爱<br/>
却又不一定能遇到可以相爱的人<br/>
遇到了又是否可以厮守呢？无常世间没有圆满；</p>

<p>可是，幸运的话<br/>
会遇到你说的那个人<br/>
他完整了我<br/>
也是他让我看到我所有的缺失。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122409.jpg"></center>


<p>两个人最初走在一起的时候<br/>
对方为自己做一件很小的事情<br/>
我们也会感动<br/>
后来，他要做更多事情，我们才会感动<br/>
再后来，他要付出更多更多，我们才肯感动<br/>
人是多么贪婪的动物？<br/>
无论我们一生撒过多少谎<br/>
自欺终究比欺人的时候多<br/>
我对你说谎的时候<br/>
眼睛也许微笑颤抖，害怕你看出来<br/>
我对自己说谎的时候<br/>
却连眉头也不会皱一下<br/>
要面对人生种种痛苦和真相<br/>
委实太残忍了，我难道不能对自己说谎吗？<br/>
可惜，人有时还是骗不了自己<br/>
终于，我不得不苦涩地承认<br/>
你已经不爱我了。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122410.jpg"></center>


<p>他不是不爱你，也不是对你不好<br/>
他只是更爱自己，永远把自己放在第一位<br/>
他可爱的时候很可爱，自私的时候却又很自私<br/>
你恨透他的自私，心里却知道他改不了<br/>
他就是这样的一个人，天性如此<br/>
爱上一个自私的人，这样的爱是孤单还是无奈？<br/>
你终于明白，自私的人是比较快乐的<br/>
要是可以自私，那该多好。<br/>
所有处在恋爱年龄的女孩子，总是分成两派：<br/>
一派说，爱对方多一点，是幸福的；<br/>
另一派说，对方爱我多一点，才是幸福的<br/>
也许，我们都错了<br/>
爱的形式与分量从来不是设定在我们心里<br/>
你遇到一个怎样的男人<br/>
你便会谈一段怎样的恋爱。<br/>
希望有个人，在我嘴里说没事的时候，看出我不是真的没事<br/>
有个人，在我强颜欢笑的时候，知道我不是真的开心<br/>
也是这个人，在我拚了命憋住眼泪的时候<br/>
偏偏挨过来摸摸我的头，对我说：&#8221; 别哭，别哭，&#8221; <br/>
结果害我把脸埋在他身上稀哩哗啦哭得更惨，却也不会生他的气。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122411.jpg"></center>


<p>爱情是什么？不就是有个人<br/>
有些失望是不可避免的<br/>
但大部分的失望，都是因为你高估了自己<br/>
又或者是高估了你爱的那个人<br/>
无论高估的是谁，终也难免失望。<br/>
梦想有时候多么像爱情？<br/>
假若不是痴心相信，是无法坚持到底的<br/>
只是，失落了的梦想也像失落了的爱情<br/>
始于如此的兴奋与渴望，又终于如此的挫败与荒凉。<br/>
时间似乎一直在我们眼前流逝<br/>
它像无情的小鸟，拍翅高飞，永不回首<br/>
而其实，我们才是那只小小鸟，短暂勾留，倏忽飞逝<br/>
时间亘古长存，它一直都在那儿，从未飞渡<br/>
惟有我们自己与所爱的人，终会成为过去<br/>
所有的相依与相聚、所有的阴晴圆缺，也如飞似逝，永不复还。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122412.jpg"></center>


<p>爱情总是想象比现实美丽<br/>
相逢如是，告别亦如是<br/>
我们以为爱得很深很深<br/>
来日岁月，会让你知道，它不过很浅很浅<br/>
最深最重的爱，必须和时日一起成长。<br/>
“我不要你管！” <br/>
女人的这句话好像总是冲她最在乎的那个人说，<br/>
也总是言不由衷<br/>
她真正的意思也许是：<br/>
“要是你不爱我，你就别管我！”</p>

<p>想和你一起变老，<br/>
老得地老天荒，<br/>
老得这世界把我俩都忘掉了，<br/>
惟独你记得我年轻的容颜。<br/>
当所爱的人骤然离世，<br/>
那份伤痛是不会离去的，<br/>
它会沉淀、会改变你。<br/>
伤痛过后，<br/>
他会想你坚强地活下去，<br/>
想你幸福地活着。<br/>
因为他知道，<br/>
他也活在你心里，<br/>
成了你的一部分，<br/>
是你的血肉，你活得好，他才会好。<br/>
生于斯世，我们不都是旅人吗？<br/>
他不会回来了；但是，你终归会回去。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122413.jpg"></center>


<p>樱花如风转眼去，惟有拜拜是人生<br/>
曾经以为，拥有是不容易的；后来才知道，舍弃更难。<br/>
有些人，你不敢接近他，可能是因为你爱他，你害怕被拒绝，害怕受伤害<br/>
有些人，你不想接近他，是真的不想<br/>
说不上讨厌这个人，倒是很想微笑对他说：<br/>
“你走开吧你！麻烦你离我远一点。我不是傻的，我也没那么好骗。”<br/>
一天，我们不无惊讶地发现<br/>
过去所有的日子都恍若昨日<br/>
时间永远比我们以为的走得快<br/>
但是，我已经不是昨日那个年少青涩的人了<br/>
我爱过和我爱着的人<br/>
也和我一样，一点点老去<br/>
活着就是要经历这些。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122414.jpg"></center>


<p>童话故事不一定都美好，安徒生有些童话就很悲伤。<br/>
快乐王子只是子虚乌有，阿拉丁神灯不过是天方夜谭。<br/>
我们还要继续相信童话吗？<br/>
童话只属于真正的小孩而不是老小孩<br/>
可是，每个老小孩心中都有一个不朽的童话<br/>
它一直在那儿，遥远而美好，天真却也荒凉，不曾老去，从未被现实消磨。<br/>
你的那个童话又是什么<br/>
一切事物，包括感情，也有它最好的时机。<br/>
某年某天某一刻，你很想对他说：“ 我爱你 ”<br/>
可是，他脸上的神情似乎没有准备好听到这句话<br/>
一瞬间，说到唇边的话消逝了。 <br/>
以后的以后，或许再也不会说了</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122415.jpg"></center>


<p>千回百转，幸福原来一直在自己手里。<br/>
机遇降临时，努力把握；<br/>
缘分来时，好好抱住它。<br/>
再难再苦也要拍拍胸膛迎上去，<br/>
擦干眼泪，我会微笑到最后。<br/>
执子之手，红尘终老。<br/>
卑微的爱无法爱到地老天荒，它总难免会有终结的一天。<br/>
但是，战战兢兢地爱着一个人的时候，<br/>
多么像一只没有自信的丑小鸭？<br/>
害怕自己配不上对方。<br/>
直到一天，羽化成天鹅了，<br/>
也许会怀念丑小鸭的那些傻痴痴的日子<br/>
爱情是一百年的孤独，<br/>
直到遇上那个矢志不渝守护着你的人，<br/>
那一刻，<br/>
所有枯涩的孤独，<br/>
都有了归途</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122416.jpg"></center>


<p>你问：“没有爱情我们到底能不能活得很潇洒？”<br/>
人往往因为爱情而活得很不潇洒。<br/>
当你了解男人都是小孩子，<br/>
你就了解人生所有的事情<br/>
你问：“如何信任一个人呢？在有过失望之后，怎样才能好好去相信别人？”<br/>
我相信真心是会有回报的。<br/>
付出真心去相信一个人，<br/>
即使会受伤害，<br/>
那是我的劫难。<br/>
我也无愧了</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122417.jpg"></center>


<p>年轻就是会高估了爱情的寿命<br/>
年轻就是不懂说不<br/>
年轻就是会为了讨好你爱的那个人而扭曲自己<br/>
年轻就是会错爱<br/>
年轻就是会相信谎言<br/>
年轻就是会天真到笨<br/>
江湖老了每一个曾经青涩的少年，<br/>
江湖也老了每一个爱做梦的少女。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122418.jpg"></center>


<p>爱情终究是两厢情愿的事，你留不住一个不爱你的人；<br/>
你也不会愿意留住一个已经不爱你、只是可怜你的人<br/>
有这样的日子,还没起床,就知道今天会非常想念你；<br/>
也有这样的日子,一直忙到半夜,才惊觉一整天连一秒都没有想过你。<br/>
这都是由不得我的事,<br/>
在清晨并没有人会预报给我听:<br/>
今天到底下哪一种雨,飘哪一朵云。<br/>
这只是我每天要经历的,我一个人的小天气。</p>

<center><img src="http://ibillxia.github.io/images/2013/IMAG2013122419.jpg"></center>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[36氪开放日杭州站回顾与总结]]></title>
    <link href="http://ibillxia.github.io/blog/2013/11/11/36kr-open-day-hangzhou-station-review-and-summary/"/>
    <updated>2013-11-11T19:10:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/11/11/36kr-open-day-hangzhou-station-review-and-summary</id>
    <content type="html"><![CDATA[<p>11月10日，36氪开放日第二次来到杭州站，首次进入大学，进行互联网行业创业和投资的机遇、观点和经验分享。这次开放日主要包含三个部分：</br>
（1）成功创业者/投资者的主题分享；</br>
（2）初创团队的产品发布与展示；</br>
（3）观众参与: 10位观众每人1分钟demo展示。</br>
本文回顾并总结一下这次活动的主要观点。</p>




<center><img src="http://ibillxia.github.io/images/2013/IMAG2013111101.jpg"></center>




<p>主题分享的特邀嘉宾有来自阿里的副总裁纪纲，来自阿米巴的资本合伙人、挖财董事长李治国，来自丁香园的CTO、微信「小道消息」作者冯大辉@Fenng，
毕业于浙大的个推创始人方毅@方毅_个推，来自网易杭研院的产品经理、目前负责易信的章行，来自Nokia的体验创新中心总经理傅蕾。</p>


<p>初创团队的产品展示有7个，分别是——金亦冶-Kivvi收银平板：时尚店主的POS收银机，徐文俊-找大巴：首创BO2O大巴招投标预订直销模式、大巴预订神器，何翱翔-九漫：交互式动态漫画，
袁一伦-要出发旅行：主打周边自驾游，李军-微洽：面向企业的社交化工作平台，胡笃晟-阿姨厨房：为厨艺爱好者提供在家创业、P2P模式的餐饮服务电子商务平台，凌曙-同船渡：位置景点
创建和结伴出游的旅行产品。</p>




<!--more-->




<p>而现场观众的1分钟demo部分，有14 位观众带着他们的产品或者idea来跟大家分享：画吧、快读、37 度、比比、氢学习、Omygod、Tipix—照片编辑App、配配、
微信公众账号杭电助手、车纷享、穿戴式智能设备、享赢棋牌联盟、爱扫货、微博书等。</p>




<h2>特邀嘉宾的主题分享</h2>


<p>主题分享有6个，在正式分享开始之前，『36氪联合创始人·主编（第二帅[偷笑]）王壮@truant 分享 1.创业公司的理想和坚持：传递正能量 ，帮助创业者，“我们是不收车马费的媒体人”；
2.大学生互联网行业的就业：一要开阔视野，培养兴趣点；二要有展现自己能力的作品，掌握独特技能。』（<a href="http://e.weibo.com/2863376813/Ai52PFTkN">微博</a>）感到比较吃惊的
是36kr的创业团队都是88后的，而且能够做得如此之好。分享的第二点也很有启发意义，既要有开阔的视野又要掌握独特技能，寻找自己的兴趣和特长、培养独特的技能是重中之重。</p>




<p>第一个主题分享是阿里副总裁纪纲的分享。『嘉宾分享之 阿里巴巴集团副总裁纪纲：首先是对战略投资的理解——公司业务先遣队，而VC和创业者关系也同样很重要。他强调了生态圈的概念：互联网是
生机勃勃的生态；纪纲谈到值得关注的两个方向：垂直性入口、软硬件结合。初创团队基因很重要，更要关注解决问题和寻找机会的平衡。』（<a href="http://e.weibo.com/2863376813/Ai5a3DfMh">微博</a>）
我个人也总结了3点：『1.阿里的收购观点分享；2.移动互联网创业潮已过，但真正的浪潮还没到来；3.移动互联网的机会还很多，垂直入口还有希望。』（<a href="http://weibo.com/2704795533/Ai5cz2iCF">微博</a>）
对于创业者而言，垂直性入口和软硬件结合这两个方向确实还有很多机遇。</p>




<p>第二个主题分享来自阿米巴的资本合伙人李治国。『嘉宾分享之 阿米巴资本合伙人、挖财董事长李治国：投资和融资经验。投资不仅要有眼光，而且要有运气。当今时代，投资的心态也需转变。
被投资的团队要有承载资金的能力，双方需判断方向和坚持方向；有些时候做事情只要赌对了方向，刚性需求+好的团队就等于成功的一半。』（<a href="http://e.weibo.com/2863376813/Ai5iLvRkg">微博</a>）
主要是投资方面的观点分享：『判断和经验很重要，坚持也很重要！』（<a href="http://weibo.com/2704795533/Ai5f8kdb2">微博</a>），『赌对方向+nb团队。投过@蘑菇街 和@快的打车』
（<a href="http://weibo.com/2704795533/Ai5ixheZx">微博</a>）。</p>




<p>第三个主题分享来自个推的 @方毅_个推。『嘉宾分享之 个推创始总经理方毅：要变，还得是绝活——如何在业务迁移中保持竞争力？快到极致，爽到极致，“帅”到极致。[威武]』
（<a href="http://e.weibo.com/2863376813/Ai5Jqdcff">微博</a>）。@北隐_BEIYIN的这个总结也不错：『方总@方毅_个推 在做分享“要变还得有绝活”，满口的“苦逼”“屌丝”
“让你爽到极致”“生理反应”“就要给你想要的”…哈哈哈哈[哈哈][哈哈] 不过话糙理直 ①学会在夹缝中生存发展 ②能够把握住深层次的需求痛点 “我们就是为了方总来的” [围观][围观]』
（<a href="http://weibo.com/3410997984/Ai5JJ4AfO">微博</a>）上次在一个创业圆桌分享会上见识过了方总，这次方师兄从自己苦逼的创业历程讲如何在业务迁移中保持竞争力，
要变，还要是绝活！给挣扎在创业道路上同样苦逼奋斗的年轻创业者们一个很好的警示。
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013111102.jpg"></center>
</p>




<p>第四个分享来自Nokia的体验创新中心总经理傅蕾。『嘉宾分享之 诺基亚体验创新中心总经理傅蕾从NEIC的愿景、职能、工作模式、资源、最新进展和动态六个方面讲述
了NEIC如何帮助创业者、开发者开发Windows Phone 平台APP，提出了“3000+300+30”的目标，和“体验创新-扶持-成长-产出”的工作模式。』（<a href="http://e.weibo.com/2863376813/Ai5UHkUO8">微博</a>）。
主要介绍了Nokia的体验创新中心的一些目标和愿望，这种亡羊补牢，为时晚矣？ 还是为时未晚？拭目以待~
</p>




<p>第五个分享来自网易杭研院的产品经理、目前负责易信的章行。『嘉宾分享之 网易杭州研究院产品经理章行：移动IM社交思考。什么是社交？社交的本质——人与人的“资源”交换。
章行认为，中国人没社交，只有消遣，是移动网络降低了交换成本；而在IM下的SNS永远只是补充。社交产品的核心任务是建立健康长久的用户关系链；团队需要取得多方面平衡。[害羞]』
（<a href="http://e.weibo.com/2863376813/Ai6oppHi1">微博</a>）。很有理性很有深度的一个分享，相比于来往没节操的广告，易信还是比较脚踏实地的在做。
</p>




<p>第六个分享来自丁香园的CTO、微信「小道消息」作者冯大辉@Fenng。『嘉宾分享之 丁香园网站CTO冯大辉：问题与痛点。1.找到用户的问题：了解用户困境、理解用户行为、
理解商业逻辑；以用户思维分析问题、以互联网思维解决问题，未必需要技术。2. 用户的痛点：痛点是用户解决不了的问题、承受不了的成本、麻烦快要死的事，更可能不存在。
“发现比想更重要”。』（<a href="http://e.weibo.com/2863376813/Ai6zi2jXi">微博</a>）。辉哥@Fenng 吐槽了很多，把很多公司贬为“狗屎”，也从“问题与痛点”深入细致的
分析了在创业过程中，创业者们在解决问题和消除痛点时要思考的一些问题。
<center><img src="http://ibillxia.github.io/images/2013/IMAG2013111103.jpg"></center>
</p>




<h2>初创团队的产品展示</h2>


<p>『演讲团队之 “水果的牌子”Kivvi收银平板：时尚店主的第一台POS收银机。将收银系统和POS机完美结合，内置磁卡条、IC卡刷卡两种支付功能并预留NFC；简约一体的外观
设计为商户提供了宽敞的收银环境。商家可直接通过Kivvi编辑商品信息，完成现金和刷卡支付，查询交易记录销售报表@Gokivvi』（<a href="http://e.weibo.com/2863376813/Ai5lGCO99">微博</a>）。
『一个包含 硬件 互联网 金融 3个关键字的很炫的创业项目，赞一个~』（<a href="http://weibo.com/2704795533/Ai5lrfl11">微博</a>）。很好的一个创业点，也是这次产品展示中我最看好的项目之一。
</p>




<p>『演讲团队之 “数字时代让用户更爽”的九漫 交互式动态漫画：以自主研发的创新型交互式阅读引擎为依托，将静态的数字漫画改编成可交互的动态数字漫画。
九漫创新开发工具和完备的制作流程确保生产效率是传统2D动画的10倍以上，所以只需要不到1/10的成本，就可达到动画60%~70%的效果。[good]』
（<a href="http://e.weibo.com/2863376813/Ai5savoGs">微博</a>）。『交互式动态漫画，demo不错的样子，不过国内动漫2C的思路确实很难盈利，国外2B的
话还是有机会的~ 』（<a href="http://weibo.com/2704795533/Ai5tjFyA2">微博</a>）。
</p>




<p>『演讲团队之 要出发旅行网：针对都市白领、年轻一族，围绕周边自驾游，提供精品特价的度假产品。精选主流城市周边的优质“酒店+吃喝玩乐”搭配。
由旅行记者实地考察亲身体验，保证酒店品质及服务的高品质，也有特派摄影师实地拍照，专业设计团队制作文案，为用户提供齐全的游玩攻略。[给力]』
（<a href="http://e.weibo.com/2863376813/Ai5vNn0HA">微博</a>）。『周边自驾游，用DS能够接受的钱享受GFS般的服务，但是价格战不是小公司的致胜之道啊~』
（<a href="http://weibo.com/2704795533/Ai5yJFySh">微博</a>）。
</p>




<p>『演讲团队之 找大巴网——首创BO2O大巴招投标预订直销模式：专注打造大巴预订直销平台和最方便好用的大巴预订神器。托酒店管理公司平台，
找大巴网拥有自己的车队和百家合作车队。提供大巴供应商直销管理系统，方便大巴车队调度人员管理车辆库存，提高出租率，增加车队收入。[给力]』
（<a href="http://e.weibo.com/2863376813/Ai5CJ2FXd">微博</a>）。『大巴预定神奇，可以比价，有评论，审核系统。。。 』（<a href="http://weibo.com/2704795533/Ai5CMg2ss">微博</a>）。
大巴版快的打车，比较看好~
</p>




<p>『演讲团队之 微洽，做工作社交阶段的引领者——一款基于企业2.0理念设计的企业社交化工作平台。对企业而言，用全新的产品体验，改变工作沟通、
协作和分享方式，促进工作目标的达成；对个人而言，通过满足基于工作的社交需求，实现个人在工作和职业上的存在感。[可爱]』
（<a href="http://e.weibo.com/2863376813/Ai5Y4xKGG">微博</a>）。『企业社交，又一个有意思的垂直入口～』（<a href="http://weibo.com/2704795533/Ai5WKmJlY">微博</a>）。
企业版的微信，但推广有难度，2B or 2C，That&#8217;s a question。
</p>




<p>『演讲团队之 阿姨厨房，“寻找您身边的私房菜”——P2P模式的餐饮创业平台。阿姨厨房整合闲置的厨房、让有手艺的家庭从事餐饮服务，为周边的白领、
邻居提供私房菜。阿姨厨房建立标准化体系、整合物流、线上营销为创业者提供用户、物流服务。明天有没有糖醋小排？[花心]』
（<a href="http://e.weibo.com/2863376813/Ai61MpZuA">微博</a>）。『很有意思，但确实推广难度很大啊，不过吃货有福利了～』
（<a href="http://weibo.com/2704795533/Ai65YpONI">微博</a>）。感觉用户群的年龄偏大，确实不太好推广，从小区和菜市场入手进行推广，很不错的切入点。
</p>




<p>『演讲团队之 同船渡——帮你来一场说走就走的旅行。同船渡通过支持用户根据爱好、玩法、自定义路线等创造新的旅行点打造“旅游wiki”；并且提供功能让
用户根据自身需求邀约旅行，让熟悉创建旅行点数据的用户成为向导，实现旅游从Do It Yourself到Design It Yourself的改变。』
（<a href="http://e.weibo.com/2863376813/Ai66Jsc4f">微博</a>）。『信息量确实很大，节操掉了一地啊～』（<a href="http://weibo.com/2704795533/Ai66S0n1S">微博</a>）。

</p>




<p>PS: 这几个创业项目在36kr上都有过报道，可以参见 <a href="http://www.36kr.com/events/oday-201311-hz#posts_list">列表</a>.</br>
相关的PPT微盘资源如下：<a href="http://vdisk.weibo.com/u/2863376813?page=1">演讲PPT合集</a></p>




<h2>观众参与的开放演讲</h2>


<p>每个人1分钟的开放演讲很短，包括如下项目：画吧、快读、37 度、比比、氢学习、Omygod、Tipix—照片编辑App、配配、微信公众账号杭电助手、车纷享、穿戴式智能设备、享赢棋牌联盟、
爱扫货、微博书等，其中一些已经有成品发布，有些则还处于开发测试阶段。这其中以下几个项目已被36kr创业数据库收录或者被报道过：</br>
<a href="http://www.36kr.net/huaba">画吧</a></br>
<a href="http://www.36kr.net/kuaiduyueduqi">快读</a></br>
<a href="http://www.36kr.net/qingxuexi">氢学习</a></br>
<a href="http://www.36kr.net/Tipix">Tipix—照片编辑App</a></br>
<a href="http://www.36kr.net/peipei">配配</a></br>
<a href="http://www.36kr.net/chefenxiang">车纷享</a></br>
可以点击以上链接获得这些项目更加详细的信息。
</p>




<p>后记：第一次参加这样高大上的创业分享盛会，还是挺激动的，非常感谢@36氪 和 @36氪开放日。创业是一件很刺激、需要激情和果敢的事，也是一件需要理性、需要毅力的事。
创业是一种追求，一种价值观，一种生活方式。</p>

]]></content>
  </entry>
  
</feed>
