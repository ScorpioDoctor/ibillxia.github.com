
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>深入理解STL源码(4.4) 关联式容器之hashtable - Bill's Blog</title>
  <meta name="author" content="Bill Xia">

  
  <meta name="description" content="Yesterday is History, Tomorrow a Mystery, Today is a Gift, Thats why it's called the Present！">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/bootstrap/bootstrap.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/bootstrap/responsive.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/syntax/syntax.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css">
  <style type="text/css">
    body {
      padding-bottom: 0px;
    }
    h1 {
      margin-bottom: 15px;
    }
    img {
      max-width: 100%;
    }
    .sharing, .meta, .pager {
      margin: 20px 0px 20px 0px;
    }
    .page-footer p {
      text-align: center;
    }
  </style>
  <script src="/javascripts/libs/jquery.js"></script>
  <script src="/javascripts/libs/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/bootstrap.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Bill's Blog" type="application/atom+xml">
  <script type="text/javascript">
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}

$(document).bind('DOMNodeInserted', function(event) {
  addBlankTargetForLinks();
});
</script>
<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/javascript">
$(document).ready(function(){

	// hide #back-top first
	$("#back-top").hide();
	
	// fade in #back-top
	$(function () {
		$(window).scroll(function () {
			if ($(this).scrollTop() > 100) {
				$('#back-top').fadeIn();
			} else {
				$('#back-top').fadeOut();
			}
		});

		// scroll body to 0px on click
		$('#back-top a').click(function () {
			$('body,html').animate({
				scrollTop: 0
			}, 800);
			return false;
		});
	});

});
</script>

  

</head>

<body   >
  <nav role="navigation"><div class="navbar navbar-inverse">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">Bill's Blog</a>

      <div class="nav-collapse">
        <ul class="nav">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories">Categories</a></li>
  <li><a href="/blog/tags">Tags</a></li>
  <li><a href="/about">About</a></li>
</ul>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
          
        </ul>

        
          <form class="pull-right navbar-search" action="http://www.google.com/" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:ibillxia.github.io" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>
        
      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      
<article class="hentry span9" role="article">

  
  <header class="page-header">
    
      <h1 class="entry-title">深入理解STL源码(4.4) 关联式容器之hashtable</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-13T21:30:00+08:00" pubdate data-updated="true">Sep 13<span>th</span>, 2014</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hashtable.h</code>、<code>stl_hash_fun.h</code> 等文件。</p>

<h2>1. hashtable 简介</h2>

<p>在数据结构中我们知道，有种数据结构的插入、删除、查找等操作的性能是常数时间，但需要比元素个数更多的空间，这种数据结构就是哈希表。哈希表的基本思想是，将数据存储在与其数值大小相关的地方，比如对该数取模，然后存储在以余数为下表的数组中。但这样会出现一个问题，就是可能会有多个数据被映射到同一个存储位置，即出现了所谓的“碰撞”。哈希表的主要内容就是解决“碰撞”问题，一般而言有以下几种方法：线性探测、二次探测、开链等。</p>

<h4>线性探测</h4>

<p>简单而言，就是在出现“碰撞”后，寻找当前位置以后的空档，然后存入。如果找到尾部都没有空档，则从头部重新开始找。只要空间大小比元素个数大，总能找到的。相应的，元素的查找和删除也与普通的数组不同，查找如果直接定位到相应位置并找到或是空档，就可以确定存在或不存在，而如果定位到当前位置非空且与待查找的元素不同，则要依序寻找后续位置的元素，直到找到或移到了空档。删除则是采用懒惰删除策略，即只标记删除记号，实际删除操作则待表格重新整理时再进行。</p>

<h4>二次探测</h4>

<p>与线性探测类似，但向后寻找的策略是探测距当前位置为平方数的位置，即 $index = H+i<em><sup>{2}$</sup> </em>。但这样会有一个问题，那就是能否保证每次探测的是不同的位置，即是否存在某次插入时，探测完一圈后回到自己而出现死循环。</p>

<h4>开链</h4>

<p>这种方法是将出现冲突的元素放在一个链表中，而哈希表中只存储这些链表的首地址。SGI STL中就是使用这种方法来解决“碰撞”的。</p>

<h2>2. hashtable 的数据结构</h2>

<p>由于使用开链的方法解决冲突，所以要维护两种数据结构，一个是 hash table，在 STL 中称为 buckets，用 vector 作为容器；另一个是链表，这里没有使用 list 或 slist 这些现成的数据结构，而是使用自定义 <code>__hashtable_node</code> ，相关定义具体如下：</p>

<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Val</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">_Hashtable_node</span> <span class="p">{</span> <span class="c1">// 链表节点的定义</span>
</span><span class='line'>  <span class="n">_Hashtable_node</span><span class="o">*</span> <span class="n">_M_next</span><span class="p">;</span> <span class="c1">// 指向下一个节点</span>
</span><span class='line'>  <span class="n">_Val</span> <span class="n">_M_val</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Val</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_HashFcn</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_ExtractKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_EqualKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">hashtable</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">_HashFcn</span> <span class="n">hasher</span><span class="p">;</span>
</span><span class='line'>  <span class="n">hasher</span>                <span class="n">_M_hash</span><span class="p">;</span> <span class="c1">// 哈希函数</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">_Hashtable_node</span><span class="o">&lt;</span><span class="n">_Val</span><span class="o">&gt;</span> <span class="n">_Node</span><span class="p">;</span> <span class="c1">// 节点类型别名定义</span>
</span><span class='line'>  <span class="n">vector</span><span class="o">&lt;</span><span class="n">_Node</span><span class="o">*</span><span class="p">,</span><span class="n">_Alloc</span><span class="o">&gt;</span> <span class="n">_M_buckets</span><span class="p">;</span> <span class="c1">// hash table，存储链表的索引</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里 hashtable 的模板参数很多，其含义如下：</p>

<blockquote><p><em>Val: 节点的实值类型
</em>Key: 节点的键值类型
<em>HashFcn: 哈希函数的类型
</em>ExtractKey: 从节点中取出键值的方法（函数或仿函数）
<em>EqualKey: 判断键值相同与否的方法（函数或仿函数）
</em>Alloc: 空间配置器，默认使用 std::alloc</p></blockquote>

<p>虽然开链法并不要求哈希表的大小为质数，但 SGI STL 仍然以质数来设计表的大小，并将28个质数（大约2倍依次递增）计算好，并提供函数来查询其中最接近某数并大于某数的质数，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">enum</span> <span class="p">{</span> <span class="n">__stl_num_primes</span> <span class="o">=</span> <span class="mi">28</span> <span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__stl_prime_list</span><span class="p">[</span><span class="n">__stl_num_primes</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="mi">53ul</span><span class="p">,</span>         <span class="mi">97ul</span><span class="p">,</span>         <span class="mi">193ul</span><span class="p">,</span>       <span class="mi">389ul</span><span class="p">,</span>       <span class="mi">769ul</span><span class="p">,</span>
</span><span class='line'>  <span class="mi">1543ul</span><span class="p">,</span>       <span class="mi">3079ul</span><span class="p">,</span>       <span class="mi">6151ul</span><span class="p">,</span>      <span class="mi">12289ul</span><span class="p">,</span>     <span class="mi">24593ul</span><span class="p">,</span>
</span><span class='line'>  <span class="mi">49157ul</span><span class="p">,</span>      <span class="mi">98317ul</span><span class="p">,</span>      <span class="mi">196613ul</span><span class="p">,</span>    <span class="mi">393241ul</span><span class="p">,</span>    <span class="mi">786433ul</span><span class="p">,</span>
</span><span class='line'>  <span class="mi">1572869ul</span><span class="p">,</span>    <span class="mi">3145739ul</span><span class="p">,</span>    <span class="mi">6291469ul</span><span class="p">,</span>   <span class="mi">12582917ul</span><span class="p">,</span>  <span class="mi">25165843ul</span><span class="p">,</span>
</span><span class='line'>  <span class="mi">50331653ul</span><span class="p">,</span>   <span class="mi">100663319ul</span><span class="p">,</span>  <span class="mi">201326611ul</span><span class="p">,</span> <span class="mi">402653189ul</span><span class="p">,</span> <span class="mi">805306457ul</span><span class="p">,</span>
</span><span class='line'>  <span class="mi">1610612741ul</span><span class="p">,</span> <span class="mi">3221225473ul</span><span class="p">,</span> <span class="mi">4294967291ul</span>
</span><span class='line'><span class="p">};</span> <span class="c1">// 使用无符号长整型（32bit）</span>
</span><span class='line'><span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__stl_next_prime</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span> <span class="n">__first</span> <span class="o">=</span> <span class="n">__stl_prime_list</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span> <span class="n">__last</span> <span class="o">=</span> <span class="n">__stl_prime_list</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">__stl_num_primes</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">,</span> <span class="n">__n</span><span class="p">);</span> <span class="c1">// lower_bound 是泛型算法，后续会介绍</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">__last</span> <span class="o">?</span> <span class="o">*</span><span class="p">(</span><span class="n">__last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>3. hashtable 的空间配置</h2>

<h4>节点空间配置</h4>

<p>首先只考虑比较简单的情况，即哈希表的大小不需要调整，此时空间配置主要是链表节点的配置，而 hashtable 使用 vector 作为容器，链表节点的空间配置（分配和释放）如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="n">simple_alloc</span><span class="o">&lt;</span><span class="n">_Node</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="n">_M_node_allocator_type</span><span class="p">;</span>
</span><span class='line'><span class="n">_Node</span><span class="o">*</span> <span class="n">_M_get_node</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_M_node_allocator_type</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span> <span class="c1">// 分配一个节点的空间</span>
</span><span class='line'><span class="kt">void</span> <span class="n">_M_put_node</span><span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__p</span><span class="p">)</span> <span class="p">{</span> <span class="n">_M_node_allocator_type</span><span class="o">::</span><span class="n">deallocate</span><span class="p">(</span><span class="n">__p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span> <span class="c1">// 释放一个节点的空间</span>
</span><span class='line'><span class="n">_Node</span><span class="o">*</span> <span class="n">_M_new_node</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_Node</span><span class="o">*</span> <span class="n">__n</span> <span class="o">=</span> <span class="n">_M_get_node</span><span class="p">();</span>
</span><span class='line'>  <span class="n">__n</span><span class="o">-&gt;</span><span class="n">_M_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__STL_TRY</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__n</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">,</span> <span class="n">__obj</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">__n</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">_M_put_node</span><span class="p">(</span><span class="n">__n</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">_M_delete_node</span><span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__n</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">);</span>
</span><span class='line'>  <span class="n">_M_put_node</span><span class="p">(</span><span class="n">__n</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>插入操作表格重新整理</h4>

<p>哈希表的插入操作有两个问题要考虑，一个是 是否允许插入相同键值的元素，另一个是 是否需要扩充表的大小。在 STL 中，首先是判断新插入一个元素后是否需要扩充，判断的条件是插入后元素的个数大于当前哈希表的大小；而是否允许元素重复则通过提供 <code>insert_unique</code> 和 <code>insert_equal</code> 来解决。相关代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_unique</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">resize</span><span class="p">(</span><span class="n">_M_num_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 先进行扩充（如有必要）</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">insert_unique_noresize</span><span class="p">(</span><span class="n">__obj</span><span class="p">);</span> <span class="c1">// 然后插入</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">insert_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">resize</span><span class="p">(</span><span class="n">_M_num_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">insert_equal_noresize</span><span class="p">(</span><span class="n">__obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">hashtable</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span><span class="n">_Key</span><span class="p">,</span><span class="n">_HF</span><span class="p">,</span><span class="n">_Ex</span><span class="p">,</span><span class="n">_Eq</span><span class="p">,</span><span class="n">_All</span><span class="o">&gt;::</span><span class="n">resize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">__num_elements_hint</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 扩充表格</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">size_type</span> <span class="n">__old_n</span> <span class="o">=</span> <span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">__num_elements_hint</span> <span class="o">&gt;</span> <span class="n">__old_n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 判断是否需要扩充</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">size_type</span> <span class="n">__n</span> <span class="o">=</span> <span class="n">_M_next_size</span><span class="p">(</span><span class="n">__num_elements_hint</span><span class="p">);</span> <span class="c1">// 下一个质数</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">__n</span> <span class="o">&gt;</span> <span class="n">__old_n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">vector</span><span class="o">&lt;</span><span class="n">_Node</span><span class="o">*</span><span class="p">,</span> <span class="n">_All</span><span class="o">&gt;</span> <span class="n">__tmp</span><span class="p">(</span><span class="n">__n</span><span class="p">,</span> <span class="p">(</span><span class="n">_Node</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_M_buckets</span><span class="p">.</span><span class="n">get_allocator</span><span class="p">());</span> <span class="c1">// 新的buckets</span>
</span><span class='line'>      <span class="n">__STL_TRY</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">size_type</span> <span class="n">__bucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">__bucket</span> <span class="o">&lt;</span> <span class="n">__old_n</span><span class="p">;</span> <span class="o">++</span><span class="n">__bucket</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历旧的buckets</span>
</span><span class='line'>          <span class="n">_Node</span><span class="o">*</span> <span class="n">__first</span> <span class="o">=</span> <span class="n">_M_buckets</span><span class="p">[</span><span class="n">__bucket</span><span class="p">];</span>
</span><span class='line'>          <span class="k">while</span> <span class="p">(</span><span class="n">__first</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 处理每一个链表</span>
</span><span class='line'>            <span class="n">size_type</span> <span class="n">__new_bucket</span> <span class="o">=</span> <span class="n">_M_bkt_num</span><span class="p">(</span><span class="n">__first</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">,</span> <span class="n">__n</span><span class="p">);</span> <span class="c1">// 确定当前节点落在新buckets中的位置</span>
</span><span class='line'>            <span class="n">_M_buckets</span><span class="p">[</span><span class="n">__bucket</span><span class="p">]</span> <span class="o">=</span> <span class="n">__first</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span> <span class="c1">// 指向下一个节点</span>
</span><span class='line'>            <span class="n">__first</span><span class="o">-&gt;</span><span class="n">_M_next</span> <span class="o">=</span> <span class="n">__tmp</span><span class="p">[</span><span class="n">__new_bucket</span><span class="p">];</span> <span class="c1">// 在新buckets的新索引位置头部插入</span>
</span><span class='line'>            <span class="n">__tmp</span><span class="p">[</span><span class="n">__new_bucket</span><span class="p">]</span> <span class="o">=</span> <span class="n">__first</span><span class="p">;</span>
</span><span class='line'>            <span class="n">__first</span> <span class="o">=</span> <span class="n">_M_buckets</span><span class="p">[</span><span class="n">__bucket</span><span class="p">];</span> <span class="c1">// 指向旧链表下一个节点</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">_M_buckets</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">__tmp</span><span class="p">);</span> <span class="c1">// 交换新旧buckets，退出后临时buckets __tmp 自动释放</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Val</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_HF</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ex</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Eq</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_All</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">pair</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">hashtable</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span><span class="n">_Key</span><span class="p">,</span><span class="n">_HF</span><span class="p">,</span><span class="n">_Ex</span><span class="p">,</span><span class="n">_Eq</span><span class="p">,</span><span class="n">_All</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">hashtable</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span><span class="n">_Key</span><span class="p">,</span><span class="n">_HF</span><span class="p">,</span><span class="n">_Ex</span><span class="p">,</span><span class="n">_Eq</span><span class="p">,</span><span class="n">_All</span><span class="o">&gt;::</span><span class="n">insert_unique_noresize</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__obj</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不允许键值重复</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">size_type</span> <span class="n">__n</span> <span class="o">=</span> <span class="n">_M_bkt_num</span><span class="p">(</span><span class="n">__obj</span><span class="p">);</span>
</span><span class='line'>  <span class="n">_Node</span><span class="o">*</span> <span class="n">__first</span> <span class="o">=</span> <span class="n">_M_buckets</span><span class="p">[</span><span class="n">__n</span><span class="p">];</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__cur</span> <span class="o">=</span> <span class="n">__first</span><span class="p">;</span> <span class="n">__cur</span><span class="p">;</span> <span class="n">__cur</span> <span class="o">=</span> <span class="n">__cur</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">_M_equals</span><span class="p">(</span><span class="n">_M_get_key</span><span class="p">(</span><span class="n">__cur</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">),</span> <span class="n">_M_get_key</span><span class="p">(</span><span class="n">__obj</span><span class="p">)))</span> <span class="c1">// 判断是否存在重复的key</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iterator</span><span class="p">(</span><span class="n">__cur</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
</span><span class='line'>  <span class="n">_Node</span><span class="o">*</span> <span class="n">__tmp</span> <span class="o">=</span> <span class="n">_M_new_node</span><span class="p">(</span><span class="n">__obj</span><span class="p">);</span>
</span><span class='line'>  <span class="n">__tmp</span><span class="o">-&gt;</span><span class="n">_M_next</span> <span class="o">=</span> <span class="n">__first</span><span class="p">;</span>
</span><span class='line'>  <span class="n">_M_buckets</span><span class="p">[</span><span class="n">__n</span><span class="p">]</span> <span class="o">=</span> <span class="n">__tmp</span><span class="p">;</span>
</span><span class='line'>  <span class="o">++</span><span class="n">_M_num_elements</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iterator</span><span class="p">(</span><span class="n">__tmp</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="kc">true</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>允许键值重复的插入操作类似的，只是为了确保相同键值的挨在一起，先要找到相同键值的位置，然后插入。</p>

<h4>整体复制和清空</h4>

<p>复制和清空时分别涉及空间的分配和释放，所以在这里也介绍一下。首先是复制操作，需要先将目标 hashtable 清空，然后将源 hashtable 的 buckets 中的每个链表一一复制，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Val</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_HF</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ex</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Eq</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_All</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">hashtable</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span><span class="n">_Key</span><span class="p">,</span><span class="n">_HF</span><span class="p">,</span><span class="n">_Ex</span><span class="p">,</span><span class="n">_Eq</span><span class="p">,</span><span class="n">_All</span><span class="o">&gt;::</span><span class="n">_M_copy_from</span><span class="p">(</span><span class="k">const</span> <span class="n">hashtable</span><span class="o">&amp;</span> <span class="n">__ht</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_M_buckets</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// 先清空目标 hashtable</span>
</span><span class='line'>  <span class="n">_M_buckets</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">__ht</span><span class="p">.</span><span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// 大小重置为源 hashtable 的大小</span>
</span><span class='line'>  <span class="n">_M_buckets</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_M_buckets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">__ht</span><span class="p">.</span><span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="n">_Node</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 将目标 hashtable 的 buckets 置空</span>
</span><span class='line'>  <span class="n">__STL_TRY</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">size_type</span> <span class="n">__i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">__i</span> <span class="o">&lt;</span> <span class="n">__ht</span><span class="p">.</span><span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">__i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历 buckets</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">_Node</span><span class="o">*</span> <span class="n">__cur</span> <span class="o">=</span> <span class="n">__ht</span><span class="p">.</span><span class="n">_M_buckets</span><span class="p">[</span><span class="n">__i</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">__cur</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_Node</span><span class="o">*</span> <span class="n">__copy</span> <span class="o">=</span> <span class="n">_M_new_node</span><span class="p">(</span><span class="n">__cur</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">);</span>
</span><span class='line'>        <span class="n">_M_buckets</span><span class="p">[</span><span class="n">__i</span><span class="p">]</span> <span class="o">=</span> <span class="n">__copy</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__next</span> <span class="o">=</span> <span class="n">__cur</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span> <span class="n">__next</span><span class="p">;</span> <span class="n">__cur</span> <span class="o">=</span> <span class="n">__next</span><span class="p">,</span>
</span><span class='line'>              <span class="n">__next</span> <span class="o">=</span> <span class="n">__cur</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 复制每个节点</span>
</span><span class='line'>          <span class="n">__copy</span><span class="o">-&gt;</span><span class="n">_M_next</span> <span class="o">=</span> <span class="n">_M_new_node</span><span class="p">(</span><span class="n">__next</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">);</span>
</span><span class='line'>          <span class="n">__copy</span> <span class="o">=</span> <span class="n">__copy</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">_M_num_elements</span> <span class="o">=</span> <span class="n">__ht</span><span class="p">.</span><span class="n">_M_num_elements</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">clear</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. hashtable 的迭代器</h2>

<p>hashtable 的迭代器是前向的单向迭代器，遍历的方式是先遍历完一个 list 然后切换到下一个 bucket 指向的 list 进行遍历。以下是 hashtable 的迭代器的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Val</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_HashFcn</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_ExtractKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_EqualKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">_Hashtable_iterator</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">hashtable</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span><span class="n">_Key</span><span class="p">,</span><span class="n">_HashFcn</span><span class="p">,</span><span class="n">_ExtractKey</span><span class="p">,</span><span class="n">_EqualKey</span><span class="p">,</span><span class="n">_Alloc</span><span class="o">&gt;</span> <span class="n">_Hashtable</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">_Hashtable_iterator</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_HashFcn</span><span class="p">,</span> <span class="n">_ExtractKey</span><span class="p">,</span> <span class="n">_EqualKey</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">_Hashtable_const_iterator</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span> <span class="n">_Key</span><span class="p">,</span> <span class="n">_HashFcn</span><span class="p">,</span> <span class="n">_ExtractKey</span><span class="p">,</span> <span class="n">_EqualKey</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">_Hashtable_node</span><span class="o">&lt;</span><span class="n">_Val</span><span class="o">&gt;</span> <span class="n">_Node</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">_Node</span><span class="o">*</span> <span class="n">_M_cur</span><span class="p">;</span> <span class="c1">// 指向当前节点</span>
</span><span class='line'>  <span class="n">_Hashtable</span><span class="o">*</span> <span class="n">_M_ht</span><span class="p">;</span> <span class="c1">// 指向当前节点所在 bucket</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">_Hashtable_iterator</span><span class="p">(</span><span class="n">_Node</span><span class="o">*</span> <span class="n">__n</span><span class="p">,</span> <span class="n">_Hashtable</span><span class="o">*</span> <span class="n">__tab</span><span class="p">)</span> <span class="o">:</span> <span class="n">_M_cur</span><span class="p">(</span><span class="n">__n</span><span class="p">),</span> <span class="n">_M_ht</span><span class="p">(</span><span class="n">__tab</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">_Hashtable_iterator</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_M_cur</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
</span><span class='line'>  <span class="n">iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">__it</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_M_cur</span> <span class="o">==</span> <span class="n">__it</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">__it</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_M_cur</span> <span class="o">!=</span> <span class="n">__it</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Val</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_HF</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_ExK</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_EqK</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_All</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">_Hashtable_iterator</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span><span class="n">_Key</span><span class="p">,</span><span class="n">_HF</span><span class="p">,</span><span class="n">_ExK</span><span class="p">,</span><span class="n">_EqK</span><span class="p">,</span><span class="n">_All</span><span class="o">&gt;&amp;</span>
</span><span class='line'><span class="n">_Hashtable_iterator</span><span class="o">&lt;</span><span class="n">_Val</span><span class="p">,</span><span class="n">_Key</span><span class="p">,</span><span class="n">_HF</span><span class="p">,</span><span class="n">_ExK</span><span class="p">,</span><span class="n">_EqK</span><span class="p">,</span><span class="n">_All</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">++</span><span class="p">(){</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">_Node</span><span class="o">*</span> <span class="n">__old</span> <span class="o">=</span> <span class="n">_M_cur</span><span class="p">;</span>
</span><span class='line'>  <span class="n">_M_cur</span> <span class="o">=</span> <span class="n">_M_cur</span><span class="o">-&gt;</span><span class="n">_M_next</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_M_cur</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 到了当前 bucket 的尾部</span>
</span><span class='line'>    <span class="n">size_type</span> <span class="n">__bucket</span> <span class="o">=</span> <span class="n">_M_ht</span><span class="o">-&gt;</span><span class="n">_M_bkt_num</span><span class="p">(</span><span class="n">__old</span><span class="o">-&gt;</span><span class="n">_M_val</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">_M_cur</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">__bucket</span> <span class="o">&lt;</span> <span class="n">_M_ht</span><span class="o">-&gt;</span><span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
</span><span class='line'>      <span class="n">_M_cur</span> <span class="o">=</span> <span class="n">_M_ht</span><span class="o">-&gt;</span><span class="n">_M_buckets</span><span class="p">[</span><span class="n">__bucket</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5. 哈希函数</h2>

<p>在第三节中介绍 hashtable 的数据结构时，提到了一个哈希函数类型的模板参数，从键值到索引位置的映射由这个哈希函数来完成，实际中是通过函数 <code>_M_bkt_num_key</code> 来完成这个映射的，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">size_type</span> <span class="n">_M_bkt_num_key</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">__key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">_M_bkt_num_key</span><span class="p">(</span><span class="n">__key</span><span class="p">,</span> <span class="n">_M_buckets</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">size_type</span> <span class="n">_M_bkt_num_key</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">__key</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">__n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">_M_hash</span><span class="p">(</span><span class="n">__key</span><span class="p">)</span> <span class="o">%</span> <span class="n">__n</span><span class="p">;</span> <span class="c1">// 在这里调用函数 _M_hash，实现映射</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的 <code>_M_hash</code> 是一个哈希函数类型的成员，可以看做是一个函数指针，真正的函数的定义在 <code>&lt;stl_hash_fun.h&gt;</code> 中，针对 char，int，long 等整数型别，这里大部分的 hash function 什么也没做，只是重视返回原始值，但对字符串（const char* ）设计了一个转换函数，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Key</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">hash</span> <span class="p">{</span> <span class="p">};</span> <span class="c1">// 仿函数 hash</span>
</span><span class='line'><span class="kr">inline</span> <span class="n">size_t</span> <span class="n">__stl_hash_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">__s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 将字符串映射为整型</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">__s</span><span class="p">;</span> <span class="o">++</span><span class="n">__s</span><span class="p">)</span>
</span><span class='line'>    <span class="n">__h</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">__h</span> <span class="o">+</span> <span class="o">*</span><span class="n">__s</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">size_t</span><span class="p">(</span><span class="n">__h</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">__s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__stl_hash_string</span><span class="p">(</span><span class="n">__s</span><span class="p">);</span> <span class="p">}</span> <span class="c1">// 函数调用操作符 operator()</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">__s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__stl_hash_string</span><span class="p">(</span><span class="n">__s</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">char</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">signed</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">short</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">long</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="n">__STL_TEMPLATE_NULL</span> <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__x</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于函数调用操作符的更多介绍，可以参见我的另一篇文章 【<a href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/">C语言函数指针与C++函数调用操作符</a>】。</p>
</div>
<div id="copyleft" class="well" >
	<span>Original Link: <a rel="full-article" href="">http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable/</a></br>
	Attribution - NON-Commercial - ShareAlike - Copyright &copy; <a href="http://about.me/ibillxia">Bill Xia</a> <span>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn"><a href="http://about.me/ibillxia">Bill Xia</a></span></span>

      








  


<time datetime="2014-09-13T21:30:00+08:00" pubdate data-updated="true">Sep 13<span>th</span>, 2014</time>
		
		
		
		  <span class="categories">Posted in <a class='category' href='/blog/categories/program/'>Program</a></span>
		
		
		  <span class="tags">Tagged with <a class='tag' href='/blog/tags/c-plus-plus/'>C++</a>, <a class='tag' href='/blog/tags/stl/'>STL</a>, <a class='tag' href='/blog/tags/ha-xi-biao/'>哈希表</a>, <a class='tag' href='/blog/tags/rong-qi/'>容器</a></span>
		
    </p>
    
      
         <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_douban"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_fb"></a>
	<a class="jiathis_button_twitter"></a>
	<a class="jiathis_button_tumblr"></a>
	<a class="jiathis_button_googleplus"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1362901762548695" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    
	</br>
	 <ul class="pager">
      
      <li class="previous"><a class="basic-alignment left"
        href="/blog/2014/08/31/insight-into-stl-4-associative-containers-3-map-and-multimap/" title="Previous Post:
        深入理解STL源码(4.3) 关联式容器之map和multimap">&laquo; 深入理解STL源码(4.3) 关联式容器之map和multimap</a></li>
      
      <li><a href="/blog/archives">Blog Archives</a></li>
      
      <li class="next"><a class="basic-alignment right" href="/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap/"
        title="Next Post: 深入理解STL源码(4.5) 关联式容器之hashset和hashmap">深入理解STL源码(4.5) 关联式容器之hashset和hashmap
        &raquo;</a></li>
      
    </ul>
    
    <section>
      <h1>Comments</h1>
      <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
    </section>
    
   
  </footer>
</article>

<aside class="sidebar-nav span3">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo" class="page-footer"><p id = "back-top">
	<a href="#top"><span></span>Back to Top</a>
</p>
<hr>
<p>
  Copyright &copy; 2009 - 2015 - <a href="http://about.me/ibillxia">Bill Xia</a> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> - Theme by <a href="https://github.com/bkutil/bootstrap-theme">bootstrap-theme</a> </span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'ibillxia';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable/';
        var disqus_url = 'http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
