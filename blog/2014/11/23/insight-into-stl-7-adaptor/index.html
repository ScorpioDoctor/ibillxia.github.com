
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>深入理解STL源码(7) 配接器adaptor - Bill's Blog</title>
  <meta name="author" content="Bill Xia">

  
  <meta name="description" content="Yesterday is History, Tomorrow a Mystery, Today is a Gift, Thats why it's called the Present！">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ibillxia.github.io/blog/2014/11/23/insight-into-stl-7-adaptor">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/bootstrap/bootstrap.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/bootstrap/responsive.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/syntax/syntax.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/style.css" media="screen, projection" rel="stylesheet" type="text/css">
  <style type="text/css">
    body {
      padding-bottom: 0px;
    }
    h1 {
      margin-bottom: 15px;
    }
    img {
      max-width: 100%;
    }
    .sharing, .meta, .pager {
      margin: 20px 0px 20px 0px;
    }
    .page-footer p {
      text-align: center;
    }
  </style>
  <script src="/javascripts/libs/jquery.js"></script>
  <script src="/javascripts/libs/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/bootstrap.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Bill's Blog" type="application/atom+xml">
  <script type="text/javascript">
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}

$(document).bind('DOMNodeInserted', function(event) {
  addBlankTargetForLinks();
});
</script>
<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/javascript">
$(document).ready(function(){

	// hide #back-top first
	$("#back-top").hide();
	
	// fade in #back-top
	$(function () {
		$(window).scroll(function () {
			if ($(this).scrollTop() > 100) {
				$('#back-top').fadeIn();
			} else {
				$('#back-top').fadeOut();
			}
		});

		// scroll body to 0px on click
		$('#back-top a').click(function () {
			$('body,html').animate({
				scrollTop: 0
			}, 800);
			return false;
		});
	});

});
</script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-39460228-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><div class="navbar navbar-inverse">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">Bill's Blog</a>

      <div class="nav-collapse">
        <ul class="nav">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/categories">Categories</a></li>
  <li><a href="/blog/tags">Tags</a></li>
  <li><a href="/about">About</a></li>
</ul>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
          
        </ul>

        
          <form class="pull-right navbar-search" action="http://www.google.com/" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:ibillxia.github.io" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>
        
      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      
<article class="hentry span9" role="article">

  
  <header class="page-header">
    
      <h1 class="entry-title">深入理解STL源码(7) 配接器adaptor</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-23T20:21:00+08:00" pubdate data-updated="true">Nov 23<span>rd</span>, 2014</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><h2>1. 概述</h2>

<p>适配器（adaptor/adapter）在STL组件的灵活运用功能上，扮演着轴承、转换器的角色，将一种容器或迭代器装换或封装成另一种容器或迭代器，例如基于deque容器的stack和queue。Adaptor这个概念，实际上是一种设计模式（design pattern），是《Design Pattern》一书中提及到的23个设计模式之一，其中对adaptor的定义如下：</p>

<blockquote><p>将一个class的接口转换为另一个class的接口，使原本因接口不兼容而不能合作的classes，可以一起运作。</p></blockquote>

<p>在STL中，除了上面提到的容器或迭代器的适配器之外，还可以对函数或更广义的仿函数使用适配器，改变其接口，这种称为function adaptor，相应的针对容器或迭代器的适配器则分别称为container adaptor，iterator adaptor，下面将分别介绍这三种适配器。</p>

<h2>2. 容器适配器</h2>

<p>容器适配器相对而言比较简单，比较典型的就是上面提到的低层由deque构成的stack和queue，其基本实现原理是，在 stack 和 queue 内部定义一个 protected 的 deque 类型的成员变量，然后只对外提供 deque 的部分功能或其异构，如 stack 的 push 和 pop 都是从 deque 的尾部进行插入和删除，而 queue 的 push 和 pop 分别是从尾部和头部进行插入和删除，这样 stack 和 queue 都可以看做是适配器，作用于容器 deque 之上的适配器。关于 stack 和 queue 的具体内容请参见之前将容器的文章 <a href="http://ibillxia.github.io/blog/2014/07/13/stl-source-insight-3-sequential-containers-3-deque-and-stack-queue/">深入理解STL源码(3.3) 序列式容器之deque和stack、queue</a>。</p>

<!-- more -->


<h2>3. 迭代器适配器</h2>

<p>STL提供了许多作用于迭代器之上的适配器，如 insert iterator，reverse iterator，iostream iterator等，相关源代码主要在 <code>stl_iterator.h</code> 文件中。</p>

<h4>3.1 insert iterator</h4>

<p>其中 insert iterator 是将一般的迭代器的赋值（assign）操作变为插入（insert）操作，而其他的自增和自减操作则不做任何处理的返回当前迭代器本身，包括从尾部插入的 <code>back_insert_iterator</code> 和从头部插入的 <code>front_insert_iterator</code> ，尾部插入的 insert iterator 的定义主要内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Container&gt; 
</span><span class='line'>class back_insert_iterator {
</span><span class='line'>public:
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;&
</span><span class='line'>  operator=(const typename _Container::value_type& __value) { // 赋值变为尾部插入
</span><span class='line'>    container-&gt;push_back(__value);
</span><span class='line'>    return *this;
</span><span class='line'>  }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator*() { return *this; } // 一下操作均返回迭代器本身
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator++() { return *this; }
</span><span class='line'>  back_insert_iterator&lt;_Container&gt;& operator++(int) { return *this; }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h4>3.2 reverse iterator</h4>

<p>reverse iterator 则将一般的迭代器的行进方向逆转，是原本应该前进的 <code>operator++</code> 变为后退操作，而 <code>operator--</code> 变为前进操作，这样做对于需要从尾部开始遍历的算法非常有用。该迭代器的主要定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Iterator&gt;
</span><span class='line'>class reverse_iterator {
</span><span class='line'>protected:
</span><span class='line'>  _Iterator current;
</span><span class='line'>public:
</span><span class='line'>  typedef _Iterator iterator_type;
</span><span class='line'>  typedef reverse_iterator&lt;_Iterator&gt; _Self;
</span><span class='line'>public:
</span><span class='line'>  _Self& operator++() { --current; return *this; } // 前置自增变为自减
</span><span class='line'>  _Self operator++(int) { _Self __tmp = *this; --current; return __tmp; }
</span><span class='line'>  _Self& operator--() { ++current; return *this; } // 前置自减变为自增
</span><span class='line'>  _Self operator--(int) { _Self __tmp = *this; ++current; return __tmp; }
</span><span class='line'>  _Self operator+(difference_type __n) const { return _Self(current - __n); }
</span><span class='line'>  _Self& operator+=(difference_type __n) { current -= __n; return *this; }
</span><span class='line'>  _Self operator-(difference_type __n) const { return _Self(current + __n); }
</span><span class='line'>  _Self& operator-=(difference_type __n) { current += __n; return *this; }
</span><span class='line'>  reference operator[](difference_type __n) const { return *(*this + __n); }  
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>这种逆向的迭代器只用于那些具有双向迭代器的容器（如vector，list，deque等，而slist，stack，queue，priority queue等则不行）或需要逆向遍历的算法（如copy backward等）。</p>

<h4>3.3  iostream iterator</h4>

<p>iostream iterator 则将迭代器绑定到某个 iostream 对象上，有 <code>istream_iterator</code> 和 <code>ostream_iterator</code> ，分别拥有输入和输出功能。</p>

<p>以 istream iterator 为例，它将迭代器绑定到一个输入数据流对象（istream object）上，其实就是在 istream iterator 内部维护一个 istream member，用户对这个 istream iterator 所做的 <code>operator++</code> 操作会被该迭代器变为这个 istream member 的输入操作 <code>operator&gt;&gt;</code>，这个迭代器是一个 input iterator，没有 <code>operator--</code> 操作，核心实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Tp, class _CharT = char, class _Traits = char_traits&lt;_CharT&gt;,
</span><span class='line'>          class _Dist = ptrdiff_t&gt; 
</span><span class='line'>class istream_iterator {
</span><span class='line'>public:
</span><span class='line'>  typedef _CharT                         char_type;
</span><span class='line'>  typedef _Traits                        traits_type;
</span><span class='line'>  typedef basic_istream&lt;_CharT, _Traits&gt; istream_type;
</span><span class='line'>  reference operator*() const { return _M_value; }
</span><span class='line'>  pointer operator-&gt;() const { return &(operator*()); }
</span><span class='line'>  istream_iterator& operator++() { _M_read(); return *this; } // ++ 变为 &gt;&gt;
</span><span class='line'>  istream_iterator operator++(int)  { istream_iterator __tmp = *this; _M_read(); return __tmp; }
</span><span class='line'>  bool _M_equal(const istream_iterator& __x) const
</span><span class='line'>    { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }
</span><span class='line'>private:
</span><span class='line'>  istream_type* _M_stream;
</span><span class='line'>  _Tp _M_value;
</span><span class='line'>  bool _M_ok;
</span><span class='line'>  void _M_read() {
</span><span class='line'>    _M_ok = (_M_stream && *_M_stream) ? true : false;
</span><span class='line'>    if (_M_ok) {
</span><span class='line'>      *_M_stream &gt;&gt; _M_value; // 转变为输入操作（&gt;&gt;）
</span><span class='line'>      _M_ok = *_M_stream ? true : false;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>可以看到以上的迭代器均非一般意义上的迭代器了，而是一个经过适配了的特殊的迭代器。</p>

<h2>4. 仿函数适配器</h2>

<p>从上文中我们看到，container adaptor 内含一个container 的成员，iterator 内含一个 iterator 或 iostream 成员，然后对这些成员的标准接口进行了一定的改造，从而使之变成一个新的 container 或 iterator，满足新的应用环境的要求。而仿函数的适配器也是类似的，其实就是在 function adaptor 内部定义了一个成员变量，它是原始 functor 的一个对象，相关源代码主要在 <code>stl_function.h</code> 文件中。</p>

<p>STL中标准的 functor adaptor 包括对返回值进行逻辑否定的 <code>not1</code>，<code>not2</code>；对参数进行绑定的 <code>bind1st</code>，<code>bind2nd</code>；用于函数合成的 <code>compose1</code>，<code>compose2</code> （非STL标准，SGI私有）；用于函数指针的 <code>ptr_fun</code>；用于成员函数指针的 <code>mem_fun</code>，<code>mem_fun_ref</code> 等。其中逻辑否定、参数绑定、函数合成的比较简单，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// not1其实是对unary_negate函数的一个简单的封装，定义了一个unary_negate类型匿名对象（函数）
</span><span class='line'>inline unary_negate&lt;_Predicate&gt; // 实际效果：!pred(param)
</span><span class='line'>not1(const _Predicate& __pred){ return unary_negate&lt;_Predicate&gt;(__pred);} 
</span><span class='line'>inline binary_negate&lt;_Predicate&gt; // 实际效果：!pred(param1,param2)
</span><span class='line'>not2(const _Predicate& __pred){ return binary_negate&lt;_Predicate&gt;(__pred); }
</span><span class='line'>inline binder1st&lt;_Operation&gt; // 实际效果：op(x,param)
</span><span class='line'>bind1st(const _Operation& __fn, const _Tp& __x) {
</span><span class='line'>  return binder1st&lt;_Operation&gt;(__fn, _Arg1_type(__x));
</span><span class='line'>}
</span><span class='line'>inline binder2nd&lt;_Operation&gt; // 实际效果：op(param,x)
</span><span class='line'>bind2nd(const _Operation& __fn, const _Tp& __x) { 
</span><span class='line'>  return binder2nd&lt;_Operation&gt;(__fn, _Arg2_type(__x));
</span><span class='line'>}
</span><span class='line'>inline unary_compose&lt;_Operation1,_Operation2&gt; // 实际效果：op1(op2(param))
</span><span class='line'>compose1(const _Operation1& __fn1, const _Operation2& __fn2) {
</span><span class='line'>  return unary_compose&lt;_Operation1,_Operation2&gt;(__fn1, __fn2);
</span><span class='line'>}
</span><span class='line'>inline binary_compose&lt;_Operation1, _Operation2, _Operation3&gt; // 实际效果：op1(op2(param),op3(param))
</span><span class='line'>compose2(const _Operation1& __fn1, const _Operation2& __fn2, const _Operation3& __fn3) {
</span><span class='line'>  return binary_compose&lt;_Operation1,_Operation2,_Operation3&gt;
</span><span class='line'>    (__fn1, __fn2, __fn3);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>用于函数指针的 <code>ptr_fun</code> 适配器使得我们可以将一般函数当做仿函数使用，就像原生指针可以当做迭代器传给STL算法一样，它的实际效果相当如 <code>fp(param)</code> 或 <code>fp(param1,param2)</code> ，前者定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;class _Arg, class _Result&gt;
</span><span class='line'>class pointer_to_unary_function : public unary_function&lt;_Arg, _Result&gt; {
</span><span class='line'>protected:
</span><span class='line'>  _Result (*_M_ptr)(_Arg);
</span><span class='line'>public:
</span><span class='line'>  pointer_to_unary_function() {}
</span><span class='line'>  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
</span><span class='line'>  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
</span><span class='line'>};
</span><span class='line'>template &lt;class _Arg, class _Result&gt;
</span><span class='line'>inline pointer_to_unary_function&lt;_Arg, _Result&gt; // 返回值型别
</span><span class='line'>ptr_fun(_Result (*__x)(_Arg)) { // 对pointer_to_unary_function 的封装
</span><span class='line'>  return pointer_to_unary_function&lt;_Arg, _Result&gt;(__x);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>用于成员函数指针的 <code>mem_fun</code> 适配器使得我们可以将成员函数当做仿函数使用，于是成员函数可以搭配各种泛型算法，而当使用父类的虚拟成员函数作为仿函数时，还可以使用泛型算法完成所谓的多态调用（polymorphic function call），这是泛型（genericity）与多态（polymorphism）之间的结合。另外需要注意的是，虽然多态可以对指针或引用起作用，但STL容器只支持“实值语意”，不支持“引用语意”，及容器的内容应该为实值而非引用（类似于<code>vecotr&lt;X&amp;&gt; vc</code> 这种）。一下是 <code>mem_fun</code> 的具体定义（还有很多个版本，这里只是最简单的一个）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 无任何参数，通过pointer调用，non-const成员函数
</span><span class='line'>template &lt;class _Ret, class _Tp&gt;
</span><span class='line'>class mem_fun_t : public unary_function&lt;_Tp*,_Ret&gt; {
</span><span class='line'>public:
</span><span class='line'>  explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
</span><span class='line'>  _Ret operator()(_Tp* __p) const { return (__p-&gt;*_M_f)(); }
</span><span class='line'>private:
</span><span class='line'>  _Ret (_Tp::*_M_f)();
</span><span class='line'>};
</span><span class='line'>template &lt;class _Ret, class _Tp&gt;
</span><span class='line'>inline mem_fun_t&lt;_Ret,_Tp&gt; // 返回类型
</span><span class='line'>mem_fun(_Ret (_Tp::*__f)()) { return mem_fun_t&lt;_Ret,_Tp&gt;(__f); } // mem_fun_t的匿名对象</span></code></pre></td></tr></table></div></figure>


<h2>推荐阅读：</h2>

<p><a href="http://sourcemaking.com/design_patterns/adapter">Adapter Design Pattern</a></p>
</div>
<div id="copyleft" class="well" >
	<span>Original Link: <a rel="full-article" href="">http://ibillxia.github.io/blog/2014/11/23/insight-into-stl-7-adaptor/</a></br>
	Attribution - NON-Commercial - ShareAlike - Copyright &copy; <a href="http://about.me/ibillxia">Bill Xia</a> <span>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn"><a href="http://about.me/ibillxia">Bill Xia</a></span></span>

      








  


<time datetime="2014-11-23T20:21:00+08:00" pubdate data-updated="true">Nov 23<span>rd</span>, 2014</time>
		
		
		
		  <span class="categories">Posted in <a class='category' href='/blog/categories/program/'>Program</a></span>
		
		
		  <span class="tags">Tagged with <a class='tag' href='/blog/tags/c-plus-plus/'>C++</a>, <a class='tag' href='/blog/tags/stl/'>STL</a>, <a class='tag' href='/blog/tags/adaptor/'>adaptor</a></span>
		
    </p>
    
      
         <!-- JiaThis Button BEGIN --><div class="jiathis_style_32x32">	<a class="jiathis_button_weixin"></a>	<a class="jiathis_button_qzone"></a>	<a class="jiathis_button_douban"></a>	<a class="jiathis_button_tsina"></a>	<a class="jiathis_button_renren"></a>	<a class="jiathis_button_tqq"></a>	<a class="jiathis_button_fb"></a>	<a class="jiathis_button_twitter"></a>	<a class="jiathis_button_tumblr"></a>	<a class="jiathis_button_googleplus"></a>	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>	<a class="jiathis_counter_style"></a></div><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1362901762548695" charset="utf-8"></script><!-- JiaThis Button END -->
      
    
	</br>
	 <ul class="pager">
      
      <li class="previous"><a class="basic-alignment left"
        href="/blog/2014/11/15/insight-into-stl-6-functor-or-function-objects/" title="Previous Post:
        深入理解STL源码(6) 仿函数|函数对象">&laquo; 深入理解STL源码(6) 仿函数|函数对象</a></li>
      
      <li><a href="/blog/archives">Blog Archives</a></li>
      
      <li class="next"><a class="basic-alignment right" href="/blog/2014/11/26/insight-into-stl-archive/"
        title="Next Post: 深入理解STL源码系列文章归档">深入理解STL源码系列文章归档
        &raquo;</a></li>
      
    </ul>
    
    <section>
      <h1>Comments</h1>
      <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
    </section>
    
   
  </footer>
</article>

<aside class="sidebar-nav span3">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo" class="page-footer"><p id = "back-top">
	<a href="#top"><span></span>Back to Top</a>
</p>
<hr>
<p>
  Copyright &copy; 2009 - 2015 - <a href="http://about.me/ibillxia">Bill Xia</a> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> - Theme by <a href="https://github.com/bkutil/bootstrap-theme">bootstrap-theme</a> </span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'ibillxia';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://ibillxia.github.io/blog/2014/11/23/insight-into-stl-7-adaptor/';
        var disqus_url = 'http://ibillxia.github.io/blog/2014/11/23/insight-into-stl-7-adaptor/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
