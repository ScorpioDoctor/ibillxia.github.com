<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Technics | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/categories/technics/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2015-03-31T21:07:57+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Koding——一个惊艳的在线编程开发平台]]></title>
    <link href="http://ibillxia.github.io/blog/2014/03/01/koding-an-amazing-online-development-environment/"/>
    <updated>2014-03-01T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/03/01/koding-an-amazing-online-development-environment</id>
    <content type="html"><![CDATA[<p>最近在v2ex上发现了一个非常酷的云编程发开平台——Koding，与大家分享一下，主要介绍一下它的基本功能和操作。</p>


<h2>What is Koding?</h2>


<p>Koding是一个在线的编程开发平台，致力于简化全球化的合作项目开发，并为每个人提供免费计算和开发资源。它已不仅仅是一个在线的编辑器那么简单，
而是通过提供免费的虚拟机（vm），上面安装了ubuntu操作系统，有真实的终端，允许开发者进行go、nodejs、ruby、python、php、js、C/C++等语言的开发，
可以安装各种工具和应用，。更主要的是，它是完全在线的，可以从世界上的任何地方访问，只需要一个浏览器。不仅如此，他还具有完美的社交功能，
可以和团队成员在线协作。</p>


<center>{% img /images/2014/IMAG2014030101.png %}</center>


<!--more-->




<h2>Activity Feed</h2>


<p>在Koding的<a href="https://koding.com/Activity">Activity面板</a>，是用户间交流的媒介，在这里可以看到一系列的状态更新、代码片段或用户动态。在这里你可以
创建主题，参与某些主题的讨论，可以关注他人，基本的社交功能都一应俱全。</p>




<h2>Development on Koding</h2>


<p>这是Koding的主体部分。在这里你可以像在本地计算机进行开发一样，当然这个可以在线操作，可以实现云同步，随时随地都可以访问，有木有很高大上？
在这里你可以导入自己的GitHub项目，在浏览器中进行项目开发，可以向GitHub push你的项目更新。这里有在线终端，有在线文本编辑器，还有内置浏览器。
除了和在本地编程开发一样的功能以外，还可以自行配置和添加vm，设置自己的独立域名等。下面我们来看看vm的一些硬件参数，主要是cpu、内存、硬盘、网络等。</p>


<p>硬件信息概要，要加sudo使用根权限并输入密码，不加short参数可以查看详细信息
``` sh
ibillxia@vm-0:~$ sudo lshw -short
[sudo] password for ibillxia:</p>

<h1>H/W path    Device   Class      Description</h1>

<pre><code>                 system     Computer
</code></pre>

<p>/0                   bus        Motherboard
/0/0                 memory     15GiB System memory
/0/1                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/2                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/3                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/4                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/5                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/6                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/7                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/8                 processor  Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
/0/100               bridge     440FX - 82441FX PMC [Natoma]
/0/100/1             bridge     82371SB PIIX3 ISA [Natoma/Triton II]
/0/100/1.1           storage    82371SB PIIX3 IDE [Natoma/Triton II]
/0/100/1.2           bus        82371SB PIIX3 USB [Natoma/Triton II]
/0/100/1.3           bridge     82371AB/EB/MB PIIX4 ACPI
/0/100/2             display    GD 5446
/0/100/3             network    Virtio network device
/0/100/4             storage    Virtio block device
/0/100/5             memory     RAM memory
/1          eth0     network    Ethernet interface
/2          gretap0  network    Ethernet interface
<code>
查看cpu信息，E5-2630 8核2.30GHz，本文只摘取第1个核的信息
</code> sh
ibillxia@vm-0:~$ cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 45
model name      : Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz
stepping        : 7
microcode       : 0x1
cpu MHz         : 2299.998
cache size      : 4096 KB
physical id     : 0
siblings        : 1
core id         : 0
cpu cores       : 1
apicid          : 0
initial apicid  : 0
fpu             : yes
fpu_exception   : yes
cpuid level     : 13
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt aes xsave avx hyperv
isor lahf_lm xsaveopt
bogomips        : 4599.99
clflush size    : 64
cache_alignment : 64
address sizes   : 40 bits physical, 48 bits virtual
power management:
<code>
查看内存信息，共16GB内存
</code> sh
ibillxia@vm-0:~$ cat /proc/meminfo                                                                                                                                                                                                                           <br/>
MemTotal:       16433708 kB
MemFree:         8506472 kB
Buffers:          332884 kB
Cached:          5334908 kB
SwapCached:            0 kB
Active:          3936496 kB
Inactive:        2222980 kB
Active(anon):    2093920 kB
Inactive(anon):    10856 kB
Active(file):    1842576 kB
Inactive(file):  2212124 kB
Unevictable:        5552 kB
Mlocked:            5552 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:                 0 kB
Writeback:             8 kB
AnonPages:        482832 kB
Mapped:            41668 kB
Shmem:           1623556 kB
Slab:            1522048 kB
SReclaimable:    1225180 kB
SUnreclaim:       296868 kB
KernelStack:        6312 kB
PageTables:        84660 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:     8216852 kB
Committed_AS:    5225664 kB
VmallocTotal:   34359738367 kB
VmallocUsed:       45688 kB
VmallocChunk:   34359561000 kB
HardwareCorrupted:     0 kB
AnonHugePages:     18432 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:      245748 kB
DirectMap2M:     7094272 kB
DirectMap1G:     9437184 kB
<code>
硬盘测速，才219kB/s，不是一般的慢啊
</code> sh
ibillxia@vm-0:~$ dd if=/dev/zero of=test bs=64k count=2k oflag=dsync
2048+0 records in
2048+0 records out
134217728 bytes (134 MB) copied, 612.942 s, 219 kB/s
<code>
网速测试，一般般
</code> sh
ibillxia@vm-0:~$ ping www.github.com  # 测试1
PING github.com (192.30.252.129) 56(84) bytes of data.
64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=1 ttl=54 time=73.2 ms
64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=2 ttl=54 time=75.9 ms
64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=3 ttl=54 time=72.4 ms
64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=4 ttl=54 time=72.3 ms
64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=5 ttl=54 time=66.2 ms
64 bytes from ip1b-lb3-prd.iad.github.com (192.30.252.129): icmp_req=6 ttl=54 time=66.1 ms
^C
--- github.com ping statistics ---
6 packets transmitted, 6 received, 0% packet loss, time 5001ms
rtt min/avg/max/mdev = 66.117/71.077/75.947/3.656 ms
ibillxia@vm-0:~$ ping www.stackoverflow.com    # 测试2
PING stackoverflow.com (198.252.206.140) 56(84) bytes of data.
64 bytes from stackoverflow.com (198.252.206.140): icmp_req=1 ttl=49 time=76.1 ms
64 bytes from stackoverflow.com (198.252.206.140): icmp_req=2 ttl=49 time=88.4 ms
64 bytes from stackoverflow.com (198.252.206.140): icmp_req=3 ttl=49 time=75.1 ms
64 bytes from stackoverflow.com (198.252.206.140): icmp_req=4 ttl=49 time=75.1 ms
64 bytes from stackoverflow.com (198.252.206.140): icmp_req=5 ttl=49 time=75.3 ms
64 bytes from stackoverflow.com (198.252.206.140): icmp_req=6 ttl=49 time=82.6 ms
^C
--- stackoverflow.com ping statistics ---
6 packets transmitted, 6 received, 0% packet loss, time 5005ms
rtt min/avg/max/mdev = 75.130/78.813/88.437/5.061 ms
ibillxia@vm-0:~$ ping www.facebook.com     # 测试3
PING star.c10r.facebook.com (31.13.77.81) 56(84) bytes of data.
64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=1 ttl=81 time=153 ms
64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=2 ttl=81 time=153 ms
64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=3 ttl=81 time=153 ms
64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=4 ttl=81 time=153 ms
64 bytes from edge-star-shv-06-sjc1.facebook.com (31.13.77.81): icmp_req=5 ttl=81 time=153 ms
^C
--- star.c10r.facebook.com ping statistics ---
6 packets transmitted, 5 received, 16% packet loss, time 5006ms
rtt min/avg/max/mdev = 153.577/153.740/153.951/0.449 ms
```</p>

<p>再来看看一些系统和软件信息。</p>


<p>查看linux内核版本、系统体系结构及预安装软件版本
<code>sh
ibillxia@vm-0:~$ uname -a
Linux vm-0.ibillxia.koding.kd.io 3.13.0-5-generic #20 SMP Mon Jan 20 19:56:12 PST 2014 x86_64 x86_64 x86_64 GNU/Linux
ibillxia@vm-0:~$ git --version
git version 1.8.1.2
ibillxia@vm-0:~$ mysql --version
mysql  Ver 14.14 Distrib 5.5.32, for debian-linux-gnu (x86_64) using readline 6.2
ibillxia@vm-0:~$ apache2 -v
Server version: Apache/2.2.22 (Ubuntu)
Server built:   Jul 12 2013 13:18:14
</code>
常用编程语言版本
``` sh
ibillxia@vm-0:~$ gcc --version
gcc (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>

<p>ibillxia@vm-0:~$ g++ --version
g++ (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>

<p>ibillxia@vm-0:~$ java -version
java version "1.7.0_25"
OpenJDK Runtime Environment (IcedTea 2.3.10) (7u25-2.3.10-1ubuntu0.13.04.2)
OpenJDK 64-Bit Server VM (build 23.7-b01, mixed mode)
ibillxia@vm-0:~$ go version<br/>
go version go1.1.1 linux/amd64
ibillxia@vm-0:~$ ruby --version
ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-linux]
ibillxia@vm-0:~$ php --version
PHP 5.4.9-4ubuntu2.3 (cli) (built: Sep  4 2013 19:32:25)
Copyright (c) 1997-2012 The PHP Group
Zend Engine v2.4.0, Copyright (c) 1998-2012 Zend Technologies
ibillxia@vm-0:~$ python --version                                                                                                                                                                                                                                   <br/>
Python 2.7.4
ibillxia@vm-0:~$ perl --version</p>

<p>This is perl 5, version 14, subversion 2 (v5.14.2) built for x86_64-linux-gnu-thread-multi
(with 80 registered patches, see perl -V for more detail)</p>

<p>Copyright 1987-2011, Larry Wall</p>

<p>Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.</p>

<p>Complete documentation for Perl, including FAQ lists, should be found on
this system using "man perl" or "perldoc perl".  If you have access to the
Internet, point your browser at http://www.perl.org/, the Perl Home Page.
```</p>

<h2>Installing and Using KDApps</h2>


<p>除了系统已安装的基本应用外，用户还可以在<a href="https://koding.com/Apps">Koding/Apps</a>上选择一些官方的apps安装到自己的vm上。可以
在线绘图、编辑照片等等。</p>




<h2>Online Teamwork</h2>


<p>Koding还具有团退协作功能，你可以创建自己的group或参加到别人的group中。加入到一个team后，系统会分配你一个Session ID，通过这个ID你可以进入
到队友的vm当中，然后你们相互之间都可以看到对方的编码动态。</p>




<p>关于Koding的更多内容，请戳<a href="http://learn.koding.com/getting-started/">Learn Koding</a>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013IDF声龙语音识别技术演示]]></title>
    <link href="http://ibillxia.github.io/blog/2013/04/10/Intel-Developer-Forum-2013-Nuance-Dragon-Presentation/"/>
    <updated>2013-04-10T12:57:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/04/10/Intel-Developer-Forum-2013-Nuance-Dragon-Presentation</id>
    <content type="html"><![CDATA[<p>2013英特尔信息技术峰会(Intel Developer Forum, IDF)上，来自Nuance的声龙语音合成和识别技术的演示，中文语音识别不给力，
笑点频出啊，哈哈</p>




<p><iframe height=560 width=780 src="http://player.youku.com/embed/XNTQwNjQ0MjUy" frameborder=0 allowfullscreen></iframe></p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EFI和操作系统]]></title>
    <link href="http://ibillxia.github.io/blog/2012/09/23/EFI-and-operating-system/"/>
    <updated>2012-09-23T23:03:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2012/09/23/EFI-and-operating-system</id>
    <content type="html"><![CDATA[<p>前两天在98上看到一个帖子 windows 8 没法和linux共存？ 里面有一个概念就是EFI</p>

<h2>什么是EFI？</h2>


<p>EFI英文全称为Extensible Firmware Interface，中文译为可扩展固件接口，其主要目的是为了提供一组在 OS 加载之前（启动前）在
所有平台上一致的、正确指定的启动服务。EFI最初由Intel开发，并在2002年12月所发布1.1版，后来在2005年Intel将此规范交由UEFI论坛
来推广与发展，并更名为Unified EFI(UEFI)。</p>




<p>EFI是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，为替代BIOS的升级方案。可扩展固件接口（EFI）负责
加电自检（POST）、连系操作系统以及提供连接操作系统与硬件的接口。UEFI在EFI基础上增加与改进了加密编码（cryptography）、
网络认证（network authentication）与用户界面架构（User Interface Architecture）等方面的内容。EFI在软件层次中的位置如下图</br>
{% img /images/2012/IMAG2012092301.png %}
</p>




<!-- more -->


<h2>为什么有EFI？</h2>


<p>EFI技术源于英特尔安腾处理器（Itanium）平台的推出。安腾处理器是英特尔瞄准服务器高端市场投入近十年研发力量设计产生的
与x86系列完全不同的64位新架构。在x86系列处理器进入32位的时代，由于兼容性的原因，新的处理器(80386)保留了16位的运行方式(实模式)，
此后多次处理器的升级换代都保留了这种运行方式。甚至在含64位扩展技术的至强系列处理器中，处理器加电启动时仍然会切换到16位的
实模式下运行。英特尔将这种情况归咎于BIOS技术的发展缓慢。</p>




<p>为什么这么说呢？因为自从PC兼容机厂商通过净室的方式复制出第一套BIOS源程序，BIOS就以16位汇编代码，寄存器参数调用方式，
静态链接，以及1MB以下内存固定编址的形式存在了十几年。虽然由于各大BIOS厂商近年来的努力，有许多新元素添加到产品中，
如PnP BIOS，ACPI，传统USB设备支持等等，但BIOS的根本性质没有得到任何改变。这迫使英特尔在开发新的处理器时，都必须考虑加进
使性能大大降低的兼容模式。有人曾打了一个比喻：这就像保时捷新一代的全自排跑车，被人套上去一个蹩脚打档器。正是在这种背景下，
Intel发展了EFI技术。</p>




<h2>EFI与操作系统又有什么关系呢？</h2>


<p>上文提到EFI是BIOS的升级版，那么EFI与OS的关系是不是也和BIOS与OS的关系一样呢？</br>
要回答这个问题，我们首先得将EFI与BIOS进行一个详细的比较：</br>
（1）EFI运行于32位或64位模式，突破传统的BIOS的16位实模式，达到处理器的最大寻址；</br>
（2）EFI利用加载驱动的形式，识别及操作硬件，不同于BIOS利用挂载真实模式中断的方式增加硬件功能；</br>
（3）EFI大部分（99%）是用模块化的C语言编写的，较BIOS而言更易于实现，容错和纠错特性更强，更易于扩展；</br>
（4）EFI系统下的驱动并不是由可以直接运行在CPU上的代码组成的，而是用EFI Byte Code编写而成的（有点像Java
的Byte Code），这是一组专用于EFI驱动的虚拟机器语言，必须在EFI驱动运行环境（Driver Execution Environment，或DXE）
下被解释运行，这就保证了充分的向下兼容性；</br>
（5）UEFI内置图形驱动功能，可以提供一个高分辨率的彩色图形环境，用户进入后能用鼠标点击调整配置，一切就像操作Windows
系统下的应用软件一样简单。BIOS将不再是高手才能玩转的工具，光这一点就足以让很多菜鸟朋友心仪不已了。</br>
（6）强大的可扩展性是UEFI的另一大优点。我们都知道，当电脑出现故障导致无法进入操作系统时，我们往往要借助其他工具才能
解决问题，BIOS在诊断系统故障方面的作用实是在太小了。不过，UEFI将不会重蹈BIOS功能单一的覆辙！UEFI使用模块化设计，它在
逻辑上分为硬件控制与OS（操作系统）软件管理两部分，硬件控制为所有UEFI版本所共有，而OS软件管理其实是一个可编程的开放接口。
借助这个接口，主板厂商可以实现各种丰富的功能。比如我们熟悉的各种备份及诊断功能可通过UEFI加以实现，主板或固件厂商可以
将它们作为自身产品的一大卖点。如果你更习惯让别人来维护机器，UEFI也可提供强大的联网功能，其他用户可以对你的主机进行
可靠的远程故障诊断，而这一切并不需要进入操作系统！
</p>




<p>由以上比较可知，EFI在开机时的作用和BIOS一样，就是初始化PC，但在细节上却有很多不一样。BIOS对PC的初始化，只是按照
一定的顺序对硬件通电，简单地检查硬件是否能工作，而EFI不但检查硬件的完好性，还会加载硬件在EFI中的驱动程序，不用操作
系统负责驱动的加载工作。 对于很多非专业人士而言，EFI的最革命之处，就在于颠 覆了BIOS的界面概念，让操作界面和Windows
一样易于上手。在EFI的操作界面中，鼠标成为了替代键盘的输入工具，各功能调节的模块也做的和Windows程序一样，可以说，EFI
就是一个小型化的Windows系统。</p>




<p>说EFI是一个小型化的Windows系统，毫不夸张。EFI在概念上非常类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力。
不少人感觉它的不断发展将有可能代替现代的操作系统。事实上，EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以
威胁操作系统的统治地位。首先，它只是硬件和预启动软件间的接口规范；其次，EFI环境下不提供中断的机制，也就是说每个EFI
驱动程序必须用轮询(polling)的方式来检查硬件状态，并且需要以解释的方式运行，较操作系统下的机械码驱动效率更低；再则，
EFI系统不提供复杂的缓存器保护功能，它只具备简单的缓存器管理机制，具体来说就是指运行在x86处理器的段保护模式下，以最大
寻址能力为限把缓存器分为一个平坦的段(Segment)，所有的程序都有权限访问任何一段位置，并不提供真实的保护服务。当EFI所有
组件加载完毕时，系统可以开启一个类似于操作系统Shell的命令解释环境，在这里，用户可以调入执行任何EFI应用程序，这些程序
可以是硬件检测及除错软件，引导管理，设置软件，操作系统引导软件等等。理论上来说，对于EFI应用程序的功能并没有任何限制，
任何人都可以编写这类软件，并且效果较以前MS-DOS下的软件更华丽，功能更强大。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[伪造IP地址的原理]]></title>
    <link href="http://ibillxia.github.io/blog/2010/08/31/the-elements-of-ip-faking/"/>
    <updated>2010-08-31T09:41:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2010/08/31/the-elements-of-ip-faking</id>
    <content type="html"><![CDATA[<p>入侵者使用假IP地址发送包，利用基于IP地址证实的应用程序。其结果是未授权的远端用户进入带有防火墙的主机系统。</p>




<p>假设有两台主机A、B和入侵者控制的主机X。假设B授予A某些特权，使得A能够获得B所执行的一些操作。X的目标就是得到与B相同的权利。
为了实现该目标，X必须执行两步操作：首先，与B建立一个虚假连接；然后，阻止A向B报告网络证实系统的问题。主机X必须假造A的IP地址，
从而使B相信从X发来的包的确是从A发来的。</p>




<p>我们同时假设主机A和B之间的通信遵守TCP／IP的三次握手机制。握手方法是：</p>


<p>{% codeblock %}
A->：SYN（序列号=M）
B->A：SYN（序列号＝N），ACK（应答序号=M+1）
A->B：ACK（应答序号＝N+1）
{% endcodeblock %}</p>

<!--more-->


<p>主机X伪造IP地址步骤如下：首先，X冒充A，向主机B发送一个带有随机序列号的SYN包。主机B响应，向主机A发送一个带有应答号的SYN+ACK包、
该应答号等于原序列号加1。同时，主机B产生自己发送包序列号，并将其与应答号一起发送。为了完成三次握手，主机X需要向主</p>




<p>机B回送一个应答包，其应答号等于主机B向主机A发送的包序列号加1。假设主机X与A和B不同在一个子网内，则不能检测到B的包，
主机X只有算出B的序列号，才能创建TCP连接。其过程描述如下：</p>


<p>{% codeblock %}
X->B：SYN（序列号=M），SRC=A
B->A：SYN（序列号=N），ACK（应答号=M+1）
X->B：ACK（应答号＝N+1），SRC＝A
{% endcodeblock %}</p>

<p>同时，主机X应该阻止主机A响应主机B的包。为此，X可以等到主机A因某种原因终止运行，或者阻塞主机A的操作系统协议部分，使它不能响应主机B。
一旦主机X完成了以上操作，它就可以向主机B发送命令。主机B将执行这些命令，认为他们是由合法主机A发来的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UTF8中文编码范围]]></title>
    <link href="http://ibillxia.github.io/blog/2010/08/21/utf8-chinese-coding/"/>
    <updated>2010-08-21T10:31:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2010/08/21/utf8-chinese-coding</id>
    <content type="html"><![CDATA[<p>UTF-8有点类似于Haffman编码，它将Unicode编码为： </br>
00000000-0000007F的字符，用单个字节来表示； </br>
00000080-000007FF的字符用两个字节表示 （中文的编码范围） </br>
00000800-0000FFFF的字符用3字节表示</br>
编码转换：iconv -f “文件目前编码” -t “文件转换后的编码” -o “转换后生成的新文件名” “源文件名”temp = Iconv.conv("UTF-8","gb2312",a) </p>




<p>因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。 
在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节
和GB编码的两个字节是不同的）。 </p>


<!--more-->


<h2>big endian和little endian</h2>


<p>我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。</p>




<p>“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，
由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。</p>




<p>big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，
还是将49写在前面？如果将6C写在前面，就是big endian。而如果将49写在前面，就是little endian。</p>




<h2>UTF编码</h2>


<p>UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下：</br>

UCS-2编码(16进制) UTF-8 字节流(二进制)</br>
0000 - 007F 0xxxxxxx</br>
0080 - 07FF 110xxxxx 10xxxxxx</br>
0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx </p>




<p>例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。
将6C49写成二进制是：0110 110001 001001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>




<p>读者可以用记事本测试一下我们的编码是否正确。</p>




<p>UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，
定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。
但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>




<h2>UTF的字节序和BOM</h2>


<p>UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。
例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？</p>




<p>Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：</br>

在UCS编码中有一个叫做"ZERO WIDTH NO-BREAK SPACE"的字符，它的编码是FEFF。
而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。</br>
UCS规范建议我们在传输字节流前，先传输字符"ZERO WIDTH NO-BREAK SPACE"。</p>




<p>这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。
因此字符"ZERO WIDTH NO-BREAK SPACE"又被称作BOM。</p>




<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符"ZERO WIDTH NO-BREAK SPACE"的UTF-8编码是EF BB BF（读者
可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</p>




<p>Windows就是使用BOM来标记文本文件的编码方式的。</p>



]]></content>
  </entry>
  
</feed>
