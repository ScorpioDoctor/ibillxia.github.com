<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: container | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/container/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-11-10T23:44:04+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.5) 关联式容器之hashset和hashmap]]></title>
    <link href="http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap/"/>
    <updated>2014-09-27T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hash_set.h</code>、<code>stl_hash_map.h</code> 等文件。</p>

<h2>1. hashset 和 hash_multi_set</h2>

<p>需要说明的是，STL 标准只规范了复杂度与接口，并没有规范实现方法，但 STL 实现的版本中 set 大多以 RB-tree 为底层机制，SGI STL 在实现了以 RB-tree 为底层机制的 set 外，还实现了以 hashtable 为底层机制的 hashset。<br/>
和 set 一样，hashset 的键值（key）和实值（value）是同一个字段，不同的是 set 默认是自动排序的，而 hashset 则是无序的。除此之外，hashset 与 set 的对外接口完全相同。<br/>
这里还有一种称为 hash_multi_set 的集合，它同 multiset 类似，允许键值重复，而上面的 hashset 则不允许。下面是 hashset 的定义的主要代码：</p>

<!-- more -->


<p>```
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
class hash_set {
private:
  typedef hashtable&lt;<em>Value, </em>Value, <em>HashFcn, </em>Identity<_Value>, <em>EqualKey, </em>Alloc> <em>Ht;
  </em>Ht <em>M_ht; // 底层容器的定义
public:
  hash_set() : </em>M_ht(100, hasher(), key_equal(), allocator_type()) {} // 构造函数
  iterator find(const key_type&amp; <strong>key) const { return _M_ht.find(</strong>key); } // 查找
  size_type count(const key_type&amp; <strong>key) const { return _M_ht.count(</strong>key); } // 计数
  size_type size() const { return <em>M_ht.size(); } // 表格大小
  size_type max_size() const { return </em>M_ht.max_size(); }
  bool empty() const { return <em>M_ht.empty(); } // 是否为空
  void swap(hash_set&amp; __hs) { </em>M_ht.swap(<strong>hs.<em>M_ht); } // 交换
  iterator begin() const { return </em>M_ht.begin(); }
  iterator end() const { return _M_ht.end(); }
  pair&lt;iterator, bool> insert(const value_type&amp; </strong>obj){ // 插入</p>

<pre><code>  pair&lt;typename _Ht::iterator, bool&gt; __p = _M_ht.insert_unique(__obj);
  return pair&lt;iterator,bool&gt;(__p.first, __p.second);
</code></pre>

<p>  }
  size_type erase(const key_type&amp; <strong>key) {return _M_ht.erase(</strong>key); } // 擦除
  void erase(iterator <strong>it) { _M_ht.erase(</strong>it); }
  void erase(iterator <strong>f, iterator </strong>l) { <em>M_ht.erase(<strong>f, </strong>l); }
  void clear() { </em>M_ht.clear(); } // 清空
};
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
inline bool operator==(const hash_set&lt;<em>Value,</em>HashFcn,<em>EqualKey,</em>Alloc>&amp; __hs1,</p>

<pre><code>       const hash_set&lt;_Value,_HashFcn,_EqualKey,_Alloc&gt;&amp; __hs2) {
</code></pre>

<p>  return <strong>hs1._M_ht == </strong>hs2._M_ht;
}
```</p>

<h2>2. hashmap 和 hash_multi_map</h2>

<p>hashmap 是以 hashtable 为底层容器的 map，而 map 是同时拥有实值（value）和键值（key），且不允许键值重复。<br/>
而 hash_multi_map 是以 hashtable 为底层容器的 map，且允许键值重复。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.4) 关联式容器之hashtable]]></title>
    <link href="http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable/"/>
    <updated>2014-09-13T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hashtable.h</code>、<code>stl_hash_fun.h</code> 等文件。</p>

<h2>1. hashtable 简介</h2>

<p>在数据结构中我们知道，有种数据结构的插入、删除、查找等操作的性能是常数时间，但需要比元素个数更多的空间，这种数据结构就是哈希表。哈希表的基本思想是，将数据存储在与其数值大小相关的地方，比如对该数取模，然后存储在以余数为下表的数组中。但这样会出现一个问题，就是可能会有多个数据被映射到同一个存储位置，即出现了所谓的“碰撞”。哈希表的主要内容就是解决“碰撞”问题，一般而言有以下几种方法：线性探测、二次探测、开链等。</p>

<h4>线性探测</h4>

<p>简单而言，就是在出现“碰撞”后，寻找当前位置以后的空档，然后存入。如果找到尾部都没有空档，则从头部重新开始找。只要空间大小比元素个数大，总能找到的。相应的，元素的查找和删除也与普通的数组不同，查找如果直接定位到相应位置并找到或是空档，就可以确定存在或不存在，而如果定位到当前位置非空且与待查找的元素不同，则要依序寻找后续位置的元素，直到找到或移到了空档。删除则是采用懒惰删除策略，即只标记删除记号，实际删除操作则待表格重新整理时再进行。</p>

<h4>二次探测</h4>

<p>与线性探测类似，但向后寻找的策略是探测距当前位置为平方数的位置，即 $index = H+i<em><sup>{2}$</sup> </em>。但这样会有一个问题，那就是能否保证每次探测的是不同的位置，即是否存在某次插入时，探测完一圈后回到自己而出现死循环。</p>

<h4>开链</h4>

<p>这种方法是将出现冲突的元素放在一个链表中，而哈希表中只存储这些链表的首地址。SGI STL中就是使用这种方法来解决“碰撞”的。</p>

<h2>2. hashtable 的数据结构</h2>

<p>由于使用开链的方法解决冲突，所以要维护两种数据结构，一个是 hash table，在 STL 中称为 buckets，用 vector 作为容器；另一个是链表，这里没有使用 list 或 slist 这些现成的数据结构，而是使用自定义 <code>__hashtable_node</code> ，相关定义具体如下：</p>

<!-- more -->


<p><code>
template &lt;class _Val&gt;
struct _Hashtable_node { // 链表节点的定义
  _Hashtable_node* _M_next; // 指向下一个节点
  _Val _M_val;
};
template &lt;class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc&gt;
class hashtable {
private:
  typedef _HashFcn hasher;
  hasher                _M_hash; // 哈希函数
  typedef _Hashtable_node&lt;_Val&gt; _Node; // 节点类型别名定义
  vector&lt;_Node*,_Alloc&gt; _M_buckets; // hash table，存储链表的索引
};
</code>
这里 hashtable 的模板参数很多，其含义如下：</p>

<blockquote><p><em>Val: 节点的实值类型
</em>Key: 节点的键值类型
<em>HashFcn: 哈希函数的类型
</em>ExtractKey: 从节点中取出键值的方法（函数或仿函数）
<em>EqualKey: 判断键值相同与否的方法（函数或仿函数）
</em>Alloc: 空间配置器，默认使用 std::alloc</p></blockquote>

<p>虽然开链法并不要求哈希表的大小为质数，但 SGI STL 仍然以质数来设计表的大小，并将28个质数（大约2倍依次递增）计算好，并提供函数来查询其中最接近某数并大于某数的质数，如下：<br/>
<code>
enum { __stl_num_primes = 28 };
static const unsigned long __stl_prime_list[__stl_num_primes] = {
  53ul,         97ul,         193ul,       389ul,       769ul,
  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
  1610612741ul, 3221225473ul, 4294967291ul
}; // 使用无符号长整型（32bit）
inline unsigned long __stl_next_prime(unsigned long __n) {
  const unsigned long* __first = __stl_prime_list;
  const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes;
  const unsigned long* pos = lower_bound(__first, __last, __n); // lower_bound 是泛型算法，后续会介绍
  return pos == __last ? *(__last - 1) : *pos;
}
</code></p>

<h2>3. hashtable 的空间配置</h2>

<h4>节点空间配置</h4>

<p>首先只考虑比较简单的情况，即哈希表的大小不需要调整，此时空间配置主要是链表节点的配置，而 hashtable 使用 vector 作为容器，链表节点的空间配置（分配和释放）如下：<br/>
```
typedef simple_alloc&lt;<em>Node, </em>Alloc> <em>M_node_allocator_type;
</em>Node<em> <em>M_get_node() { return </em>M_node_allocator_type::allocate(1); } // 分配一个节点的空间
void <em>M_put_node(</em>Node</em> <strong>p) { _M_node_allocator_type::deallocate(</strong>p, 1); } // 释放一个节点的空间
<em>Node* </em>M_new_node(const value_type&amp; __obj) {</p>

<pre><code>_Node* __n = _M_get_node();
__n-&gt;_M_next = 0;
__STL_TRY {
    construct(&amp;__n-&gt;_M_val, __obj);
    return __n;
}
__STL_UNWIND(_M_put_node(__n));
</code></pre>

<p>}
void <em>M_delete_node(</em>Node* __n) {</p>

<pre><code>destroy(&amp;__n-&gt;_M_val);
_M_put_node(__n);
</code></pre>

<p>}
```</p>

<h4>插入操作表格重新整理</h4>

<p>哈希表的插入操作有两个问题要考虑，一个是 是否允许插入相同键值的元素，另一个是 是否需要扩充表的大小。在 STL 中，首先是判断新插入一个元素后是否需要扩充，判断的条件是插入后元素的个数大于当前哈希表的大小；而是否允许元素重复则通过提供 <code>insert_unique</code> 和 <code>insert_equal</code> 来解决。相关代码如下：<br/>
```
pair&lt;iterator, bool> insert_unique(const value_type&amp; __obj) {</p>

<pre><code>resize(_M_num_elements + 1); // 先进行扩充（如有必要）
return insert_unique_noresize(__obj); // 然后插入
</code></pre>

<p>}
iterator insert_equal(const value_type&amp; __obj) {</p>

<pre><code>resize(_M_num_elements + 1);
return insert_equal_noresize(__obj);
</code></pre>

<p>}
void hashtable&lt;<em>Val,</em>Key,<em>HF,</em>Ex,<em>Eq,</em>All>::resize(size_type <strong>num_elements_hint) { // 扩充表格
  const size_type </strong>old_n = _M_buckets.size();
  if (<strong>num_elements_hint > </strong>old_n) { // 判断是否需要扩充</p>

<pre><code>const size_type __n = _M_next_size(__num_elements_hint); // 下一个质数
if (__n &gt; __old_n) {
  vector&lt;_Node*, _All&gt; __tmp(__n, (_Node*)(0), _M_buckets.get_allocator()); // 新的buckets
  __STL_TRY {
    for (size_type __bucket = 0; __bucket &lt; __old_n; ++__bucket) { // 遍历旧的buckets
      _Node* __first = _M_buckets[__bucket];
      while (__first) { // 处理每一个链表
        size_type __new_bucket = _M_bkt_num(__first-&gt;_M_val, __n); // 确定当前节点落在新buckets中的位置
        _M_buckets[__bucket] = __first-&gt;_M_next; // 指向下一个节点
        __first-&gt;_M_next = __tmp[__new_bucket]; // 在新buckets的新索引位置头部插入
        __tmp[__new_bucket] = __first;
        __first = _M_buckets[__bucket]; // 指向旧链表下一个节点
      }
    }
    _M_buckets.swap(__tmp); // 交换新旧buckets，退出后临时buckets __tmp 自动释放
  }
}
</code></pre>

<p>  }
}
template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool>
hashtable&lt;<em>Val,</em>Key,<em>HF,</em>Ex,<em>Eq,</em>All>::insert_unique_noresize(const value_type&amp; <strong>obj) { // 不允许键值重复
  const size_type </strong>n = <em>M_bkt_num(__obj);
  </em>Node<em> <strong>first = _M_buckets[</strong>n];
  for (_Node</em> <strong>cur = </strong>first; <strong>cur; </strong>cur = <em>_cur-></em>M_next)</p>

<pre><code>if (_M_equals(_M_get_key(__cur-&gt;_M_val), _M_get_key(__obj))) // 判断是否存在重复的key
  return pair&lt;iterator, bool&gt;(iterator(__cur, this), false); 
</code></pre>

<p>  <em>Node* __tmp = </em>M_new_node(<strong>obj);
  </strong>tmp-><em>M_next = __first;
  </em>M_buckets[<strong>n] = </strong>tmp;
  ++_M_num_elements;
  return pair&lt;iterator, bool>(iterator(__tmp, this), true);
}
```
允许键值重复的插入操作类似的，只是为了确保相同键值的挨在一起，先要找到相同键值的位置，然后插入。</p>

<h4>整体复制和清空</h4>

<p>复制和清空时分别涉及空间的分配和释放，所以在这里也介绍一下。首先是复制操作，需要先将目标 hashtable 清空，然后将源 hashtable 的 buckets 中的每个链表一一复制，如下：<br/>
```
template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable&lt;<em>Val,</em>Key,<em>HF,</em>Ex,<em>Eq,</em>All>::<em>M_copy_from(const hashtable&amp; __ht) {
  </em>M_buckets.clear(); // 先清空目标 hashtable
  <em>M_buckets.reserve(__ht.</em>M_buckets.size()); // 大小重置为源 hashtable 的大小
  <em>M_buckets.insert(</em>M_buckets.end(), <strong>ht.<em>M_buckets.size(), (</em>Node*) 0); // 将目标 hashtable 的 buckets 置空
  </strong>STL_TRY {</p>

<pre><code>for (size_type __i = 0; __i &lt; __ht._M_buckets.size(); ++__i) { // 遍历 buckets
  const _Node* __cur = __ht._M_buckets[__i];
  if (__cur) {
    _Node* __copy = _M_new_node(__cur-&gt;_M_val);
    _M_buckets[__i] = __copy;
    for (_Node* __next = __cur-&gt;_M_next; __next; __cur = __next,
            __next = __cur-&gt;_M_next) { // 复制每个节点
      __copy-&gt;_M_next = _M_new_node(__next-&gt;_M_val);
      __copy = __copy-&gt;_M_next;
    }
  }
}
_M_num_elements = __ht._M_num_elements;
</code></pre>

<p>  }
  __STL_UNWIND(clear());
}
```</p>

<h2>4. hashtable 的迭代器</h2>

<p>hashtable 的迭代器是前向的单向迭代器，遍历的方式是先遍历完一个 list 然后切换到下一个 bucket 指向的 list 进行遍历。以下是 hashtable 的迭代器的定义：<br/>
```
template <class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc>
struct <em>Hashtable_iterator {
  typedef hashtable&lt;</em>Val,<em>Key,</em>HashFcn,<em>ExtractKey,</em>EqualKey,<em>Alloc> </em>Hashtable;
  typedef <em>Hashtable_iterator&lt;</em>Val, <em>Key, </em>HashFcn, <em>ExtractKey, </em>EqualKey, <em>Alloc> iterator;
  typedef </em>Hashtable_const_iterator&lt;<em>Val, </em>Key, <em>HashFcn, </em>ExtractKey, <em>EqualKey, </em>Alloc> const_iterator;
  typedef <em>Hashtable_node<_Val> </em>Node;</p>

<p>  <em>Node* </em>M_cur; // 指向当前节点
  <em>Hashtable* </em>M_ht; // 指向当前节点所在 bucket</p>

<p>  <em>Hashtable_iterator(</em>Node<em> <em>_n, </em>Hashtable</em> <strong>tab) : _M_cur(</strong>n), <em>M_ht(__tab) {}
  </em>Hashtable_iterator() {}
  reference operator<em>() const { return <em>M_cur-></em>M_val; }
  iterator&amp; operator++();
  iterator operator++(int);
  bool operator==(const iterator&amp; <strong>it) const { return _M_cur == </strong>it.<em>M_cur; }
  bool operator!=(const iterator&amp; __it) const { return </em>M_cur != <em><em>it.</em>M_cur; }
};
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
</em>Hashtable_iterator&lt;<em>Val,</em>Key,<em>HF,</em>ExK,<em>EqK,</em>All>&amp;
<em>Hashtable_iterator&lt;</em>Val,<em>Key,</em>HF,<em>ExK,</em>EqK,<em>All>::operator++(){
  const </em>Node</em> <em><em>old = </em>M_cur;
  </em>M_cur = <em>M_cur-></em>M_next;
  if (!_M_cur) { // 到了当前 bucket 的尾部</p>

<pre><code>size_type __bucket = _M_ht-&gt;_M_bkt_num(__old-&gt;_M_val);
while (!_M_cur &amp;&amp; ++__bucket &lt; _M_ht-&gt;_M_buckets.size())
  _M_cur = _M_ht-&gt;_M_buckets[__bucket];
</code></pre>

<p>  }
  return *this;
}
```</p>

<h2>5. 哈希函数</h2>

<p>在第三节中介绍 hashtable 的数据结构时，提到了一个哈希函数类型的模板参数，从键值到索引位置的映射由这个哈希函数来完成，实际中是通过函数 <code>_M_bkt_num_key</code> 来完成这个映射的，如下：<br/>
```
size_type _M_bkt_num_key(const key_type&amp; __key) const {</p>

<pre><code>return _M_bkt_num_key(__key, _M_buckets.size());
</code></pre>

<p>}
size_type _M_bkt_num_key(const key_type&amp; <strong>key, size_t </strong>n) const {</p>

<pre><code>return _M_hash(__key) % __n; // 在这里调用函数 _M_hash，实现映射
</code></pre>

<p>}
<code>
这里的 `_M_hash` 是一个哈希函数类型的成员，可以看做是一个函数指针，真正的函数的定义在 `&lt;stl_hash_fun.h&gt;` 中，针对 char，int，long 等整数型别，这里大部分的 hash function 什么也没做，只是重视返回原始值，但对字符串（const char* ）设计了一个转换函数，如下：  
</code>
template <class _Key> struct hash { }; // 仿函数 hash
inline size_t <strong>stl_hash_string(const char* </strong>s) { // 将字符串映射为整型
  unsigned long <strong>h = 0;
  for ( ; *</strong>s; ++__s)</p>

<pre><code>__h = 5*__h + *__s;
</code></pre>

<p>  return size_t(<strong>h);
}
</strong>STL_TEMPLATE_NULL struct hash&lt;char<em>> {
  size_t operator()(const char</em> <strong>s) const { return </strong>stl_hash_string(<strong>s); } // 函数调用操作符 operator()
};
</strong>STL_TEMPLATE_NULL struct hash<const char*> {
  size_t operator()(const char* <strong>s) const { return </strong>stl_hash_string(<strong>s); }
};
</strong>STL_TEMPLATE_NULL struct hash<char> {
  size_t operator()(char <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<unsigned char> {
  size_t operator()(unsigned char </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<signed char> {
  size_t operator()(unsigned char <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<short> {
  size_t operator()(short </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned short> {
  size_t operator()(unsigned short <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<int> {
  size_t operator()(int </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned int> {
  size_t operator()(unsigned int <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<long> {
  size_t operator()(long </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned long> {
  size_t operator()(unsigned long <strong>x) const { return </strong>x; }
};
```
关于函数调用操作符的更多介绍，可以参见我的另一篇文章 【<a href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/">C语言函数指针与C++函数调用操作符</a>】。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.3) 关联式容器之map和multimap]]></title>
    <link href="http://ibillxia.github.io/blog/2014/08/31/insight-into-stl-4-associative-containers-3-map-and-multimap/"/>
    <updated>2014-08-31T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/08/31/insight-into-stl-4-associative-containers-3-map-and-multimap</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_map.h</code>、<code>stl_multimap.h</code>、<code>stl_pair.h</code>、<code>map.h</code>、 <code>multimap.h</code>、 <code>map</code>  等文件。</p>

<h2>1. map 简介</h2>

<p>map 的特性是，所有元素都是键值对，用一个 pair 表示，pair 的第一个元素是键值（key），第二个元素是实值（value），map 不允许两个元素的键值相同。<br/>
与 set 类似的，map 也不允许修改 key 的值，但不同的是可以修改 value 的值，因此 map 的迭代器既不是一种 constant iterators，也不是一种 mutable iterators。同样的，map的插入和删除操作不影响操作之前定义的迭代器的使用（被删除的那个元素除外）。<br/>
与 set 不同的是，map 没有交、并、差等运算，只有插入、删除、查找、比较等基本操作。</p>

<h2>2. map 的实现</h2>

<p>由于 map 的元素是键值对，用 pair 表示，下面是它的定义：<br/>
<code>
template &lt;class _T1, class _T2&gt;
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;
  _T1 first; // 两个成员 first 和 second
  _T2 second;
  pair() : first(_T1()), second(_T2()) {} // 构造函数
  pair(const _T1&amp; __a, const _T2&amp; __b) : first(__a), second(__b) {} // 拷贝构造函数
};
template &lt;class _T1, class _T2&gt;
inline bool operator==(const pair&lt;_T1, _T2&gt;&amp; __x, const pair&lt;_T1, _T2&gt;&amp; __y) { // 相等比较
  return __x.first == __y.first &amp;&amp; __x.second == __y.second;
}
template &lt;class _T1, class _T2&gt;
inline bool operator&lt;(const pair&lt;_T1, _T2&gt;&amp; __x, const pair&lt;_T1, _T2&gt;&amp; __y) { // 大小比较
  return __x.first &lt; __y.first || (!(__y.first &lt; __x.first) &amp;&amp; __x.second &lt; __y.second);
}
template &lt;class _T1, class _T2&gt;
inline pair&lt;_T1, _T2&gt; make_pair(const _T1&amp; __x, const _T2&amp; __y) { // 创建一个 pair
  return pair&lt;_T1, _T2&gt;(__x, __y);
}
</code></p>

<!-- more -->


<p>然后是 map 的定义，大体上和 set 差不多，只是在使用 RB-tree 作为容器时，传入的模板参数是一个 pair，主要代码如下：<br/>
```
template <class _Key, class _Tp, class _Compare, class _Alloc>
class map {
public:
  typedef <em>Key                  key_type;
  typedef </em>Tp                   data_type;
  typedef <em>Tp                   mapped_type;
  typedef pair<const _Key, _Tp> value_type;
  typedef </em>Compare              key_compare;
  // 一个用于键值比较的内部类
  class value_compare : public binary_function&lt;value_type, value_type, bool> {
  friend class map&lt;<em>Key,</em>Tp,<em>Compare,</em>Alloc>;
  protected :</p>

<pre><code>_Compare comp;
value_compare(_Compare __c) : comp(__c) {}
</code></pre>

<p>  public:</p>

<pre><code>bool operator()(const value_type&amp; __x, const value_type&amp; __y) const {
  return comp(__x.first, __y.first);
}
</code></pre>

<p>  };
private:
  typedef <em>Rb_tree&lt;key_type, value_type, </em>Select1st<value_type>,</p>

<pre><code>key_compare, _Alloc&gt; _Rep_type; // 这里的value_type是一个pair&lt;const _Key, _Tp&gt;
</code></pre>

<p>  <em>Rep_type </em>M_t;  // 用红黑树作为底层容器
public:
  map() : <em>M_t(</em>Compare(), allocator_type()) {} // 默认构造函数
  bool empty() const { return <em>M_t.empty(); } // 判断是否为空
  size_type size() const { return </em>M_t.size(); } // 获取元素个数
  map(const value_type<em> __first, const value_type</em> __last)</p>

<pre><code>: _M_t(_Compare(), allocator_type())
{ _M_t.insert_unique(__first, __last); } // 构造函数，使用insert_unique，键值不允许重复
</code></pre>

<p>  void insert(const value_type<em> __first, const value_type</em> __last) { // 插入操作</p>

<pre><code>_M_t.insert_unique(__first, __last);
</code></pre>

<p>  }
  void erase(iterator <strong>position) { _M_t.erase(</strong>position); } // 删除操作
  iterator find(const key_type&amp; <strong>x) { return _M_t.find(</strong>x); } // 查找操作
};
```
可以看到，基本也是对底层容器 RB-tree 的一个简单的封装。</p>

<h2>3. multimap</h2>

<p>multimap 与 map 的关系和 multiset 与 set 的关系一样，即 multimap 允许键值（key）重复，插入操作使用 RB-tree 的 <code>insert_equal</code> ，其他都和 map 一样，这里就不贴源代码了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.2) 关联式容器之set和multiset]]></title>
    <link href="http://ibillxia.github.io/blog/2014/08/17/insight-into-stl-4-associative-containers-2-set-and-multiset/"/>
    <updated>2014-08-17T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/08/17/insight-into-stl-4-associative-containers-2-set-and-multiset</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要有 <code>stl_set.h</code>、 <code>stl_multiset.h</code>、 <code>set.h</code>、 <code>multiset.h</code>、 <code>set</code> 等文件。</p>

<h2>1. set 简介</h2>

<p>set 即集合，相比于其他容器有些特别。首先是它的每个元素是唯一的，即不允许有相同的值出现。其次，作为一种关联容器，set 的元素不像 map 那样可以同时拥有实值（value）和键值（key），set 元素的键值就是实值，实值就是键值。<br/>
由于 set 的实质和键值相同，共用同一个内存空间，而 set 的底层容器为红黑树（中序遍历有序），因此不能对其键值进行修改，否则会破坏其有序特性。为避免非法修改操作，在SGI STL的实现中，<code>set&lt;T&gt;::iterator</code> 被定义为 RB-tree 底层的 const_iterator，_杜绝写入操作。set 与 list 有一个相似的地方是，元素插入、删除后，之前的迭代器依然有效（被删除的那个元素的迭代器除外）。<br/>
我们知道集合有一些特殊的操作，诸如并、交、差等，在STL的 set 中，默认也提供了这些操作，如交集 <code>set_intersection</code> 、联集 <code>set_union</code> 、差集 <code>set_difference</code> 和对称差集 <code>set_symmetric_difference</code> 等。与之前那些线性容器不同的是，这些 set 的操作并不是在 set 内部实现的，而是放在了算法模块（algorithm）中，其具体实现在后面的算法章节中会具体介绍。</p>

<h2>2. set 的实现</h2>

<p>前面多次提到 set 的底层采用 RB-tree 容器，这是因为 RB-tree 是一种比较高效的平衡二叉搜索树，能够很好的满足元素值唯一的条件，而且查找效率高。由于 RB-tree 已实现了很多操作，因此 set 基本上只是对 RB-tree 进行了一层简单的封装。下面是其实现的主要代码：</p>

<!-- more -->


<p>```
template <class _Key, class _Compare, class _Alloc>
class set {
public:
  typedef <em>Key     key_type;
  typedef </em>Key     value_type; // 实值与键值同类型
private:
  typedef <em>Rb_tree&lt;key_type, value_type, </em>Identity<value_type>, key_compare, <em>Alloc> </em>Rep_type;
  <em>Rep_type </em>M_t;  // 底层使用红黑树作为容器
  set() : <em>M_t(</em>Compare(), allocator_type()) {} // 默认构造函数
  set(const set&lt;<em>Key,</em>Compare,<em>Alloc>&amp; __x) : </em>M_t(<strong>x._M_t) {}  // 拷贝构造函数
  pair&lt;iterator,bool> insert(const value_type&amp; </strong>x) { // 插入操作</p>

<pre><code>pair&lt;typename _Rep_type::iterator, bool&gt; __p = _M_t.insert_unique(__x); 
return pair&lt;iterator, bool&gt;(__p.first, __p.second);
</code></pre>

<p>  }
  void erase(iterator __position) { // 删除操作</p>

<pre><code>typedef typename _Rep_type::iterator _Rep_iterator;
_M_t.erase((_Rep_iterator&amp;)__position); 
</code></pre>

<p>  }
  void clear() { <em>M_t.clear(); } // 清空操作
  iterator find(const key_type&amp; __x) const { return </em>M_t.find(<strong>x); } // 查找
  size_type count(const key_type&amp; </strong>x) const { // 计数</p>

<pre><code>return _M_t.find(__x) == _M_t.end() ? 0 : 1;
</code></pre>

<p>  }
};
template <class _Key, class _Compare, class _Alloc>
inline bool operator==(const set&lt;<em>Key,</em>Compare,_Alloc>&amp; __x,</p>

<pre><code>                   const set&lt;_Key,_Compare,_Alloc&gt;&amp; __y) { // 比较相等操作符
</code></pre>

<p>  return <strong>x._M_t == </strong>y.<em>M_t;
}
template <class _Key, class _Compare, class _Alloc>
inline bool operator&lt;(const set&lt;</em>Key,<em>Compare,</em>Alloc>&amp; __x,</p>

<pre><code>                  const set&lt;_Key,_Compare,_Alloc&gt;&amp; __y) { // 比较大小操作符
</code></pre>

<p>  return <strong>x._M_t &lt; </strong>y.<em>M_t;
}
<code>``
可以看到基本都是调用</code></em>M_t<code>的方法来实现的，而这里的</code>_M_t` 是一个红黑树对象。</p>

<h2>3. multiset</h2>

<p>multiset 的特性和用法与 set 基本相同，唯一差别在于它允许有重复的键值，因此它的插入操作使用的底层机制是 RB-tree 的 <code>insert_equal()</code> 而不是 <code>insert_unique()</code> ，下面是 multiset 的主要代码，主要列出了与 set 不同的部分。<br/>
```
template <class _Key, class _Compare, class _Alloc>
class multiset {
public:
  multiset(const value_type<em> __first, const value_type</em> __last)</p>

<pre><code>: _M_t(_Compare(), allocator_type())
{ _M_t.insert_equal(__first, __last); } // 构造函数
</code></pre>

<p>  iterator insert(const value_type&amp; __x) { // 插入操作</p>

<pre><code>return _M_t.insert_equal(__x);
</code></pre>

<p>  }
  iterator insert(iterator <strong>position, const value_type&amp; </strong>x) {</p>

<pre><code>typedef typename _Rep_type::iterator _Rep_iterator;
return _M_t.insert_equal((_Rep_iterator&amp;)__position, __x);
</code></pre>

<p>  }
  void insert(const value_type<em> __first, const value_type</em> __last) {</p>

<pre><code>_M_t.insert_equal(__first, __last);
</code></pre>

<p>  }
  void insert(const_iterator <strong>first, const_iterator </strong>last) {</p>

<pre><code>_M_t.insert_equal(__first, __last);
</code></pre>

<p>  }
};
```
其他部分基本与 set 一样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.1) 关联式容器之红黑树]]></title>
    <link href="http://ibillxia.github.io/blog/2014/08/03/insight-into-stl-4-associative-containers-1-red-black-tree/"/>
    <updated>2014-08-03T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/08/03/insight-into-stl-4-associative-containers-1-red-black-tree</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_tree.h</code> 这个文件。</p>

<h2>0. 关联式容器</h2>

<p>之前几篇文章详细介绍了SGI STL中序列式容器的实现，并提到过STL中还有一类关联式的容器。标准的STL管理师容器分为 set（集合）和map（映射表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表），这些容器的底层机制均以RB-Tree（红黑树）完成。RB-Tree是一种非常高效的数据结构，它本质上是一种平衡的二叉搜索树，因而其查找的平均时间复杂度为元素总个数的对数（即logN）。在STL中RB-Tree是一个独立的容器，但并没有对用户的公开接口，仅提供给STL的set和map使用。<br/>
SGI STL在标准STL之外，还提供了一类关联式容器——hash table（哈希表），以及以此为低层机制的hash set（散列集合）、hash map（散列映射表）、hash multiset（散列多键集合）和hash multimap（散列多键映射表）。相比于RB-Tree，hash table的时间效率更高，插入、删除、查找的时间复杂度均为常数时间，但需要比元素总个数多得多的空间。<br/>
本文接下来主要介绍树及RB-Tree相关的内容，后续文章将具体介绍SGI STL中set、map、hash table的实现。</p>

<h2>1. 树与二叉搜索树</h2>

<p>树是一种非常常见而且实用的数据结构，几乎所有的操作系统都将文件存放在树状结构里，几乎所有编译器需要实现一个表达式树（expression tree），文件压缩所用的哈夫曼算法也需要用到树状结构，数据库所使用的B-tree则是一种相当复杂的树状结构。<br/>
关于树的一些基本概念相信大家都比较熟悉，这里就不赘述了，如果需要可以google或看wikipedia，这里重点重温一下数据结构里的二叉搜索树、平衡二叉搜索树、AVL树。<br/>
<strong>二叉搜索树</strong>：任何节点的键值大于其<strong>左子树</strong>中<strong>每一个</strong>节点的键值，并小于其<strong>右子树</strong>中的<strong>每一个</strong>节点的键值。根据二叉搜索树的定义可知，按照中序遍历该树可以得到一个有序的序列。平均情况下，二叉搜索树可以提供对数时间的插入和访问。其插入和查找的算法也很简单，每次与根节点的键值进行比较，小于根节点的键值则往根节点的左子树插入或查找，大于则往右子树插入或查找，无论是递归实现还是非递归实现都很简单。<br/>
<strong>平衡二叉搜索树</strong>：上面提到二叉搜索数的<strong>平均</strong>性能为对数时间，这是因为二叉搜索树的深度与数据插入的顺序有关，如果插入的数据本身就比较有序，那么就会产生一个深度过大的树，甚至会退化为一个链表的结构，这中情况下，其查找的效率就是线性时间了。平衡二叉搜索树就是为了解决这个问题而产生的，“平衡”的意义是，没有任何一个节点过深。不同的平衡条件造就出不同的效率表现，以及不同的实现复杂度，如 <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL-Tree</a>、<a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">RB-Tree</a>、<a href="http://en.wikipedia.org/wiki/AA_tree">AA-Tree</a> _等。他们都比简单的二叉搜索树要复杂，特别是插入和删除操作，但他们可以避免高度不平衡的情况，因而查找时间较快。</p>

<!-- more -->


<p><strong>AVL树</strong>：AVL-tree（Adelson-Velskii-Landis tree）是一个加上了“额外平衡条件”的二叉搜索树，是一种高度平衡的二叉搜索树，它的这个额外的条件为：任何节点的左右子树高度相差最多1。该条件能够保证整棵树的高度为logN，但其插入和删除的操作也相对比较复杂，因为这些操作可能导致树的失衡，需要调整（或旋转）树的结构，使其保持平衡。插入时出现失衡的情况有如下四种（其中X为最小失衡子树的根节点）：</p>

<blockquote><ol>
<li>插入点位于X的左子节点的左子树——左左；</li>
<li>插入点位于X的左子节点的右子树——左右；</li>
<li>插入点位于X的右子节点的左子树——右左；</li>
<li>插入点位于X的右子节点的右子树——右右。</li>
</ol>
</blockquote>

<p>情况1和4对称，称为外侧插入，可以采用单旋转操作调整恢复平衡；2和3对称，称为内侧插入，可以采用双旋转操作调整恢复平衡：先经过一次旋转变成左左或右右，然后再经过一次旋转恢复平衡。1和2的实例如下图：<br/>
<img src="/images/2014/IMAG2014080301.jpg"><br/>
图中从中间到最右情况1的恢复平衡的旋转方法，只是其中节点3为新插入的元素；而最左到最右是情况2的恢复平衡的旋转方法，其中节点4为新插入的元素。情况3和4分别与2和1对称，其调整方法也很类似，就不赘述了。<br/>
RB-tree是另一种被广泛使用的平衡二叉搜索树，也是SGI STL唯一实现的一种搜索树，作为关联式容器的底层容器。RB-tree的平衡条件不同于AVL-tree，但同样运用了单旋转和双旋转的恢复平衡的机制，下面我们详细介绍RB-tree的实现。</p>

<h2>2. RB-tree的定义及数据结构</h2>

<p>所谓RB-tree，不仅仅是一个二叉搜索树，而且必须满足以下规则：</p>

<blockquote><ol>
<li>每个节点不是红色就是黑色；</li>
<li>根节点为黑色；</li>
<li>每个叶子节点（NIL）为黑色；</li>
<li>如果节点为红，其左右子节点必为黑；</li>
<li>对每个节点，从该节点到其子孙中的叶子节点的所有路径上所包含的黑节点数目相同。</li>
</ol>
</blockquote>

<p>上面的这些约束保证了这个树大致上是平衡的，这也决定了红黑树的插入、删除、查询等操作是比较快速的。 根据规则5，新增节点必须为红色；根据规则4，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形。下图是一个典型的RB-tree（来自wiki）：<br/>
<img src="/images/2014/IMAG2014080302.png"><br/>
SGI STL中RB-tree的数据结构比较简单，其中每个节点的数据结构如下：
```
typedef bool <em>Rb_tree_Color_type;
const </em>Rb_tree_Color_type <em>S_rb_tree_red = false;
const </em>Rb_tree_Color_type <em>S_rb_tree_black = true;
//======================================
struct </em>Rb_tree_node_base { // 节点的定义
  typedef <em>Rb_tree_Color_type </em>Color_type;
  typedef <em>Rb_tree_node_base* </em>Base_ptr;
  <em>Color_type </em>M_color; // 节点颜色，实际为一个bool型变量
  <em>Base_ptr </em>M_parent; // 指向父节点，方便遍历
  <em>Base_ptr </em>M_left;
  <em>Base_ptr </em>M_right;</p>

<p>  static <em>Base_ptr </em>S_minimum(_Base_ptr __x) {</p>

<pre><code>while (__x-&gt;_M_left != 0) __x = __x-&gt;_M_left;
return __x;
</code></pre>

<p>  }
  static <em>Base_ptr </em>S_maximum(_Base_ptr __x) {</p>

<pre><code>while (__x-&gt;_M_right != 0) __x = __x-&gt;_M_right;
return __x;
</code></pre>

<p>  }
};
//======================================
template <class _Value> struct <em>Rb_tree_node : public </em>Rb_tree_node_base { // 节点的定义
  typedef <em>Rb_tree_node<_Value>* </em>Link_type;
  <em>Value </em>M_value_field;
};
<code>
其中每个节点主要包含一个标志颜色的bool变量 `_M_color`，3个节点指针 `_M_parent` , `_M_left` , `_M_right`，2个成员函数 `_S_minimum` 和 `_S_maximum` （分别求取最小（最左）、最大（最右）节点）。  
而RB-tree的定义如下：  
</code>
template <class _Tp, class _Alloc> struct <em>Rb_tree_base { // RB-tree的定义
  typedef </em>Alloc allocator_type;
  allocator_type get_allocator() const { return allocator_type(); }
  <em>Rb_tree_base(const allocator_type&amp;)  : </em>M_header(0) { <em>M_header = </em>M_get_node(); } // 构造函数
  ~<em>Rb_tree_base() { </em>M_put_node(<em>M_header); } // 析构函数
protected:
  </em>Rb_tree_node<_Tp><em> <em>M_header; // 根节点
  typedef simple_alloc&lt;</em>Rb_tree_node<_Tp>, <em>Alloc> </em>Alloc_type; // 空间配置器
  _Rb_tree_node<_Tp></em> <em>M_get_node()  { return </em>Alloc_type::allocate(1); } // 分配一个节点的空间
  void <em>M_put_node(</em>Rb_tree_node<_Tp>* <strong>p) { _Alloc_type::deallocate(</strong>p, 1); } // 释放<em><em>p节点的空间
};
//======================================
template &lt;class </em>Key, class </em>Value, class <em>KeyOfValue, class </em>Compare,</p>

<pre><code>      class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) &gt;
</code></pre>

<p>class <em>Rb_tree : protected </em>Rb_tree_base&lt;<em>Value, </em>Alloc> {
  typedef <em>Rb_tree_base&lt;</em>Value, <em>Alloc> </em>Base;
// ...
};
<code>``
可以看到RB-tree的空间配置器是</code>simple_alloc<code>配置器，按</code>_Rb_tree_node` 节点大小分配空间，每次分配或释放一个节点的空间。</p>

<h2>3. RB-tree的迭代器</h2>

<p>要将RB-tree实现为一个泛型容器并用作set、map的低层容器，迭代器的设计是一个关键。RB-tree的迭代器是一个双向迭代器，但不具备随机访问能力，其引用（dereference）和访问（access）操作与list十分类似，较为特殊的是自增（operator++）和自减（operator--）操作，这里的自增/自减操作是指将迭代器移动到RB-tree按键值大小排序后当前节点的下一个/上一个节点，也即按中序遍历RB-tree时当前节点的下一个/上一个节点。RB-tree的迭代器的定义如下： <br/>
<code>
struct _Rb_tree_base_iterator {
  typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
  typedef bidirectional_iterator_tag iterator_category;
  void _M_increment()  { }
  void _M_decrement()  { }
};
template &lt;class _Value, class _Ref, class _Ptr&gt;
struct _Rb_tree_iterator : public _Rb_tree_base_iterator {
  _Self&amp; operator++() { _M_increment(); return *this; }
  _Self&amp; operator--() { _M_decrement(); return *this; }
};
</code>
可以看到RB-tree的自增和自减操作是使用基迭代器的increment和decrement来实现的，这里仅分析自增操作的实现（自减操作类似的）。RB-tree的自增操作实际上是寻找中序遍历下当前节点的后一个节点，其代码如下：<br/>
```
  void _M_increment()  { // 自增操作，中序遍历的下一个节点</p>

<pre><code>if (_M_node-&gt;_M_right != 0) { // 当前节点有右子树
  _M_node = _M_node-&gt;_M_right;
  while (_M_node-&gt;_M_left != 0) // 右子树的最左节点即为所求
    _M_node = _M_node-&gt;_M_left;
} else { // 当前节点没有右子树，找父节点且父节点的右子树不包含当前节点的祖先节点
  _Base_ptr __y = _M_node-&gt;_M_parent;
  while (_M_node == __y-&gt;_M_right) { // 当前节点在父节点的右子树中就继续往父节点的父节点找
    _M_node = __y;
    __y = __y-&gt;_M_parent;
  }
  if (_M_node-&gt;_M_right != __y)
    _M_node = __y;
}
</code></pre>

<p>  }
```<br/>
下面几节主要介绍一下RB-tree的基本操作。</p>

<h2>4. RB-tree的插入操作</h2>

<h4>4.1 基本插入操作</h4>

<p>RB-tree提供两种插入操作，<code>insert_unique()</code> 和 <code>insert_equal()</code>，顾名思义，前者表示被插入的节点的键值在树中是唯一的（如果已经存在，就不需要插入了），后者表示可以存在键值相同的节点。这两个函数都有多个版本，下面以后者的最简单版本（单一参数：被插入的节点的键值）为实例进行介绍。下面是 <code>insert_equal</code> 的实现：
```
<em>Rb_tree&lt;</em>Key,<em>Value,</em>KeyOfValue,<em>Compare,</em>Alloc> ::insert_equal(const <em>Value&amp; __v) {
  </em>Link_type <strong>y = <em>M_header;
  </em>Link_type </strong>x = _M_root(); // 从根节点开始
  while (__x != 0) { // 往下寻找插入点</p>

<pre><code>__y = __x;
// 比较，当前节点的键值比插入值大往左子树找，否则往右子树找
__x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? _S_left(__x) : _S_right(__x); 
</code></pre>

<p>  }
  return <em>M_insert(<strong>x, </strong>y, __v); // 真正的插入操作，x为新插入节点，y为x的父节点，v为新值
}
//真正的插入操作，主要是对RB-tree及新节点的成员变量的设置
</em>Rb_tree&lt;<em>Key,</em>Value,<em>KeyOfValue,</em>Compare,<em>Alloc> ::</em>M_insert(<em>Base_ptr __x</em>, <em>Base_ptr __y</em>, const <em>Value&amp; __v) {
  </em>Link_type <strong>x = (_Link_type) </strong>x<em>;
  </em>Link_type <strong>y = (_Link_type) </strong>y<em>;
  </em>Link_type <strong>z;
  if (</strong>y == <em>M_header || __x != 0 || </em>M_key_compare(<em>KeyOfValue()(__v), </em>S_key(__y))) {</p>

<pre><code>__z = _M_create_node(__v); // 创建新节点
_S_left(__y) = __z;     // makes _M_leftmost() = __z, when __y == _M_header
if (__y == _M_header) { // y为header
  _M_root() = __z;
  _M_rightmost() = __z;
} else if (__y == _M_leftmost()) // y为最左节点
  _M_leftmost() = __z;  // maintain _M_leftmost() pointing to min node
</code></pre>

<p>  } else {</p>

<pre><code>__z = _M_create_node(__v); // 创建新节点。???为什么不放到if-else上面???
_S_right(__y) = __z; // 新节点为y的右孩子
if (__y == _M_rightmost()) // y为最右节点
  _M_rightmost() = __z; // maintain _M_rightmost() pointing to max node
</code></pre>

<p>  }
  <em>S_parent(<strong>z) = </strong>y; // 设定新节点的父节点
  </em>S_left(<strong>z) = 0;
  _S_right(</strong>z) = 0;
  <em>Rb_tree_rebalance(__z, </em>M_header-><em>M_parent); // 调整RB-tree使之恢复平衡
  ++</em>M_node_count;
  return iterator(<em>_z); // 返回指向新节点的迭代器
}
<code>``
至此新节点插入完成。然而，由于新节点的插入，可能会引起RB-tree的性质4,5的破坏，需要对RB-tree进行旋转并对相关节点重新着色，这都是在</code></em>Rb_tree_rebalance` 这个函数中实现的，下面就主要介绍RB-tree是如何恢复平衡。</p>

<h4>4.2 调整RB-tree使之恢复平衡</h4>

<p>RB-tree的调整与AVL-tree类似但更复杂，因为不仅仅需要旋转，还需要考虑节点的颜色是否符合要求。破坏RB-tree性质4的可能起因是插入了一个红色节点、将一个黑色节点变为红色或者是旋转，而破坏性质5的可能原因是插入一个黑色的节点、节点颜色的改变（红变黑或黑变红）或者是旋转。<br/>
在讨论 RB-tree 插入操作之前必须明白一点，那就是新插入的节点的颜色必为红色（调整前），因为插入黑点会增加某条路径上黑结点的数目，从而导致整棵树黑高度的不平衡。但如果新结点的父结点为红色时（如下图所示），将会违反红黑树的性质：一条路径上不能出现父子同为红色结点。这时就需要通过一系列操作来使红黑树保持平衡。为了清楚地表示插入操作以下在结点中使用“N”字表示一个新插入的结点，使用“P”字表示新插入点的父结点，使用“U”字表示“P”结点的兄弟结点，使用“G”字表示“P”结点的父结点。插入操作分为以下几种情况：<br/>
<strong>1）、树为空</strong><br/>
此时，新插入节点为根节点，上面说过新插入节点均为红色，这不符合RB-tree的性质2，只需要将新节点重新改为黑色即可。<br/>
<strong>2）、黑父</strong><br/>
如果新节点的父结点为黑色结点，那么插入一个红点将不会影响红黑树的平衡，此时插入操作完成。红黑树比AVL树优秀的地方之一在于黑父的情况比较常见，从而使红黑树需要旋转的几率相对AVL树来说会少一些。<br/>
<strong>3）、红父</strong><br/>
这种情况就比较复杂。由于父节点为红，所以祖父节点必为黑色。由于新节点和父节点均为红，所以需要重新着色或进行旋转，此时就需要考虑叔父节点的颜色，进而可能需要考虑祖父、祖先节点的颜色。
<strong>3.1）、叔父为红</strong>
只要将父和叔结点变为黑色，将祖父结点变为红色即可，如下图所示：<br/>
<img src="/images/2014/IMAG2014080303.png"><br/>
但由于祖父结点的父结点有可能为红色，从而违反红黑树性质。此时必须将祖父结点作为新的判定点<strong>继续向上</strong>（迭代）进行平衡操作。<br/>
<strong>3.2）、叔父为黑</strong><br/>
当叔父结点为黑色时，需要进行旋转，有4中情况（类似AVL），以下图示了所有的旋转可能：<br/>
<img src="/images/2014/IMAG2014080304.png"><br/>
可以观察到，当旋转完成后，新的旋转根全部为黑色，此时不需要再向上回溯进行平衡操作，插入操作完成。篇幅原因，相关代码这里就不粘贴出来了，要注意的一点就是case1和case2的变色方案是一样的，虽然从上图中看一个是P由红变黑，一个是N由红变黑，但实际上在case2中，经过一次旋转后，迭代器所指向的节点已经发生改变，这样刚好使得这两个case的变色方案相同，均为P由红变黑而G由黑变红。case3与case4的变色方案也是类似的。</p>

<h2>5. RB-tree的删除操作</h2>

<p>相比于插入操作，RB-tree的删除操作更加复杂。在侯捷的书上并没有讲删除操作，而在算法导论上是有专门的一节内容的，wiki上也有详细的讲述。限于篇幅，这里指讲解一个大概的思路，更详细的介绍请参见wiki或算法导论。RB-tree删除操作的基本思路是这样的，首先按照一般的二叉搜索树进行节点的删除，然后对RB-tree相关节点进行变色或旋转。<br/>
一般的二叉搜索树删除节点的基本思路是：首先找到待删除节点位置，设为D。如果D同时有左右子树，那么用D的后继（右孩子的最左子节点，该后继最多有一个子节点——右孩子）替代D（<strong>注意</strong>：这里的替代是只key的替代，color不变，仍为D的color），从而将删除位置转移到该后继节点（成为新的D，为叶子节点或只有右孩子）。于是，我们只需要讨论删除只有一个儿子的节点的情况(如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子)，设这个儿子节点为N，这仍然需要分三种情况：<br/>
<strong>1）D为红</strong><br/>
这种情况比较简单。由于D为红色，所以它的父亲和儿子一定是黑色的，我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。<br/>
  <strong>2）D为黑且N为红</strong><br/>
如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，可能会破坏性质4，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5，同时也满足性质4。<br/>
<strong>3）D为黑且N为黑</strong><br/>
这是一种复杂的情况。我们首先把要删除的节点D替换为它的（右）儿子N，在新树中（D被N覆盖），设N的父节点为P，兄弟为S，SL为S的左儿子，SR为S的右儿子。此时，以N为根节点的子树的黑高度减少了一，与S为根节点的子树的黑高度不一致，破坏了性质5。为了恢复，可以分为如下情形：<br/>
<strong>3.1）N为根节点</strong><br/>
已经满足所有性质，不需要调整。<br/>
<strong>3.2） N是它父亲P的左儿子</strong><br/>
<strong>case1、S为红色</strong>：将P改为红色，S改为黑色，以P为中心左旋，旋转后<strong>SL为新的S</strong>，SL和SR是新的S的左右孩子，此时case1就转化为了case2或case3或case4；<br/>
注：case2~4中S均为黑色（否则是case1）。<br/>
<strong>case2、SL、SR同为黑色</strong>：将S改为红色，这样黑高度失衡的节点变为P，转到3.1）重新开始判断和调整；<br/>
<strong>case3、SR为黑</strong>：此时SL为红（否则是case2）。将S改为红色，SL改为黑色，然后以S为中心右旋，旋转后SL为新的S，而原S成为SR且为红色，这就将case3变成了case4；<br/>
<strong>case4、SR为红</strong>：以P为中心左旋，然后交换P和S的颜色，最后将SR改为黑色，即可完成调整。可以看到调整过程与SL的颜色无关。<br/>
<strong>3.3）N是它父亲P的右儿子</strong><br/>
与3.2）类似，这里就不详细展开了。</p>

<h2>6. RB-tree的查询操作</h2>

<p>RB-tree是一个二叉搜索树，元素的查询是其拿手项目，非常简单，以下是RB-tree提供的查询操作：
```
template <class _Key, class _Value, class _KeyOfValue, class _Compare, class _Alloc>
typename <em>Rb_tree&lt;</em>Key,<em>Value,</em>KeyOfValue,<em>Compare,</em>Alloc>::iterator
<em>Rb_tree&lt;</em>Key,<em>Value,</em>KeyOfValue,<em>Compare,</em>Alloc>::find(const <em>Key&amp; __k) {
  </em>Link_type <strong>y = _M_header;      // Last node which is not less than </strong>k.
  <em>Link_type __x = </em>M_root();      // Current node.</p>

<p>  while (__x != 0) // x为NIL时推出循环</p>

<pre><code>if (!_M_key_compare(_S_key(__x), __k))
  __y = __x, __x = _S_left(__x); // 往左子树找（赋值运算优先于逗号运算，y是x的父节点）
else
  __x = _S_right(__x); // 往右子树找
</code></pre>

<p>  iterator <strong>j = iterator(</strong>y); <br/>
  return (<strong>j == end() || _M_key_compare(</strong>k, <em>S_key(__j.</em>M_node))) ?</p>

<pre><code> end() : __j; // 没找到返回end()，否则返回相应节点的指针（迭代器）
</code></pre>

<p>}
```</p>

<h2>小结</h2>

<p>关于RB-tree基本就介绍到这里了，主要是RB-tree的定义、数据结构、插入删除和查找等基本操作，其中最主要也最困难的就是插入和删除操作中恢复平衡的方法。另外，还介绍了二叉搜索树的基本概念和高度平衡的AVL树，可以看到，AVL树保持平衡的方法非常简单易懂，而RB-tree由于引入了节点的颜色属性，使得理解起来相对比较困难，那么问题就来了，为什么不用AVL-tree而用RB-tree作为set和map的低层容器呢？<br/>
这个问题要问STL的实现者了，其实AVL-tree和RB-tree的平均性能在 <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL-tree的wiki</a> _上是有严格的数学公式的，AVL的平均高度为 $1.44logN$ ，而RB-tree的平均高度为 $2logN$ ，这些数据的来历也有相关的论文，感兴趣的可以更深入的看看。</p>
]]></content>
  </entry>
  
</feed>