<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: hashset | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/hashset/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-10-19T22:04:43+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.5) 关联式容器之hashset和hashmap]]></title>
    <link href="http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap/"/>
    <updated>2014-09-27T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hash_set.h</code>、<code>stl_hash_map.h</code> 等文件。</p>

<h2>1. hashset 和 hash_multi_set</h2>

<p>需要说明的是，STL 标准只规范了复杂度与接口，并没有规范实现方法，但 STL 实现的版本中 set 大多以 RB-tree 为底层机制，SGI STL 在实现了以 RB-tree 为底层机制的 set 外，还实现了以 hashtable 为底层机制的 hashset。<br/>
和 set 一样，hashset 的键值（key）和实值（value）是同一个字段，不同的是 set 默认是自动排序的，而 hashset 则是无序的。除此之外，hashset 与 set 的对外接口完全相同。<br/>
这里还有一种称为 hash_multi_set 的集合，它同 multiset 类似，允许键值重复，而上面的 hashset 则不允许。下面是 hashset 的定义的主要代码：</p>

<!-- more -->


<p>```
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
class hash_set {
private:
  typedef hashtable&lt;<em>Value, </em>Value, <em>HashFcn, </em>Identity<_Value>, <em>EqualKey, </em>Alloc> <em>Ht;
  </em>Ht <em>M_ht; // 底层容器的定义
public:
  hash_set() : </em>M_ht(100, hasher(), key_equal(), allocator_type()) {} // 构造函数
  iterator find(const key_type&amp; <strong>key) const { return _M_ht.find(</strong>key); } // 查找
  size_type count(const key_type&amp; <strong>key) const { return _M_ht.count(</strong>key); } // 计数
  size_type size() const { return <em>M_ht.size(); } // 表格大小
  size_type max_size() const { return </em>M_ht.max_size(); }
  bool empty() const { return <em>M_ht.empty(); } // 是否为空
  void swap(hash_set&amp; __hs) { </em>M_ht.swap(<strong>hs.<em>M_ht); } // 交换
  iterator begin() const { return </em>M_ht.begin(); }
  iterator end() const { return _M_ht.end(); }
  pair&lt;iterator, bool> insert(const value_type&amp; </strong>obj){ // 插入</p>

<pre><code>  pair&lt;typename _Ht::iterator, bool&gt; __p = _M_ht.insert_unique(__obj);
  return pair&lt;iterator,bool&gt;(__p.first, __p.second);
</code></pre>

<p>  }
  size_type erase(const key_type&amp; <strong>key) {return _M_ht.erase(</strong>key); } // 擦除
  void erase(iterator <strong>it) { _M_ht.erase(</strong>it); }
  void erase(iterator <strong>f, iterator </strong>l) { <em>M_ht.erase(<strong>f, </strong>l); }
  void clear() { </em>M_ht.clear(); } // 清空
};
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
inline bool operator==(const hash_set&lt;<em>Value,</em>HashFcn,<em>EqualKey,</em>Alloc>&amp; __hs1,</p>

<pre><code>       const hash_set&lt;_Value,_HashFcn,_EqualKey,_Alloc&gt;&amp; __hs2) {
</code></pre>

<p>  return <strong>hs1._M_ht == </strong>hs2._M_ht;
}
```</p>

<h2>2. hashmap 和 hash_multi_map</h2>

<p>hashmap 是以 hashtable 为底层容器的 map，而 map 是同时拥有实值（value）和键值（key），且不允许键值重复。<br/>
而 hash_multi_map 是以 hashtable 为底层容器的 map，且允许键值重复。</p>
]]></content>
  </entry>
  
</feed>