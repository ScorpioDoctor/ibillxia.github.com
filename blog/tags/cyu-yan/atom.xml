<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: C语言 | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/cyu-yan/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2015-01-09T23:56:17+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PCM WAVE格式详解及用C语言实现wave文件的读取]]></title>
    <link href="http://ibillxia.github.io/blog/2013/07/20/details-of-wave-format-and-reading-wave-files-in-C-language/"/>
    <updated>2013-07-20T20:07:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2013/07/20/details-of-wave-format-and-reading-wave-files-in-C-language</id>
    <content type="html"><![CDATA[<h2>1.PCM Wave格式详解</h2>


<p>WAVE文件格式是微软RIFF(Resource Interchange File Format,资源交换文件标准)的一种，是针对于多媒体文件存储的一种文件格式和标准。
一般而言，RIFF文件由文件头和数据两部分组成，一个WAVE文件由一个“WAVE”数据块组成，这个“WAVE”块又由一个"fmt"子数据块和一个“data”子
数据块组成，也称这种格式为“Canonical form”（权威/牧师格式），如下图所示：
<center><img src="/images/2013/IMAG2013072001.gif"></center>
</p>


<!--more-->


<p>每个字段的涵义如下：
ChunkID: 占4个字节，内容为“RIFF”的ASCII码(0x52494646)，以大端（big endian）存储。</br>
ChunkSize: 4字节，存储整个文件的字节数（不包含ChunkID和ChunkSize这8个字节），以小端（little endian）方式存储。</br>
Format: 4字节，内容为“WAVE”的ASCII码(0x57415645)，以大端存储。</br>
</p>




<p>
其中bigendian 主要有一个特征，在内存中对操作数的存储方式和从高字节到低字节。例如：0x1234，这样一个数，存储为:</br>
0x4000:   0x12</br>
0x4001:   0x34</br>
而小尾端littleendian是：</br>
0x4000:   0x34</br>
0x4001:   0x12</br>
用程序在区别的话，可以考虑：
``` c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
       union w
      {
       short int a;
       char b;
      }c;
      c.a=1;
      if( c.b==1 )  printf("little endian\n");
      else printf("big endian\n");
      system("PAUSE"); 
      return 0;
}
```
</p>




<p>"WAVE"格式由两个子数据块构成：“fmt”块和“data”块，其中“fmt”块的详细解释如下：
Subchunk1ID: 占4个字节，内容为“fmt ”的ASCII码(0x666d7420)，以大端存储。</br>
Subchunk1Size: 占4个字节，存储该子块的字节数（不含前面的Subchunk1ID和Subchunk1Size这8个字节），以小端方式存储。</br>
AudioFormat：占2个字节，以小端方式存储，存储音频文件的编码格式，例如若为PCM则其存储值为1，若为其他非PCM格式的则有一定的压缩。</br>
NumChannels: 占2个字节，以小端方式存储，通道数，单通道(Mono)值为1，双通道(Stereo)值为2，等等。</br>
SampleRate: 占4个字节，以小端方式存储，采样率，如8k，44.1k等。</br>
ByteRate: 占4个字节，以小端方式存储，每秒存储的bit数，其值=SampleRate * NumChannels * BitsPerSample/8</br>
BlockAlign: 占2个字节，以小端方式存储，块对齐大小，其值=NumChannels * BitsPerSample/8</br>
BitsPerSample: 占2个字节，以小端方式存储，每个采样点的bit数，一般为8,16,32等。</br>
接下来是两个可选的扩展参数：</br>
ExtraParamSize: 占2个字节，表示扩展段的大小。</br>
ExtraParams: 扩展段其他自定义的一些参数的具体内容，大小由前一个字段给定。
</p>




<p>其中，对于每个采样点的bit数，不同的bit数读取数据的方式不同：
``` c
// data 为读取到的采样点的值，speech为原始数据流，
//对应于下面的"WAVE"格式文件的第二个子数据块“data”块的“Data”部分。
for(i=0;i<NumSample;i++){
    if(BitsPerSample==8)
        data[i] = (int)*((char*)speech+i);
    else if(BitsPerSample==16)
        data[i] = (int)*((short*)speech+i);
    else if(BitsPerSample==32)
        data[i] = (int)*((int*)speech+i);
}
```
</p>




<p>"WAVE"格式文件的第二个子数据块是“data”，其个字段的详细解释如下：</br>
Subchunk2ID: 占4个字节，内容为“data”的ASCII码(0x64617461)，以大端存储。</br>
Subchunk2Size: 占4个字节，内容为接下来的正式的数据部分的字节数，其值=NumSamples * NumChannels * BitsPerSample/8</br>
Data: 真正的语音数据部分。</br>
</p>




<h2>一个Wave文件头的实例</h2>


<p>设一个wave文件的前72个字节的十六进制内容如下(可以使用Ultra Edit等工具查看wave文件头)：
```
52 49 46 46 24 08 00 00 57 41 56 45 66 6d 74 20 10 00 00 00 01 00 02 00 
22 56 00 00 88 58 01 00 04 00 10 00 64 61 74 61 00 08 00 00 00 00 00 00 
24 17 1e f3 3c 13 3c 14 16 f9 18 f9 34 e7 23 a6 3c f2 24 f2 11 ce 1a 0d 
```
则其个字段的解析如下图：
<center><img src="/images/2013/IMAG2013072002.gif"></center>
</p>




<h2>C语言实现wave文件的读取</h2>


<p>这里给出一个用基本的C语言文件操作库函数实现的Wave文件读取的实例代码，可以跨Windows和Linux平台。</p>


<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>// define Wave format structure
typedef struct tWAVEFORMATEX
{</p>

<pre><code>short wFormatTag;         /* format type */
short nChannels;          /* number of channels (i.e. mono, stereo...) */
unsigned int nSamplesPerSec;     /* sample rate */
unsigned int nAvgBytesPerSec;    /* for buffer estimation */
short nBlockAlign;        /* block size of data */
short wBitsPerSample;     /* number of bits per sample of mono data */
short cbSize;             /* the count in bytes of the size of */
                                /* extra information (after cbSize) */
</code></pre>

<p>} WAVEFORMATEX, *PWAVEFORMATEX;</p>

<p>char<em> wavread(char </em>fname, WAVEFORMATEX *wf);</p>

<p>int main(){</p>

<pre><code>char fname[] = "test.wav";
char *speech;
WAVEFORMATEX wf;

speech = wavread(fname, &amp;wf);
// afterward processing...

return 0;
</code></pre>

<p>}</p>

<p>// read wave file
char<em> wavread(char </em>fname, WAVEFORMATEX *wf){</p>

<pre><code>FILE* fp;
char str[32];
char *speech;
unsigned int subchunk1size; // head size
unsigned int subchunk2size; // speech data size

// check format type
fp = fopen(fname,"r");
if(!fp){
    fprintf(stderr,"Can not open the wave file: %s.\n",fname);
    return NULL;
}
fseek(fp, 8, SEEK_SET);
fread(str, sizeof(char), 7, fp);
str[7] = '\0';
if(strcmp(str,"WAVEfmt")){
    fprintf(stderr,"The file is not in WAVE format!\n");
    return NULL;
}

// read format header
fseek(fp, 16, SEEK_SET);
fread((unsigned int*)(&amp;subchunk1size),4,1,fp);
fseek(fp, 20, SEEK_SET);
fread(wf, subchunk1size, 1, fp);

// read wave data
fseek(fp, 20+subchunk1size, SEEK_SET);
fread(str, 1, 4, fp);
str[4] = '\0';
if(strcmp(str,"data")){
    fprintf(stderr,"Locating data start point failed!\n");
    return NULL;
}
fseek(fp, 20+subchunk1size+4, SEEK_SET);
fread((unsigned int*)(&amp;subchunk2size), 4, 1, fp);
speech = (char*)malloc(sizeof(char)*subchunk2size);
if(!speech){
    fprintf(stderr, "Memory alloc failed!\n");
    return NULL;
}
fseek(fp, 20+subchunk1size+8, SEEK_SET);
fread(speech, 1, subchunk2size, fp);

fclose(fp);
return speech;
</code></pre>

<p>}
```</p>

<h2>参考</h2>


<p>
[1]WAVE PCM soundfile format: https://ccrma.stanford.edu/courses/422/projects/WaveFormat/ </br>
[2]Resource Interchange File Format: http://en.wikipedia.org/wiki/Resource_Interchange_File_Format </br>
[3]基于Visual C++6.0的声音文件操作: http://www.yesky.com/20030414/1663116_1.shtml
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言输入输出缓冲区]]></title>
    <link href="http://ibillxia.github.io/blog/2009/06/05/io-buffer-in-c-language/"/>
    <updated>2009-06-05T23:02:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2009/06/05/io-buffer-in-c-language</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.csdn.net/cxyol/archive/2006/03/18/628324.aspx">http://blog.csdn.net/cxyol/archive/2006/03/18/628324.aspx</a></p>

<h2>1.输入输出缓冲区的概念（C++用的多一些）</h2>

<p>我想以一个例子说明，比如我想把一篇文章以字符序列的方式输出到计算机显示器屏幕上，那么我的程序内存作为数据源而显示器驱动程序作为数据目标，如果数据源直接对数据目标发送数据的话。数据目标获得第一个字符，便将它显示。然后从端口读取下一个字符，可是这时就不能保证数据源向端口发送的恰好是第二个字符（也许是第三个，而第二个已经在数据目标显示时发送过了）。这样的话就不能保证输出的数据能完整的被数据目标所接受并处理。</p>

<p>为了解决这个问题，我们需要在数据源与数据目标中间放置一个保存完整数据内容的区域，那就是 “缓冲区”。这样的话， 数据源可以不考虑数据目标正在处理哪部分数据，只要把数据输出到缓冲区就可以了，数据目标也可以不考虑数据源的发送频率，只是从缓冲区中依次取出下一个数据。从而保证了数据发送的完整性，同时也提高了程序的效率。</p>

<p>当然<code>getch()</code>，<code>getche()</code>没有用到缓冲区。</p>

<!-- more -->


<h2>2.几个函数的区别</h2>

<p>首先不要忘了，<strong>要用getch()必须引入头文件<code>conio.h</code> </strong>，以前学C语言的时候，我们总喜欢用在程序的末尾加上它，利用它来实现程序运行完了暂停不退出的效果。如果不加这句话，在TC2.0的环境中我们用Ctrl+F9编译并运行后，程序一运行完了就退回到TC环境中，我们根本来不及看到结果，这时要看结果，我们就要按Alt+F5回到DOS环境中去看结果，这很麻烦。而如果在程序的结尾加上一行 <code>getch();</code> 语句，我们就可以省掉会DOS看结果这个步骤，因为程序运行完了并不退出，而是在程序最后把屏幕停住了，按任意键才退回到TC环境中去。</p>

<p>那我们来看看 <code>getch()</code> 到底起的什么作用， <code>getch()</code> 实际是一个输入命令，作用是从键盘接收一个字符，而且并不把这个字符显示出来，就是说，你按了一个键后它并不在屏幕上显示你按的什么，而继续运行后面的代码，所以我们在C++中可以用它来实现“按任意键继续”的效果，即程序中遇到getch();这行语句，它就会把程序暂停下来，等你按任意键，它接收了这个字符键后再继续执行后面的代码。</p>

<p>你也许会问，为什么我们在C++中就没有在程序的末尾加上 <code>getch()</code> ，解释是，软件总是不断更新的，不好的地方当然要进行改正， <code>getch()</code> 加在程序末尾，它又不赋值给任何变量，所以它在这个地方完全是垃圾代码，与程序无关。C++中考虑到这一点，于是在每次程序运行完了并不退出，而是自动把屏幕停下来，并显示 “press any key...” 叫你按任意键退出，这就好比C++在它的环境中运行程序，在程序的末尾自动加上了一行 <code>getch();</code> 语句，并且在这行语句前还添加了一行输出语句 <code>cout&lt;&lt;"press any key...";</code> 来提示你程序结束了，按任意键继续。</p>

<p>实际上我们编译好的程序在程序结束了本身是不会停下来的，我们可以在编译产生的Debug目录中找到这个编译好的应用程序（扩展名exe），在文件夹中双击运行它，你会发现屏幕闪了一下MS-DOS窗口就关闭了，因为程序运行完就自动退出了，回到了windows环境，当然，如果我们在DOS环境中运行这个程序，我们就可以直接在看到DOS屏幕上看到程序运行结果，因为程序运行完后并不清屏。但是，visual stdio.net2003有返回到了tc那样的情况，你必需要有个 <code>getch()</code> 才行。</p></p>

<p><code>getche()</code> 和 <code>getch()</code> 很相似，它也需要引入头文件 <code>conio.h</code> ，那它们之间的区别又在哪里呢？不同之处就在于 <code>getch()</code> 无返回显示，<code>getche()</code> 有返回显示。就这么一点看看下面的例子：</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;conio.h></h1>

<p>void main()
{</p>

<pre><code>char ch;
for(int i=0;i&lt;5;i++)
{
    ch=getch();
    printf("%c",ch);
}
</code></pre>

<p>}
```</p>

<p>首先这是个连续5次的循环来实现5次停顿，等待我们输入，我们编译并运行这个程序，假设我们分别输入 <code>abcde</code> ，屏幕上显示的结果是 <code>abcde</code> ，这个 <code>abcde</code> 并不是在 <code>ch=getch();</code> 中输出的，我们把 <code>printf("%c",ch);</code> 这行语句去掉，就会发现我们按5次任意键程序就结束了，但屏幕上什么都没有显示。</p>

<p>然后我们在把代码中的 <code>getch()</code> 换成 <code>getche()</code> 看看有什么不同，我们还是分别输入 <code>abcde</code> ，这时屏幕上显示的结果是 <code>aabbccddee</code> ，我们把 <code>printf("%c",ch);</code> 这行语句再去掉看看，显示的结果就是 <code>abcde</code> 了，说明程序在执行 <code>ch=getche();</code> 这条语句的时候就把我们输入的键返回显示在屏幕上，有无回显就是它们的唯一区别。</p>

<p>有人会说，既然是C的函数库中的，那么就应该淘汰了，我们还研究它，还用它干嘛？但是我发现还是有用着它的地方，否则我也不会在这里说这么多来耽误大家的时间。我就举个例子吧，程序如下：</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;conio.h></h1>

<p>void main()
{</p>

<pre><code>char ch='*';
while(ch=='*')
{
    printf("/n按 * 继续循环，按其他键退出！");
    ch=getch();
}
printf("/n退出程序！");
</code></pre>

<p>}
```</p>

<p>我们可以在这个循环体中添加我们想要的功能，程序中按*继续循环，其他任意键退出，而且利用 <code>getch()</code> 无回显的特性，我们不管按什么，都不会在屏幕上留下痕迹，使我们的界面达到美观效果，如果还有更好的办法实现这个功能。例子：</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;conio.h></h1>

<p>void main()
{</p>

<pre><code>char c, ch;
c=getch();     /*从键盘上读入一个字符不回显送给字符变量c*/
putchar(c);    /*输出该字符*/
ch=getche();   /*从键盘上带回显的读入一个字符送给字符变量ch*/
putchar(ch);
printf("/n/n");
</code></pre>

<p>}
```</p>

<p><strong>值得注意的是前面两个函数都是从键盘读入数据！</strong><br/>
还有 <code>getchar</code> 是很值得研究的：<code>getchar()</code> 是 <code>stdio.h</code> 中的库函数，它的作用是从 <code>stdin</code> 流中读入一个字符，也就是说，如果 <code>stdin</code> 有数据的话不用输入它就可以直接读取了。而 <code>getch()</code> 和 <code>getche()</code> 是 <code>conio.h</code> 中的库函数，它的作用是从键盘接收字符。<code>getchar</code> 带有显示。</p></p>

<p>与前面两个函数的区别在于： <code>getchar()</code> 函数等待输入直到按回车才结束（前提是缓冲区没有数据），回车前的所有输入字符都会逐个显示在屏幕上。但只有第一个字符作为函数的返回值。</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;conio.h></h1>

<p>void main()
{</p>

<pre><code>char c;
c=getchar();   /*从键盘读入字符直到回车结束*/
//getchar()在这里它只返回你输入字符串的第一个字符，并把返回值赋值给c
putchar(c);    /*显示输入的第一个字符*/
printf("/n/n");
</code></pre>

<p>}
```</p>

<p>例四：呵呵，这个程序你运行一下，相信你又会有疑问了。这个就是从缓冲区中读取了例子。第一次 <code>getchar()</code> 时，确实需要人工的输入，但是如果你输了多个字符，以后的 <code>getchar()</code> 再执行时就会直接从缓冲区中读取了。</p>

<p>``` c</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;conio.h></h1>

<p>void main()
{</p>

<pre><code>char c;
while ((c=getchar())!='/n')    /*每个getchar()依次读入一个字符*/
    printf("%c",c);        /*按照原样输出*/
printf("/n/n");
</code></pre>

<p>}
```</p>

<p>程序运行时，首先停下来，等你输入一串字符串，输入完毕后，它把你输入的整个字符串都输出来了，咦，你不是说 <code>getchar()</code> 只返回第一个字符么，这里怎么？</p>

<p>因为我们输入的字符串并不是取了第一个字符就把剩下的字符串丢掉了，它还在我们的内存中，就好比，开闸放水，我们把水放到闸里去以后，开一次闸就放掉一点，开一次就放掉一点，直到放光了为止，这里开闸动作就相当于调用一次 <code>getchar()</code> 。我们输入的字符串也是这么一回事，首先我们输入的字符串是放在内存的缓冲区中的，我们调用一次 <code>getchar()</code> 就把缓冲区中里出口最近的一个字符输出，也就是最前面的一个字符输出，输出后，就把它释放掉了，但后面还有字符串，所以我们就用循环把最前面的一个字符一个个的在内存中释放掉，直到不满足循环条件退出为止。</p>

<p>例子中循环条件里的 <code>'/n'</code> 实际上就是你输入字符串后的回车符，所以意思就是说，直到遇到回车符才结束循环，而 <code>getchar()</code> 函数就是等待输入（或缓冲区中的数据）直到按回车才结束，所以实现了整个字符串的输出。当然，我们也可以把循环条件改一下，比如 <code>while ((c=getchar())!='a')</code> ，什么意思呢，意思就是遇到字符'a'就停止循环，当然意思是如果你输入 <code>“12345a213123/n”</code> 那么只会输出到 <code>a</code> ，结果是 <code>12345a</code> 。</p>

<p>再次注意：用 <code>getchar()</code> 它是从“流”中间去读取，所以第一个 <code>getchar()</code> 接受的是刚刚中断的流队列中即将出列的第一个字符（不限于回车符，上面举过例子了），如果流队列不为空，执行 <code>getchar()</code> 就继续放水，直到把回车符也放空为止，空了之后再在执行 <code>getchar()</code> 就停下等待你的输入了；我们用 <code>getch()</code> 为什么每次都是等待用户的输入呢？因为 <code>getch()</code> 是从键盘接收，即时的接收，并不是从 <code>stdin</code> 流中去读取数据。</p>

<p>补充：按键盘上的回车产生了2个字符:回车符(<code>'/r'</code>)和换行符(<code>'/n'</code>)。回车符<code>'/r'</code>(CR:carriage return:倒车）使光标回到这行的首部，换行符(<code>'/n'</code>)(new line)然后再换行。</p>

<p>所以当输入字符'w',并按下回车键以后。首先得到回车符。那个 <code>getchar</code> 函数结束了。 但是还存在一个换行符。所以如果用 <code>getchar()</code> 来做判断的时候。最好再写一次 <code>getchar()</code> 清除缓冲区的'/n'.</p>

<h2>3.如何清空输入缓冲区的内容？</h2>

<p>如果我想让 <code>getchar()</code> 每次都能够等待用户输入的话就要清空缓冲区，下面就介绍方法（不同平台）。</p>

<p>C标准规定 <code>fflush()</code> 函数是用来刷新输出（stdout）缓存的。对于输入（stdin），它是没有定义的。但是有些编译器也定义了 <code>fflush( stdin )</code> 的实现，比如微软的VC。其它编译器是否也定义了 <code>fflush( stdin )</code> 的实现应当查找它的手册。GCC编译器没有定义它的实现，所以不能使用 <code>fflush( stdin )</code> 来刷新输入缓存。</p>

<p>对于没有定义 <code>fflush( stdin )</code> 的编译器，可以使用 <code>fgets()</code> 函数来代替它（比用  <code>getchar()</code>、<code>scanf()</code> 等函数通用性好）。可以这样忽略输入流中留下的回车等其它输入，从而使下一次的输入总保持一个“干净”的状态。（这个是任何平台下都可以的）</p>

<p><code>c
// ...
char sbuf[1024];
// ...
fgets( sbuf, 1024, stdin );
// ...
在windows 的vc下面就可以这样了：
for(int i=0;i&lt;10;++i)
{
   char ch=getchar();
   fflush(stdin); //每次都会有等待状态了
}
</code></p>

<h2>4.总结</h2>

<p>主要看 <code>getch()</code>，<code>getche()</code> 的是否显示，<code>getchar()</code> 是读取流，而且和前面两个函数不是一个库。掌握清空缓冲区的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言编译过程全解析]]></title>
    <link href="http://ibillxia.github.io/blog/2009/05/28/analysis-the-steps-of-compiling-c-language/"/>
    <updated>2009-05-28T19:45:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2009/05/28/analysis-the-steps-of-compiling-c-language</id>
    <content type="html"><![CDATA[<h2>0.内容摘要</h2>

<p>C语言编译的整个过程是非常复杂的，里面涉及到的编译器知识、硬件知识、工具链知识都是非常多的，深入了解整个编译过程对工程师理解应用程序的编写是有很大帮助的，希望大家可以多了解一些，在遇到问题时多思考、多实践。</p>

<p>一般情况下，我们只需要知道分成编译和连接两个阶段:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;·编译阶段将源程序（*.c)转换成为目标代码（一般是obj文件，至于具体过程就是上面说的那些阶段）；<br/>
&nbsp;&nbsp;&nbsp;&nbsp;·连接阶段是把源程序转换成的目标代码（obj文件）与你程序里面调用的库函数对应的代码连接起来形成对应的可执行文件（exe文件）就可以了，其他的都需要在实践中多多体会才能有更深的理解。<br/>
编译的概念：编译程序读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码，再由汇编程序转换为机器语言，并且按照操作系统对可执行文件格式的要求链接生成可执行程序。</p>

<p>编译的完整过程：C源程序->预编译处理(.c)->编译、优化程序（.s、.asm）->汇编程序(.obj、.o、.a、.ko)->链接程序（.exe、.elf、.axf等）。</p>

<h2>1.编译预处理</h2>

<p>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理伪指令主要包括以下四个方面：</p>

<!-- more -->


<p><strong>（1）宏定义指令</strong>，如<code>#define Name TokenString</code>，<code>#undef</code>等。对于前一个伪指令，预编译所要做的是将程序中的所有Name用TokenString替换，但作为字符串常量的 Name则不被替换。对于后者，则将取消对某个宏的定义，使以后该串的出现不再被替换。</p>

<p><strong>（2）条件编译指令</strong>，如<code>#ifdef</code>，<code>#ifndef</code>，<code>#else</code>，<code>#elif</code>，<code>#endif</code>等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。</p>

<p><strong>（3）头文件包含指令</strong>，如<code>#include "FileName"</code>或者<code>#include &lt;FileName&gt;</code>等。在头文件中一般用伪指令 <code>#define</code> 定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。<br/>
采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条 <code>#include</code> 语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。<br/>
包含到c源程序中的头文件可以是系统提供的，这些头文件一般被放在 <code>/usr/include</code> 目录下。在程序中 <code>#include</code> 它们要使用尖括号（<code>&lt; &gt;</code>）。 另外开发人员也可以定义自己的头文件，这些文件一般与c源程序放在同一目录下，此时在 <code>#include</code>中要用双引号（""）。</p>

<p><strong>（4）特殊符号</strong>，预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。<br/>
预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。下一步，此输出文件将作为编译程序的输出而被翻译成为机器指令。</p>

<h2>2.编译、优化阶段</h2>

<p>经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如 <code>main,if,else,for,while,{,}, +,-,*,/</code>等等。<br/>
编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。<br/>
优化处理是编译系统中一项比较艰深的技术。它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。优化一部分是对中间代码的优化。 这种优化不依赖于具体的计算机。另一种优化则主要针对目标代码的生成而进行的。</p>

<p>对于前一种优化，主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。<br/>
后一种类型的优化同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数。另外，如何根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行
一些调整使目标代码比较短，执行的效率比较高，也是一个重要的研究课题。</p>

<p>经过优化得到的汇编代码必须经过汇编程序的汇编转换成相应的机器指令，方可能被机器执行。</p>

<h2>3.汇编过程</h2>

<p>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。<br/>
目标文件由段组成。通常一个目标文件中至少有两个段：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;·代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。<br/>
&nbsp;&nbsp;&nbsp;&nbsp;·数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。</p>

<p>UNIX环境下主要有三种类型的目标文件：<br/>
<strong>（1）可重定位文件</strong><br/>
其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。<br/>
<strong>（2）共享的目标文件</strong><br/>
这种文件存放了适合于在两种上下文里链接的代码和数据。<br/>
第一种是链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个 目标文件；<br/>
第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。 <br/>
<strong>（3）可执行文件</strong><br/>
它包含了一个可以被操作系统创建一个进程来执行之的文件。<br/>
汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。</p>

<h2>4.链接程序</h2>

<p>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。<br/>
例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。<br/>
链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。<br/>
根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：</p>

<p><strong>（1）静态链接</strong><br/>
在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。</p>

<p><strong>（2） 动态链接</strong><br/>
在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。</p>

<p>对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。</p>

<h2>5.总结</h2>

<p>C语言编译的整个过程是非常复杂的，里面涉及到的编译器知识、硬件知识、工具链知识都是非常多的，深入了解整个编译过程对工程师理解应用程序的编写是有很大帮助的，希望大家可以多了解一些，在遇到问题时多思考、多实践。</p>

<p>一般情况下，我们只需要知道分成编译和连接两个阶段，编译阶段将源程序（*.c)转换成为目标代码（一般是obj文件，至于具体过程就是上面说的那些阶段），连接阶段是把源程序转换成的目标代码（obj文件）与你程序里面调用的库函数对应的代码连接起来形成对应的可执行文件（exe文件）就可以了，其他的都需要在实践中多多体会才能有更深的理解。</p>
]]></content>
  </entry>
  
</feed>