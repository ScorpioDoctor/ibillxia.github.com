<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: C | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/c/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2015-01-11T15:21:15+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言函数指针与C++函数调用操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/"/>
    <updated>2014-05-24T21:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在编程过程中，一些特殊的时候，我们需要向一个函数传递另一个函数的地址（比如在快速排序中，我们需要传入两个元素大小比较的函数的地址），此时在C语言中一般是通过传递一个函数指针来实现。最近在看《STL源码剖析》一书，上面提到，在C++中其实可以通过另一种方式实现，那就是函数调用操作符<code>()</code> 。本文首先介绍一下C语言中函数指针的用法，然后再介绍C++中函数调用操作符的用法。</p>

<h2>C语言中的函数指针</h2>

<p>我们先直接看一个例子吧。这个例子比较全面而且简单，其中的函数指针是带参数且有返回值的函数指针，而且还有把函数指针作为参数来传递的代码。这个例子来自 <a href="http://blog.jobbole.com/44639/">jobbole伯乐在线</a>，代码如下：</p>

<!-- more -->


<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>// 函数原型
int add(int x, int y);
int subtract(int x, int y);
int domath(int (*mathop)(int, int), int x, int y);</p>

<p>// 加法 x+ y
int add(int x, init y) {</p>

<pre><code>return x + y;
</code></pre>

<p>}</p>

<p>// 减法 x - y
int subtract(int x, int y) {</p>

<pre><code>return x - y;
</code></pre>

<p>}</p>

<p>// 根据输入执行函数指针
int domath(int (*mathop)(int, int), int x, int y) {</p>

<pre><code>return (*mathop)(x, y);
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>// 用加法调用domath
int a = domath(add, 10, 2);
printf("Add gives: %d\n", a);

// 用减法调用domath
int b = domath(subtract, 10, 2);
printf("Subtract gives: %d\n", b);
</code></pre>

<p>}
```</p>

<p>在函数 <code>domath</code> 中，我们可以根据传入的 <code>mathop</code> 函数指针来做不同的计算操作。另外，在该文中，最后提到函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名，解引用符 <code>*</code> 和取地址符 <code>&amp;</code> 用在函数名之前基本上都是多余的。这个之前还真不知道，新技能get，哈哈</p>

<h4>使用typedef</h4>

<p>在C语言中，对于函数指针，我们可以使用 <code>typedef</code> 将其定义为一种数据类型，这样我们就可以定义这种类型的变量了，就像使用普通的变量类型一样。下面是一个具体的定义（来自<a href="http://stackoverflow.com/questions/4295432/typedef-function-pointer">stackoverflow</a> Jacob的回答）：</p>

<pre><code>    typedef   void      (*FunctionFunc)  ( );
   //         ^                ^         ^
   //     return type      type name  arguments
</code></pre>

<p>这里 <code>typedef</code> 的使用方法与一般的 <code>typedef A B</code> 的使用方式不不大一样的，如果没有接触过这种用法，可能开起来很别扭（在很多开源库中可能经常会碰到）。下面是其具体使用的实例（不完整代码）：</p>

<p><code>c
FunctionFunc x;
void doSomething() { printf("Hello there\n"); }
x = &amp;doSomething;
x(); //prints "Hello there"
</code></p>

<p>根据上面提到的隐式转换，这里的取址符其实是没有必要的。关于C语言的函数指针就介绍到这儿了，接下来介绍一下C++的函数调用操作符。</p>

<h2>C++中的函数调用操作符</h2>

<p>在C++中，函数调用操作符是指左右小括弧 <code>()</code> ，该操作符是可以重载的。许多 STL 算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时按照使用者自定义的大小关系进行排序）。 上面讲了，在C语言中使用者是通过传递函数指针的方式来实现的。然而，函数指针有一些缺点，最重要的是它无法持有自己的状态（这里指局部状态，local states，具体可以通过后面的例子来理解），也无法达到组件技术中的可适配性 —— 也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>

<p>在C++中，对应于C中函数指针的东西是仿函数（functor），使用起来就像函数一样。其实现方法是对某个 class 进行 <code>operator()</code> 重载，他就成为一个仿函数。而要成为一个可适配（adaptable）的仿函数，还需要其他的一些努力（在《STL源码剖析》一书的第8章，关于适配器（adaptor）的内容）。这里，我们只拿书中的那个例子来简单的看一下仿函数的定义和使用方法吧。代码如下：</p>

<p>``` cpp</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>// 对plus进行operator() 重载，使得 plus 变成了一个仿函数
template<class T>
struct plus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x+y;}
</code></pre>

<p>};</p>

<p>// 对 minus 进行operator() 重载，使得 minus 变成了一个仿函数
template<class T>
struct minus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x-y;}
</code></pre>

<p>};</p>

<p>int main(){</p>

<pre><code>// 以下产生仿函数对象
plus&lt;int&gt; plusObj;
minus&lt;int&gt; minusObj;
// 以下使用仿函数，就像使用一般函数一样
cout&lt;&lt;plusObj(3,5)&lt;&lt;endl;
cout&lt;&lt;minusObj(3,5)&lt;&lt;endl;
// 也可以这样使用，通过临时对象（匿名对象）
cout&lt;&lt;plus&lt;int&gt;()(3,5)&lt;&lt;endl;
cout&lt;&lt;minus&lt;int&gt;()(3,5)&lt;&lt;endl;
return 0;
</code></pre>

<p>}
```</p>

<p>这里的 <code>plus&lt;T&gt;</code> 和 <code>minus&lt;T&gt;</code> 已经非常接近 STL 的实现了，唯一的差别是它缺乏“可适配能力”，关于 STL 中的适配器（adaptor），我现在也还没看完该书，也还不太了解，在后续文章中应该会介绍到。读者可以自行google。</p>

<h2>在快排中使用函数调用操作符</h2>

<p>为了加深对函数调用操作符的理解，并将其真正用到实际中，这里拿快排这个非常典型的例子，并充分利用C++及STL的特性。下面是核心代码：</p>

<p>``` cpp
template<typename InIt,typename FuncType>
void myqsort(InIt begin, InIt end, FuncType cmp){</p>

<pre><code>if(begin==end||begin==end-1)return;
InIt it = mysplit(begin,end,cmp);
if(it!=end){
    myqsort(begin,it,cmp);
    myqsort(it+1,end,cmp);
}
</code></pre>

<p>}</p>

<p>template<typename InIt,typename FuncType>
InIt mysplit(InIt begin, InIt end, FuncType cmp){</p>

<pre><code>InIt itl,itr;
itl=begin;
itr=end-1;
while(itl != itr){
    while(itl != itr &amp;&amp; cmp(*itr,*begin)&gt;0)itr--;
    if(itl==itr)break;
    while(itl != itr &amp;&amp; cmp(*begin,*itl)&gt;0)itl++;
    if(itl==itr)break;
    swap(*itl,*itr);
    itr--;
}
return itl;
</code></pre>

<p>}</p>

<p>class Test{
public:</p>

<pre><code>double m_lf;
string m_str;
</code></pre>

<p>public:</p>

<pre><code>void set(){ cin&gt;&gt;m_lf&gt;&gt;m_str; }
void print(){ cout&lt;&lt;m_lf&lt;&lt;" "&lt;&lt;m_str&lt;&lt;endl; }
</code></pre>

<p>};</p>

<p>struct cmpd{</p>

<pre><code>int operator()(Test a,Test b){
    if(abs(a.m_lf - b.m_lf)&lt;INF)return 0;
    if(a.m_lf &gt; b.m_lf)return 1;
    return -1;
}
</code></pre>

<p>};</p>

<p>struct cmps{</p>

<pre><code>int operator()(Test a,Test b){
    return a.m_str.compare(b.m_str);
}
</code></pre>

<p>};
```</p>

<p>完整的代码及测试输入可以通过以下链接打包下载：<a href="https://ibillxia.github.io/upload/code/20140525.tar.gz">code-2014-05-25</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解C语言的define和内联函数]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c/"/>
    <updated>2014-05-17T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在 <code>Robert C.Searcord</code> 的 <em>The</em> <em>Cert</em> <em>C</em> <em>Secure</em> <em>Coding</em> <em>Standard</em> 一书中，关于宏定义的规范中第一条就是</p>

<blockquote><p>用内联函数或静态函数替代与函数相似的宏</p></blockquote>

<p>这个规范非常实用。内联函数是C99标准中新增的，当宏定义和内联函数可以互换时，应该优先考虑选择内联函数，这也是为什么在C++标准库函数中 <code>max</code>, <code>min</code>, <code>swap</code> 等都是通过内联函数来实现的原因。 宏定义是完全原封不动的很SB的替换，而内联函数则并非简单的文本替换，而是按函数调用的方式展开。关于内联函数相对于宏替换的优点，在wiki有如下几点的总结：</p>

<ul>
<li>宏调用并不执行类型检查，甚至连正常参数也不检查，但是函数调用却要检查。</li>
<li>C语言的宏使用的是文本替换，可能导致无法预料的后果，因为需要重新计算参数和操作顺序。</li>
<li>在宏中的编译错误很难发现，因为它们引用的是扩展的代码，而不是程序员键入的。</li>
<li>许多结构体使用宏或者使用不同的语法来表达很难理解。内联函数使用与普通函数相同的语言，可以随意的内联和不内联。</li>
<li>内联代码的调试信息通常比扩展的宏代码更有用。</li>
</ul>


<p>其中前面两条很好理解，相信大家应该不陌生，这里主要通过具体讨论一个该书中提到的一个程序实例来感受一下后面几点。</p>

<!-- more -->


<h2>宏定义引起的运行时错误</h2>

<p>下面我们看一个稍微复杂的例子，这个例子是在运行时才出现另我们感到意外的错误（这里的运行时错误并不是指 <code>Runtime Error</code>，么么哒）。</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>int count=0;</p>

<p>void g(void){</p>

<pre><code>printf("Called g, count=%d.\n",count);
</code></pre>

<p>}</p>

<h1>define EXEC_BUMP(func) (func(),++count)</h1>

<p>typedef void(*exec_func)(void);  // 定义函数指针类型
inline void exec_bump(exec_func f){</p>

<pre><code>f();
++count;
</code></pre>

<p>}</p>

<p>int main(void)
{</p>

<pre><code>int count=0;
while(count++&lt;10){
    //EXEC_BUMP(g);  // (1) 宏定义实现
    exec_bump(g);    // (2) 内联实现
}
return 0;
</code></pre>

<p>}
```</p>

<p>使用宏定义的实现得到输出如下：</p>

<p><code>
Called g, count=0.
Called g, count=0.
Called g, count=0.
Called g, count=0.
Called g, count=0.
</code></p>

<p>这并不是我们想要的结果。而使用内联函数实现得到的输出如下：</p>

<p><code>
Called g, count=0.
Called g, count=1.
Called g, count=2.
Called g, count=3.
Called g, count=4.
Called g, count=5.
Called g, count=6.
Called g, count=7.
Called g, count=8.
Called g, count=9.
</code></p>

<p>这才是我们想要的结果。根据这两个输出结果，我们可以分析宏定义和内联的区别。通过宏定义时，直接使用 <code>(g(),++count);</code> 替换 <code>EXEC_BUMP(g);</code> 即可，这样每次调用 <code>g()</code> 函数时输出的 <code>count</code> 是全局的变量，所以都是0；而调用完 <code>g()</code> 函数之后，对局部变量 <code>count</code> 进行了自加操作，所以循环了5次。然而使用内联函数实现时，是按照函数调用的方式展开的，首先将全局变量和内联函数的传入参数压栈，然后是执行函数体，最后参数出栈；因此，内联函数中调用 <code>g()</code> 函数时输出的 <code>count</code> 也是全局变量，而且在内联函数中的 <code>++count</code> 也是对全局变量的操作，因此每次调用时输出的计数变量是递增的。  由此，我们可以更清楚的理解内联函数的替换原理了，它是由编译器显式地将函数调用中的压栈、函数体、出栈等步骤生成到可执行文件中，而不是像普通函数那样，函数体与调用该函数的代码部分是分离的，在调用内联函数时不需要跳转，因而执行效率会比普通的函数要高。（然而，如果函数本身代码较多，如果使用内联，就会在可执行文件中多个地方有该内联函数的函数体，这样可执行文件的大小就会比不使用内联的大。因此，一般不会将函数体复杂的函数定义为内联函数，除非特殊情况下，为了运行时间性能的考虑）</p>

<h2>宏定义的典型应用场景</h2>

<p>上面主要是对宏定义的贬低和歧视，其实宏定义也并非毫无用武之地，下面几种情况下宏定义还是不可替代的：</p>

<p>（1）用于实现局部函数 <br/>
此时无法用内联函数替代宏定义。因为宏定义代码块中的自动变量可以和引用宏的前后代码块互为使用，即宏引用前的代码快中的自动变量可以在宏中直接使用，而宏中定义的自动变量可以在宏引用的代码块之后使用。例如，比较常见是：</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>define FOR(i,n) for(int i=0;i&lt;n;i++)  // 宏定义部分</h1>

<p>int main(){</p>

<pre><code>int a[]={1,2,3,4,5};
FOR(j,5) // 宏引用，这里j是在宏中才定义的自动变量
    printf("%d ",a[j]);  // 但是可以在宏引用之后的代码中使用
return 0;
</code></pre>

<p>}
```</p>

<p>其中对临时变量 <code>j</code> 的声明是在宏中定义的，可以在宏调用完后使用这个变量。同样的，也可以在宏定义前声明临时变量，而直接在宏中使用（不需要作为参数传递给宏）。</p>

<p>（2）宏可以支持某种形式的惰式计算<br/>
例如：</p>

<p>``` c</p>

<h1>define SELECT(s,v1,v2) ((s)?(v1):(v2))</h1>

<p>```</p>

<p>这个是无法用内联实现的。</p>

<p>(3)宏定义可以产生编译时常量<br/>
例如：</p>

<p>``` c</p>

<h1>define ADD(a,b) ((a)+(b))</h1>

<p>```</p>

<p>调用 <code>ADD(3,4)</code> 会产生一个常量表达式 <code>3+4</code> ，而内联无此效果。</p>

<p>（4）实现类型通用的函数<br/>
如果不借助C++模板这样的机制，C语言内联是无法实现这样的功能的，而只能针对不同的数据类型定义不同名的函数。</p>
]]></content>
  </entry>
  
</feed>