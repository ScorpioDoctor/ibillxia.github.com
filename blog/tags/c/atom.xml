<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: C | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/c/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2015-01-08T22:09:37+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言函数指针与C++函数调用操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/"/>
    <updated>2014-05-24T21:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在编程过程中，一些特殊的时候，我们需要向一个函数传递另一个函数的地址（比如在快速排序中，我们需要传入两个元素大小比较的函数的地址），此时在C语言中一般是通过传递一个函数指针来实现。最近在看《STL源码剖析》一书，上面提到，在C++中其实可以通过另一种方式实现，那就是函数调用操作符<code>()</code> 。本文首先介绍一下C语言中函数指针的用法，然后再介绍C++中函数调用操作符的用法。</p>

<h2>C语言中的函数指针</h2>

<p>我们先直接看一个例子吧。这个例子比较全面而且简单，其中的函数指针是带参数且有返回值的函数指针，而且还有把函数指针作为参数来传递的代码。这个例子来自 <a href="http://blog.jobbole.com/44639/">jobbole伯乐在线</a>，代码如下：</p>

<!-- more -->


<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>// 函数原型
int add(int x, int y);
int subtract(int x, int y);
int domath(int (*mathop)(int, int), int x, int y);</p>

<p>// 加法 x+ y
int add(int x, init y) {</p>

<pre><code>return x + y;
</code></pre>

<p>}</p>

<p>// 减法 x - y
int subtract(int x, int y) {</p>

<pre><code>return x - y;
</code></pre>

<p>}</p>

<p>// 根据输入执行函数指针
int domath(int (*mathop)(int, int), int x, int y) {</p>

<pre><code>return (*mathop)(x, y);
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>// 用加法调用domath
int a = domath(add, 10, 2);
printf("Add gives: %d\n", a);

// 用减法调用domath
int b = domath(subtract, 10, 2);
printf("Subtract gives: %d\n", b);
</code></pre>

<p>}
```</p>

<p>在函数 <code>domath</code> 中，我们可以根据传入的 <code>mathop</code> 函数指针来做不同的计算操作。另外，在该文中，最后提到函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名，解引用符 <code>*</code> 和取地址符 <code>&amp;</code> 用在函数名之前基本上都是多余的。这个之前还真不知道，新技能get，哈哈</p>

<h4>使用typedef</h4>

<p>在C语言中，对于函数指针，我们可以使用 <code>typedef</code> 将其定义为一种数据类型，这样我们就可以定义这种类型的变量了，就像使用普通的变量类型一样。下面是一个具体的定义（来自<a href="http://stackoverflow.com/questions/4295432/typedef-function-pointer">stackoverflow</a> Jacob的回答）：</p>

<pre><code>    typedef   void      (*FunctionFunc)  ( );
   //         ^                ^         ^
   //     return type      type name  arguments
</code></pre>

<p>这里 <code>typedef</code> 的使用方法与一般的 <code>typedef A B</code> 的使用方式不不大一样的，如果没有接触过这种用法，可能开起来很别扭（在很多开源库中可能经常会碰到）。下面是其具体使用的实例（不完整代码）：</p>

<p><code>c
FunctionFunc x;
void doSomething() { printf("Hello there\n"); }
x = &amp;doSomething;
x(); //prints "Hello there"
</code></p>

<p>根据上面提到的隐式转换，这里的取址符其实是没有必要的。关于C语言的函数指针就介绍到这儿了，接下来介绍一下C++的函数调用操作符。</p>

<h2>C++中的函数调用操作符</h2>

<p>在C++中，函数调用操作符是指左右小括弧 <code>()</code> ，该操作符是可以重载的。许多 STL 算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时按照使用者自定义的大小关系进行排序）。 上面讲了，在C语言中使用者是通过传递函数指针的方式来实现的。然而，函数指针有一些缺点，最重要的是它无法持有自己的状态（这里指局部状态，local states，具体可以通过后面的例子来理解），也无法达到组件技术中的可适配性 —— 也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>

<p>在C++中，对应于C中函数指针的东西是仿函数（functor），使用起来就像函数一样。其实现方法是对某个 class 进行 <code>operator()</code> 重载，他就成为一个仿函数。而要成为一个可适配（adaptable）的仿函数，还需要其他的一些努力（在《STL源码剖析》一书的第8章，关于适配器（adaptor）的内容）。这里，我们只拿书中的那个例子来简单的看一下仿函数的定义和使用方法吧。代码如下：</p>

<p>``` cpp</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>// 对plus进行operator() 重载，使得 plus 变成了一个仿函数
template<class T>
struct plus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x+y;}
</code></pre>

<p>};</p>

<p>// 对 minus 进行operator() 重载，使得 minus 变成了一个仿函数
template<class T>
struct minus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x-y;}
</code></pre>

<p>};</p>

<p>int main(){</p>

<pre><code>// 以下产生仿函数对象
plus&lt;int&gt; plusObj;
minus&lt;int&gt; minusObj;
// 以下使用仿函数，就像使用一般函数一样
cout&lt;&lt;plusObj(3,5)&lt;&lt;endl;
cout&lt;&lt;minusObj(3,5)&lt;&lt;endl;
// 也可以这样使用，通过临时对象（匿名对象）
cout&lt;&lt;plus&lt;int&gt;()(3,5)&lt;&lt;endl;
cout&lt;&lt;minus&lt;int&gt;()(3,5)&lt;&lt;endl;
return 0;
</code></pre>

<p>}
```</p>

<p>这里的 <code>plus&lt;T&gt;</code> 和 <code>minus&lt;T&gt;</code> 已经非常接近 STL 的实现了，唯一的差别是它缺乏“可适配能力”，关于 STL 中的适配器（adaptor），我现在也还没看完该书，也还不太了解，在后续文章中应该会介绍到。读者可以自行google。</p>

<h2>在快排中使用函数调用操作符</h2>

<p>为了加深对函数调用操作符的理解，并将其真正用到实际中，这里拿快排这个非常典型的例子，并充分利用C++及STL的特性。下面是核心代码：</p>

<p>``` cpp
template<typename InIt,typename FuncType>
void myqsort(InIt begin, InIt end, FuncType cmp){</p>

<pre><code>if(begin==end||begin==end-1)return;
InIt it = mysplit(begin,end,cmp);
if(it!=end){
    myqsort(begin,it,cmp);
    myqsort(it+1,end,cmp);
}
</code></pre>

<p>}</p>

<p>template<typename InIt,typename FuncType>
InIt mysplit(InIt begin, InIt end, FuncType cmp){</p>

<pre><code>InIt itl,itr;
itl=begin;
itr=end-1;
while(itl != itr){
    while(itl != itr &amp;&amp; cmp(*itr,*begin)&gt;0)itr--;
    if(itl==itr)break;
    while(itl != itr &amp;&amp; cmp(*begin,*itl)&gt;0)itl++;
    if(itl==itr)break;
    swap(*itl,*itr);
    itr--;
}
return itl;
</code></pre>

<p>}</p>

<p>class Test{
public:</p>

<pre><code>double m_lf;
string m_str;
</code></pre>

<p>public:</p>

<pre><code>void set(){ cin&gt;&gt;m_lf&gt;&gt;m_str; }
void print(){ cout&lt;&lt;m_lf&lt;&lt;" "&lt;&lt;m_str&lt;&lt;endl; }
</code></pre>

<p>};</p>

<p>struct cmpd{</p>

<pre><code>int operator()(Test a,Test b){
    if(abs(a.m_lf - b.m_lf)&lt;INF)return 0;
    if(a.m_lf &gt; b.m_lf)return 1;
    return -1;
}
</code></pre>

<p>};</p>

<p>struct cmps{</p>

<pre><code>int operator()(Test a,Test b){
    return a.m_str.compare(b.m_str);
}
</code></pre>

<p>};
```</p>

<p>完整的代码及测试输入可以通过以下链接打包下载：<a href="https://ibillxia.github.io/upload/code/20140525.tar.gz">code-2014-05-25</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解C语言的define和内联函数]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c/"/>
    <updated>2014-05-17T22:43:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在 <code>Robert C.Searcord</code> 的 <em>The</em> <em>Cert</em> <em>C</em> <em>Secure</em> <em>Coding</em> <em>Standard</em> 一书中，关于宏定义的规范中第一条就是</p>

<blockquote><p>用内联函数或静态函数替代与函数相似的宏</p></blockquote>

<p>这个规范非常实用。内联函数是C99标准中新增的，当宏定义和内联函数可以互换时，应该优先考虑选择内联函数，这也是为什么在C++标准库函数中 <code>max</code>, <code>min</code>, <code>swap</code> 等都是通过内联函数来实现的原因。 宏定义是完全原封不动的很SB的替换，而内联函数则并非简单的文本替换，而是按函数调用的方式展开。关于内联函数相对于宏替换的优点，在wiki有如下几点的总结：</p>

<ul>
<li>宏调用并不执行类型检查，甚至连正常参数也不检查，但是函数调用却要检查。</li>
<li>C语言的宏使用的是文本替换，可能导致无法预料的后果，因为需要重新计算参数和操作顺序。</li>
<li>在宏中的编译错误很难发现，因为它们引用的是扩展的代码，而不是程序员键入的。</li>
<li>许多结构体使用宏或者使用不同的语法来表达很难理解。内联函数使用与普通函数相同的语言，可以随意的内联和不内联。</li>
<li>内联代码的调试信息通常比扩展的宏代码更有用。</li>
</ul>


<p>其中前面两条很好理解，相信大家应该不陌生，这里主要通过具体讨论一个该书中提到的一个程序实例来感受一下后面几点。</p>

<!-- more -->


<h2>宏定义引起的运行时错误</h2>

<p>下面我们看一个稍微复杂的例子，这个例子是在运行时才出现另我们感到意外的错误（这里的运行时错误并不是指 <code>Runtime Error</code>，么么哒）。</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>int count=0;</p>

<p>void g(void){</p>

<pre><code>printf("Called g, count=%d.\n",count);
</code></pre>

<p>}</p>

<h1>define EXEC_BUMP(func) (func(),++count)</h1>

<p>typedef void(*exec_func)(void);  // 定义函数指针类型
inline void exec_bump(exec_func f){</p>

<pre><code>f();
++count;
</code></pre>

<p>}</p>

<p>int main(void)
{</p>

<pre><code>int count=0;
while(count++&lt;10){
    //EXEC_BUMP(g);  // (1) 宏定义实现
    exec_bump(g);    // (2) 内联实现
}
return 0;
</code></pre>

<p>}
```</p>

<p>使用宏定义的实现得到输出如下：</p>

<p><code>
Called g, count=0.
Called g, count=0.
Called g, count=0.
Called g, count=0.
Called g, count=0.
</code></p>

<p>这并不是我们想要的结果。而使用内联函数实现得到的输出如下：</p>

<p><code>
Called g, count=0.
Called g, count=1.
Called g, count=2.
Called g, count=3.
Called g, count=4.
Called g, count=5.
Called g, count=6.
Called g, count=7.
Called g, count=8.
Called g, count=9.
</code></p>

<p>这才是我们想要的结果。根据这两个输出结果，我们可以分析宏定义和内联的区别。通过宏定义时，直接使用 <code>(g(),++count);</code> 替换 <code>EXEC_BUMP(g);</code> 即可，这样每次调用 <code>g()</code> 函数时输出的 <code>count</code> 是全局的变量，所以都是0；而调用完 <code>g()</code> 函数之后，对局部变量 <code>count</code> 进行了自加操作，所以循环了5次。然而使用内联函数实现时，是按照函数调用的方式展开的，首先将全局变量和内联函数的传入参数压栈，然后是执行函数体，最后参数出栈；因此，内联函数中调用 <code>g()</code> 函数时输出的 <code>count</code> 也是全局变量，而且在内联函数中的 <code>++count</code> 也是对全局变量的操作，因此每次调用时输出的计数变量是递增的。  由此，我们可以更清楚的理解内联函数的替换原理了，它是由编译器显式地将函数调用中的压栈、函数体、出栈等步骤生成到可执行文件中，而不是像普通函数那样，函数体与调用该函数的代码部分是分离的，在调用内联函数时不需要跳转，因而执行效率会比普通的函数要高。（然而，如果函数本身代码较多，如果使用内联，就会在可执行文件中多个地方有该内联函数的函数体，这样可执行文件的大小就会比不使用内联的大。因此，一般不会将函数体复杂的函数定义为内联函数，除非特殊情况下，为了运行时间性能的考虑）</p>

<h2>宏定义的典型应用场景</h2>

<p>上面主要是对宏定义的贬低和歧视，其实宏定义也并非毫无用武之地，下面几种情况下宏定义还是不可替代的：</p>

<p>（1）用于实现局部函数 <br/>
此时无法用内联函数替代宏定义。因为宏定义代码块中的自动变量可以和引用宏的前后代码块互为使用，即宏引用前的代码快中的自动变量可以在宏中直接使用，而宏中定义的自动变量可以在宏引用的代码块之后使用。例如，比较常见是：</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>define FOR(i,n) for(int i=0;i&lt;n;i++)  // 宏定义部分</h1>

<p>int main(){</p>

<pre><code>int a[]={1,2,3,4,5};
FOR(j,5) // 宏引用，这里j是在宏中才定义的自动变量
    printf("%d ",a[j]);  // 但是可以在宏引用之后的代码中使用
return 0;
</code></pre>

<p>}
```</p>

<p>其中对临时变量 <code>j</code> 的声明是在宏中定义的，可以在宏调用完后使用这个变量。同样的，也可以在宏定义前声明临时变量，而直接在宏中使用（不需要作为参数传递给宏）。</p>

<p>（2）宏可以支持某种形式的惰式计算<br/>
例如：</p>

<p>``` c</p>

<h1>define SELECT(s,v1,v2) ((s)?(v1):(v2))</h1>

<p>```</p>

<p>这个是无法用内联实现的。</p>

<p>(3)宏定义可以产生编译时常量<br/>
例如：</p>

<p>``` c</p>

<h1>define ADD(a,b) ((a)+(b))</h1>

<p>```</p>

<p>调用 <code>ADD(3,4)</code> 会产生一个常量表达式 <code>3+4</code> ，而内联无此效果。</p>

<p>（4）实现类型通用的函数<br/>
如果不借助C++模板这样的机制，C语言内联是无法实现这样的功能的，而只能针对不同的数据类型定义不同名的函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言中的异常处理机制]]></title>
    <link href="http://ibillxia.github.io/blog/2011/05/03/Exception-handling-mechanism-in-c/"/>
    <updated>2011-05-03T11:09:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2011/05/03/Exception-handling-mechanism-in-c</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>


<p>什么是异常？异常一般指的是程序运行期（Run-Time）发生的非正常情况。异常一般是不可预测的，如：内存不足、打开文件失败、
范围溢出等。UNIX 使用信号给出异常，并当发生异常时转跳到信号处理过程进行异常处理。DOS下的信号对比UNIX系统而言相对较少。</p>




<p>我们知道，不管是在c++还是在java中，异常都被认为是一种很优雅的处理错误的机制。而如果想在c语言中使用异常就比较麻烦，
但是我们仍然可以使用c语言中强大的setjmp和longjmp函数实现类似于c++的异常处理机制。</p>




<p>异常处理的核心思想是，把功能模块代码与系统中可能出现错误的处理代码分离开来，以此来达到使我们的代码组织起来更美观、
逻辑上更清晰，并且同时从根本上来提高我们软件系统长时间稳定运行的可靠性。那么，现在回过头来看，实际上在计算机系统的硬件
设计中，操作系统的总体设计中，早期的许多面向结构化程序设计语言中(例如C语言)，都有异常处理的机制和方法的广泛运用。</p>




<h2>2.基于goto语句的异常处理</h2>


<p>goto语句，程序员朋友们对它太熟悉了，它是C语言中使用最为灵活的一条语句，由它也充分体现出了C语言的许多特点或者说是优点。
它虽然是一条高级语言中提供的语句，但是它一般却直接对应一条“无条件直接跳转的机器指令”，所以说它非常地特别，它引起过许多
争议，但是这条语句仍然一直被保留了下来，即便是今天的C++语言中，也有对它的支持(虽然不建议使用它)。</p>




<!-- more -->


<p>goto语句有非常多的用途或优点，例如，它特别适合于在编写系统程序中被使用，它能使编写出来的代码非常简练。另外，goto语句
另外一个最重要的作用就是，它实际上是一种对异常处理编程，最初也最原始的支持手段或方法。它能把错误处理模块的代码有效与其
它代码分离开来。例程如下</p>


<p>{% codeblock %}
void main(int argc, char* argv[])<br/>
{<br/>
　　if (Call_Func1(in, param out) {<br/>
　　　　// 函数调用成功，我们正常的处理<br/>
　　　　if (Call_Func2(in, param out) {<br/>
　　　　// 函数调用成功，我们正常的处理<br/>
　　　　　　while(condition) {<br/>
　　　　　　　　//do other job<br/>
　　　　　　　　// 如果错误直接跳转<br/>
　　　　　　　　if (has error) goto Error;<br/>
　　　　　　//do other job<br/>
　　　　　　}<br/>
　　　　}<br/>
　　　　// 如果错误直接跳转<br/>
　　　　else goto Error;<br/>
　　}<br/>
　　// 如果错误直接跳转<br/>
　　else goto Error;<br/>
　　// 错误处理模块<br/>
Error:<br/>
　　process_error();<br/>
　　exit();<br/>
}
{% endcodeblock %}</p>

<p>虽然goto 语句能有效地支持异常处理编程的实现。但是没有人却建议使用它，即便是在C语言中。因为：</br>
(1) goto语句能破坏程序的结构化设计，使代码难于测试，且包含大量goto的代码模块不易理解和阅读。它一直遭结构化程序设计思想所抛弃，强烈建议程序员不易使用它;</br>
(2) 与C++语言中提供的异常处理编程模型相比，它的确是太弱了一些。例如，它一般只能是在某个函数的局部作用域内跳转，也即它不能有效和方便地实现程序控制流的跨函数远程的跳转。</br>
(3) 如果在C++语言中，用goto语句来实现异常处理，那么它将给面向对象构成极大破坏，并影响到效率。这一点，以后会继续深入阐述。</p>




<p>虽然goto语句缺点多多，但不管如何，goto语句的确为程序员朋友们，在C语言中，有效运用异常处理思想来进行编程处理，提供了一种途径或简易的手段。
当然，运用goto语句来进行异常处理编程已经成为历史。因为，在C语言中，早就已经提供了一种更加优雅的异常处理机制。</p>




<h2>3.更优雅的异常处理机制：setjmp()函数与longjmp()函数</h2>


<p>C标准库提供两个特殊的函数：setjmp() 及 longjmp()，这两个函数是结构化异常的基础，正是利用这两个函数的特性来实现异常。</p>


<p>所以，异常的处理过程可以描述为这样：</br>
·首先设置一个跳转点（setjmp() 函数可以实现这一功能），然后在其后的代码中任意地方调用 longjmp() 跳转回这个跳转点上，
以此来实现当发生异常时，转到处理异常的程序上，在其后的介绍中将介绍如何实现。</br>
·setjmp() 为跳转返回保存现场并为异常提供处理程序，longjmp() 则进行跳转（抛出异常），setjmp() 与 longjmp() 可以在函数
间进行跳转，这就像一个全局的 goto 语句，可以跨函数跳转。</p>




<p>举个例子，程序在 main() 函数内使用 setjmp() 设置跳转，并调用另一函数A，函数A内调用B，B抛出异常（调用longjmp() 函数），
则程序直接跳回到 main() 函数内使用 setjmp() 的地方返回，并且返回一个值。</p>




<h4>jmp_buf 异常结构</h4>


<p>使用 setjmp() 及 longjmp() 函数前，需要先认识一下 jmp_buf 异常结构。jmp_buf 将使用在 setjmp() 函数中，用于保存当前程序现场（保存
当前需要用到的寄存器的值），jmp_buf 结构在 setjmp.h 文件内声明：</p>


<p>{% codeblock %}
typedef struct
{</p>

<pre><code>unsigned j_sp;  // 堆栈指针寄存器
unsigned j_ss;  // 堆栈段
unsigned j_flag;  // 标志寄存器
unsigned j_cs;  // 代码段
unsigned j_ip;  // 指令指针寄存器
unsigned j_bp; // 基址指针
unsigned j_di;  // 目的指针
unsigned j_es; // 附加段
unsigned j_si;  // 源变址
unsigned j_ds; // 数据段
</code></pre>

<p>} jmp_buf;
{% endcodeblock %}</p>

<p>jmp_buf 结构存放了程序当前寄存器的值，以确保使用 longjmp() 后可以跳回到该执行点上继续执行。</p>




<h4>setjmp() 与 longjmp() 函数详细说明</h4>


<p>setjmp() 与 longjmp() 函数原型如下：</p>


<p>{% codeblock %}
void <em>Cdecl longjmp(jmp_buf jmpb, int retval);
int </em>Cdecl setjmp(jmp_buf jmpb);
{% endcodeblock %}</p>

<p>_Cdecl 声明函数的参数使用标准C的进栈方式（由右向左）压栈，_Cdecl 是C语言的一种调用约定，除此以外，PASCAL 也是
调用约定之一。C标准调用约定（_Cdecl）所声明的函数不自动清除堆栈，这一事务由调用者自行负责——这也是C可以支持不固定
个数的参数的原因。此外，这一调用约定将在函数名前添加一个下划线字符，如某一函数声明为：</p>


<p>{% codeblock %}
int cdecl DoSomething(void);
{% endcodeblock %}</p>

<p>编译时将自动为 DoSomething 加上下划线前缀，即函数名变为：_DoSomething。</p>




<p>setjmp() 与 longjmp() 函数都使用了 jmp_buf 结构作为形参，它们的调用关系是这样的：</br>
首先调用 setjmp() 函数来初始化 jmp_buf 结构变量 jmpb，将当前CPU中的大部分影响到程序执行的寄存器的值存入 jmpb，
为 longjmp() 函数提供跳转，setjmp() 函数是一个有趣的函数，它能返回两次，它应该是所有库函数中唯一一个能返回两次
的函数，第一次是初始化时，返回零，第二次遇到 longjmp() 函数调用后，longjmp() 函数使 setjmp() 函数发生第二次返回，
返回值由 longjmp() 的第二个参数给出（整型，这时不应该再返回零）。</p>




<p>在使用 setjmp() 初始化 jmpb 后，可以其后的程序中任意地方使用 longjmp() 函数跳转会 setjmp() 函数的位置，longjmp() 
的第一个参数便是 setjmp() 初始化的 jmpb，若想跳转回刚才设置的 setjmp() 处，则 longjmp() 函数的第一个参数是 setjmp() 
所初始化的 jmpb 这个异常，这也说明一件事，即 jmpb 这个异常，一般需要定义为全局变量，否则，若是局部变量，当跨函数调用
时就几乎无法使用（除非每次遇到函数调用都将 jmpb 以参数传递，然而明显地，是不值得这样做的）；longjmp() 函数的第二个参数
是传给 setjmp() 的第二次返回值，这在介绍 setjmp() 函数时已经介绍过。</p>




<h4>异常处理过程</h4>


<p>先来对比（参考）一下 C++ 的异常处理，C++ 在语言层上便添加了异常处理机制，使用 try 块来包含那些可能出现错误的代码，
你可以在 try 块代码中抛出异常，C++ 使用 throw 来抛出异常。抛出异常后，将转到异常处理程序中执行，C++ 使用 catch 块来
包含那些处理异常的代码，catch 块可以接收不同类型的异常。需要说明的是，throw 一般不在 try 块内的代码中抛出异常，try 
块内的代码调用了别的函数，如函数A，函数A 又调用了函数 B，throw 可以在函数B中抛出异常，或者更深的函数调用层，无论如何，
只要有异常抛出，程序将转到 catch 处执行。</p>




<p>C中如何实现，或者明确地说是模拟这一功能？下面介绍的是一些简单的方法。现在假设 longjmp() 第二个值为1，即 setjmp() 
第二次将返回1。我们使用一组简单的宏来替代 setjmp() 和 longjmp() 以便使用：</br>
首先定义一个全局的异常：</p>


<p>{% codeblock %}
jmp_buf Jump_Buffer;
{% endcodeblock %}</p>

<p>因为 setjmp() 第一次调用初始化后返回0，第二次返回非0，可以这样定义一个宏使得它功能接近于 C++ 的 try。</p>


<p>{% codeblock %}</p>

<h1>define try if(!setjmp(Jump_Buffer))</h1>

<p>{% endcodeblock %}</p>

<p> 当 setjmp() 函数第一次0 时，取非为真，则执行 try 块内的代码，如：</p>


<p>{% codeblock %}
try {</p>

<pre><code>Test();
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>当因为调用 longjmp() 抛出异常而导致 setjmp() 第二次返回时（程序将会转到 setjmp() 函数处返回，这时，这时应该执行
的是异常处理代码。longjmp() 使 setjmp() 函数返回非0，if(!setjmp(JumpBuffer)) 中将值取非则为假，是以，异常处理放在
其后应该使用一个 else：</p>


<p>{% codeblock %}</p>

<h1>define catch else</h1>

<p>{% endcodeblock %}</p>

<p>如此看起来便跟 C++ 相似了，setjmp() 函数的第二次返回导致 if() 中表达式值为假，刚好使 catch 块得以执行，如：</p>


<p>{% codeblock %}
try  {</p>

<pre><code>Test();
</code></pre>

<p>} catch {</p>

<pre><code>puts("Error");
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>实现如 C++ 的 throw 语句，事实上以宏替换 longjmp(jmp_buf, int) 的调用：</p>


<p>{% codeblock %}</p>

<h1>define throw longjmp(Jump_Buffer, 1)</h1>

<p>{% endcodeblock %}</p>

<p>下面的例程解释如何使用这些宏：</p>


<p>{% codeblock %}</p>

<h1>include"stdio.h"</h1>

<h1>include"conio.h"</h1>

<h1>include"setjmp.h"</h1>

<p>jmp_buf Jump_Buffer;</p>

<h1>define try if(!setjmp(Jump_Buffer))</h1>

<h1>define catch else</h1>

<h1>define throw longjmp(Jump_Buffer,1)</h1>

<p>int Test(int T)<br/>
{</p>

<pre><code>if(T&gt;100)  
    throw;  
else  
      puts("OK.");  
return 0;  
</code></pre>

<p>}<br/>
int Test_T(int T)<br/>
{</p>

<pre><code>Test(T);  
return 0;  
</code></pre>

<p>}<br/>
int main()<br/>
{</p>

<pre><code>int T;  
try{  
      puts("Input a value:");  
      scanf("%d",&amp;T);  
      T++;  
      Test_T(T);  
  } catch{  
      puts("Input Error!");  
  }  
getch();  
return 0;  
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言断言简介]]></title>
    <link href="http://ibillxia.github.io/blog/2011/05/03/introduce-to-assert-in-c-language/"/>
    <updated>2011-05-03T10:31:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2011/05/03/introduce-to-assert-in-c-language</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>


<p> 断言是对某种假设条件进行检查（可理解为若条件成立则无动作，否则应报告），它可以快速发现并定位软件问题，
同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，
提高系统的可测性。实际应用时，可根据具体情况灵活地设计断言。</p>




<h2>2.标准断言机制</h2>


<p>原型定义：</p>


<p>{% codeblock %}</p>

<h1>include &lt;assert.h></h1>

<p>void assert( int expression_r_r_r );
{% endcodeblock %}</p>

<p>assert的作用是现计算表达式 expression_r_r_r ，如果其值为假（即为0），
那么它先向stderr打印一条出错信息，然后通过调用 abort来终止程序运行。</p>




<!-- more -->


<h2>3.简单实例</h2>


<p>下面给一个断言的简单实例：</p>


<p>{% codeblock %}</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;assert.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>int main( void )<br/>
{<br/>
   FILE *fp;</p>

<p>   fp = fopen( "test.txt", "w" );//以可写的方式打开一个文件，如果不存在就创建一个同名文件<br/>
   assert( fp );         //所以这里不会出错<br/>
   fclose( fp );</p>

<p>   fp = fopen( "noexitfile.txt", "r" );//以只读的方式打开一个文件，如果不存在就打开失败<br/>
   assert( fp );         //所以这里出错<br/>
   fclose( fp );         //程序永远都执行不到这里来<br/>
   return 0;<br/>
}
{% endcodeblock %}</p>

<h2>4.断言用法详解</h2>


<p>1)在函数开始处检验传入参数的合法性，如:</p>


<p>{% codeblock %}
int resetBufferSize(int nNewSize)
{
  //功能:改变缓冲区大小,
  //参数:nNewSize 缓冲区新长度
  //返回值:缓冲区当前长度
  //说明:保持原信息内容不变，nNewSize&lt;=0表示清除缓冲区
  assert(nNewSize >= 0);
  assert(nNewSize &lt;= MAX_BUFFER_SIZE);
  //...
}
{% endcodeblock %}</p>

<p>2)每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败</p>


<p>{% codeblock %}
assert(nOffset>=0 &amp;&amp; nOffset+nSize&lt;=m_nInfomationSize);  //不好
assert(nOffset >= 0);   //好
assert(nOffset+nSize &lt;= m_nInfomationSize);
{% endcodeblock %}</p>

<p>3)不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在真正运行时遇到问题</p>


<p>{% codeblock %}
assert(i++ &lt; 100);  //错误
{% endcodeblock %}</p>

<p>这是因为如果出错，比如在执行之前i=100,那么这条语句就不会执行，那么i++这条命令就没有执行。</p>


<p>{% codeblock %}
assert(i &lt; 100);    //正确
i++;
{% endcodeblock %}</p>

<p>4)assert和后面的语句应空一行,以形成逻辑和视觉上的一致感</p>




<p>5)有的地方,assert不能代替条件过滤</p>




<h2>5注意事项：</h2>


<p>1).使用assert的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。
在调试结束后，可以通过在包含#include <assert.h>的语句之前插入 #define NDEBUG 来禁用assert调用，
示例代码如下：</p>


<p>{% codeblock %}</p>

<h1>include &lt;stdio.h></h1>

<h1>define NDEBUG</h1>

<h1>include &lt;assert.h></h1>

<p>{% endcodeblock %}</p>

<p>2).ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略掉。（在C中，ASSERT是宏而不是函数），
使用ASSERT“断言”容易在debug时输出程序错误所在。而assert()的功能类似，它是ANSI C标准中规定的函数，
它与ASSERT的一个重要区别是可以用在Release版本中。</p>




<h3>推荐阅读</h3>


<p><a href="http://www.cppblog.com/oosky/archive/2006/03/26/4625.html#_Toc131314725">华为软件编程规范</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈C语言的可变参数]]></title>
    <link href="http://ibillxia.github.io/blog/2011/04/21/about-variable-parameters-in-c-language/"/>
    <updated>2011-04-21T16:50:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2011/04/21/about-variable-parameters-in-c-language</id>
    <content type="html"><![CDATA[<h2>1.问题引入</h2>


<p>
C语言中有些函数使用可变参数，比如常见的int printf( const char *format [, argument]... );，
第一个参数format是固定的，其余的参数的个数和类型都不固定。例如：</p>


<p>{% codeblock %}
printf("Enjoy yourself everyday!/n");
printf("The value is %d!/n", value);
{% endcodeblock %}</p>

<p>这种可变参数可以说是C语言一个比较难理解的部分，这里会由几个问题引发一些对它的分析。
注意：在C++中有函数重载（overload）可以用来区别不同函数参数的调用，但它还是不能表示任意数量的函数参数。</p>




<h2>2.printf（）实现原理</h2>


<p>
C语言用va_start等宏来处理这些可变参数。这些宏看起来很复杂，其实原理挺简单，
就是根据参数入栈的特点从最靠近第一个可变参数的固定参数开始，依次获取每个可变参数的地址。
下面我们来分析这些宏。</p>




<!-- more -->


<p>在stdarg.h头文件中，针对不同平台有不同的宏定义，我们选取X86平台下的宏定义：</p>


<p>{% codeblock %}
typedef char * va_list;</p>

<h1>define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )</h1>

<h1>define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</h1>

<h1>define va_arg(ap,t) ( <em>(t </em>)((ap += <em>INTSIZEOF(t)) - </em>INTSIZEOF(t)) )</h1>

<h1>define va_end(ap) ( ap = (va_list)0 )</h1>

<p>{% endcodeblock %}</p>

<p>_INTSIZEOF(n)宏是为了考虑那些内存地址需要对齐的系统，从宏的名字来应该是跟sizeof(int)对齐。
一般的sizeof(int)=4，也就是参数在内存中的地址都为4的倍数。比如，如果sizeof(n)在1－4之间，
那_INTSIZEOF(n)＝4；如果sizeof(n)在5－8之间，那么_INTSIZEOF(n)=8。</p>




<p>为了能从固定参数依次得到每个可变参数，va_start,va_arg充分利用下面两点：</br>
&nbsp;&nbsp;&nbsp;&nbsp;1．C语言在函数调用时，先将最后一个参数压入栈;</br>
&nbsp;&nbsp;&nbsp;&nbsp;2．X86平台下的内存分配顺序是从高地址内存到低地址内存</br>
<center>{% img /images/2011/IMAG2011042101.png %}</center></p>




<p>由上图可见，v是固定参数在内存中的地址，在调用va_start后，ap指向第一个可变参数。
这个宏的作用就是在v的内存地址上增加v所占的内存大小，这样就得到了第一个可变参数的地址。</p>




<p>接下来，可以这样设想，如果我能确定这个可变参数的类型，那么我就知道了它占用了多少内存，
依葫芦画瓢，我就能得到下一个可变参数的地址。</p>




<p>让我们再来看看va_arg，它先ap指向下一个可变参数，然后减去当前可变参数的大小即得到当前
可变参数的内存地址，再做个类型转换，返回它的值。</br>
要确定每个可变参数的类型，有两种做法，要么都是默认的类型，要么就在固定参数中包含足够的
信息让程序可以确定每个可变参数的类型。比如，printf，程序通过分析format字符串就可以
确定每个可变参数大类型。</br>
最后一个宏就简单了，va_end使得ap不再指向有效的内存地址。</p>




<p>看了这几个宏，不禁让我再次感慨，C语言太灵活了，而且代码可以写得非常简洁，
虽然有时候让人看得不是很明白，但是一旦明白 过来，你肯定会为它击掌叫好！</br>
其实在varargs.h头文件中定义了UNIX System V实行的va系列宏，而上面在stdarg.h头文件中
定义的是ANSI C形式的宏，这两种宏是不兼容的，一般说来，我们应该使用ANSI C形式的va宏。</p>




<h2>3.实战演练</h2>


<p>有没有办法写一个函数，这个函数参数的具体形式可以在运行时才确定？</br>
系统提供了vprintf系列格式化字符串的函数，用于编程人员封装自己的I/O函数。</p>


<p>{% codeblock %}
int vprintf / vscanf(const char * format, va_list ap); // 从标准输入/输出格式化字符串
int vfprintf / vfsacanf(FILE * stream, const char * format, va_list ap);// 从文件流
int vsprintf / vsscanf(char * s, const char * format, va_list ap); // 从字符串
// 例1：格式化到一个文件流，可用于日志文件
FILE *logfile;
int WriteLog(const char * format, ...)
{
   va_list arg_ptr;
   va_start(arg_ptr, format);
   int nWrittenBytes = vfprintf(logfile, format, arg_ptr);
   va_end(arg_ptr);
   return nWrittenBytes;
}
...
// 调用时，与使用printf()没有区别。
WriteLog("%04d-%02d-%02d %02d:%02d:%02d %s/%04d logged out.", nYear, nMonth, nDay, nHour, nMinute, szUserName, nUserID);
{% endcodeblock %}</p>

<p>同理，也可以从文件中执行格式化输入；或者对标准输入输出，字符串执行格式化。</br>
在上面的例1中，WriteLog()函数可以接受参数个数可变的输入，本质上，它的实现需要vprintf()的支持。
如何真正实现属于自己的可变参数函数，包括控制每一个传入的可选参数。</p>




<h2>4.关于va()函数和va宏</h2>


<p>C语言支持va函数，作为C语言的扩展--C++同样支持va函数，但在C++中并不推荐使用，C++引入的
多态性同样可以实现参数个数可变的函数。不过，C++的重载功能毕竟只能是有限多个可以预见的参数个数。
比较而言，C中的va函数则可以定义无穷多个相当于C++的重载函数，这方面C++是无能为力的。va函数的
优势表现在使用的方便性和易用性上，可以使代码更简洁。C编译器为了统一在不同的硬件架构、硬件
平台上的实现，和增加代码的可移植性，提供了一系列宏来屏蔽硬件环境不同带来的差异。</p>




<p>ANSI C标准下，va的宏定义在stdarg.h中，它们有：va_list，va_start()，va_arg()，va_end()。</p>


<p>{% codeblock %}
// 例2：求任意个自然数的平方和：
int SqSum(int n1, ...)
{
   va_list arg_ptr;
   int nSqSum = 0, n = n1;
   va_start(arg_ptr, n1);
   while (n > 0)
  {
nSqSum += (n * n);
n = va_arg(arg_ptr, int);
  }
  va_end(arg_ptr);
  return nSqSum;
}
// 调用时
int nSqSum = SqSum(7, 2, 7, 11, -1);
{% endcodeblock %}</p>

<p>可变参数函数的原型声明格式为：</p>


<p>{% codeblock %}
type VAFunction(type arg1, type arg2, ... );
{% endcodeblock %}</p>

<p>参数可以分为两部分：个数确定的固定参数和个数可变的可选参数。函数至少需要一个固定参数，
固定参数的声明和普通函数一样；可选参数由于个数不确定，声明时用"..."表示。固定参数和可选
参数公同构成一个函数的参数列表。借助上面这个简单的例2，来看看各个va_xxx的作用。</p>




<p>va_list arg_ptr：定义一个指向个数可变的参数列表指针；</br>
va_start(arg_ptr, argN)：使参数列表指针arg_ptr指向函数参数列表中的第一个可选参数，
说明：argN是位于第一个可选参数之前的固定参数，（或者说，最后一个固定参数；...
之前的一个参数），函数参数列表中参数在内存中的顺序与函数声明时的顺序是一致的。
如果有一va函数的声明是void va_test(char a, char b, char c, ...)，则它的固定
参数依次是a,b,c，最后一个固定参数argN为c，因此就是va_start(arg_ptr, c)。</br>
va_arg(arg_ptr, type)：返回参数列表中指针arg_ptr所指的参数，返回类型为type，
并使指针arg_ptr指向参数列表中下一个参数。</br>
va_copy(dest, src)：dest，src的类型都是va_list，va_copy()用于复制参数列表指针，将dest初始化为src。</br>
va_end(arg_ptr)：清空参数列表，并置参数指针arg_ptr无效。说明：指针arg_ptr被置无效后，
可以通过调用va_start()、va_copy()恢复arg_ptr。每次调用va_start() / va_copy()后，
必须得有相应的va_end()与之匹配。参数指针可以在参数列表中随意地来回移动，
但必须在va_start() ... va_end()之内。</p>



]]></content>
  </entry>
  
</feed>