<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Pointer | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/pointer/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-05-24T23:52:01+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言函数指针与C++函数调用操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/"/>
    <updated>2014-05-24T21:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在编程过程中，一些特殊的时候，我们需要向一个函数传递另一个函数的地址（比如在快速排序中，我们需要传入两个元素大小比较的函数的地址），此时在C语言中一般是通过传递一个函数指针来实现。最近在看《STL源码剖析》一书，上面提到，在C++中其实可以通过另一种方式实现，那就是函数调用操作符<code>()</code> 。本文首先介绍一下C语言中函数指针的用法，然后再介绍C++中函数调用操作符的用法。</p>

<h2>C语言中的函数指针</h2>

<p>我们先直接看一个例子吧。这个例子比较全面而且简单，其中的函数指针是带参数且有返回值的函数指针，而且还有把函数指针作为参数来传递的代码。这个例子来自 <a href="http://blog.jobbole.com/44639/">jobbole伯乐在线</a>，代码如下：</p>

<!-- more -->


<p>```</p>

<h1>include &lt;stdio.h></h1>

<p>// 函数原型
int add(int x, int y);
int subtract(int x, int y);
int domath(int (*mathop)(int, int), int x, int y);</p>

<p>// 加法 x+ y
int add(int x, init y) {</p>

<pre><code>return x + y;
</code></pre>

<p>}</p>

<p>// 减法 x - y
int subtract(int x, int y) {</p>

<pre><code>return x - y;
</code></pre>

<p>}</p>

<p>// 根据输入执行函数指针
int domath(int (*mathop)(int, int), int x, int y) {</p>

<pre><code>return (*mathop)(x, y);
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>// 用加法调用domath
int a = domath(add, 10, 2);
printf("Add gives: %d\n", a);

// 用减法调用domath
int b = domath(subtract, 10, 2);
printf("Subtract gives: %d\n", b);
</code></pre>

<p>}
```</p>

<p>在函数 <code>domath</code> 中，我们可以根据传入的 <code>mathop</code> 函数指针来做不同的计算操作。另外，在该文中，最后提到函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名，解引用符 <code>*</code> 和取地址符 <code>&amp;</code> 用在函数名之前基本上都是多余的。这个之前还真不知道，新技能get，哈哈</p>

<h4>使用typedef</h4>

<p>在C语言中，对于函数指针，我们可以使用 <code>typedef</code> 将其定义为一种数据类型，这样我们就可以定义这种类型的变量了，就像使用普通的变量类型一样。下面是一个具体的定义（来自<a href="http://stackoverflow.com/questions/4295432/typedef-function-pointer">stackoverflow</a>）：</p>

<blockquote><p>typedef   void      (*FunctionFunc)  ( );
//         ^                ^         ^
//     return type      type name  arguments</p></blockquote>

<p>这里 <code>typedef</code> 的使用方法与一般的 <code>typedef A B</code> 的使用方式不不大一样的，如果没有接触过这种用法，可能开起来很别扭（在很多开源库中可能经常会碰到）。下面是其具体使用的实例（不完整代码）：</p>

<p><code>
FunctionFunc x;
void doSomething() { printf("Hello there\n"); }
x = &amp;doSomething;
x(); //prints "Hello there"
</code></p>

<p>根据上面提到的隐式转换，这里的取址符其实是没有必要的。关于C语言的函数指针就介绍到这儿了，接下来介绍一下C++的函数调用操作符。</p>

<h2>C++中的函数调用操作符</h2>

<p>在C++中，函数调用操作符是指左右小括弧 <code>()</code> ，该操作符是可以重载的。许多 STL 算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时按照使用者自定义的大小关系进行排序）。 上面讲了，在C语言中使用者是通过传递函数指针的方式来实现的。然而，函数指针有一些缺点，最重要的是它无法持有自己的状态（这里指局部状态，local states，具体可以通过后面的例子来理解），也无法达到组件技术中的可适配性 —— 也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>

<p>在C++中，对应于C中函数指针的东西是仿函数（functor），使用起来就像函数一样。其实现方法是对某个 class 进行 <code>operator()</code> 重载，他就成为一个仿函数。而要成为一个可适配（adaptable）的仿函数，还需要其他的一些努力（在《STL源码剖析》一书的第8章，关于适配器（adaptor）的内容）。这里，我们只拿书中的那个例子来简单的看一下仿函数的定义和使用方法吧。代码如下：</p>

<p>```</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>// 对plus进行operator() 重载，使得 plus 变成了一个仿函数
template<class T>
struct plus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x+y;}
</code></pre>

<p>};</p>

<p>// 对 minus 进行operator() 重载，使得 minus 变成了一个仿函数
template<class T>
struct minus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x-y;}
</code></pre>

<p>};</p>

<p>int main(){</p>

<pre><code>// 以下产生仿函数对象
plus&lt;int&gt; plusObj;
minus&lt;int&gt; minusObj;
// 以下使用仿函数，就像使用一般函数一样
cout&lt;&lt;plusObj(3,5)&lt;&lt;endl;
cout&lt;&lt;minusObj(3,5)&lt;&lt;endl;
// 也可以这样使用，通过临时对象（匿名对象）
cout&lt;&lt;plus&lt;int&gt;()(3,5)&lt;&lt;endl;
cout&lt;&lt;minus&lt;int&gt;()(3,5)&lt;&lt;endl;
return 0;
</code></pre>

<p>}
```</p>

<p>这里的 <code>plus&lt;T&gt;</code> 和 <code>minus&lt;T&gt;</code> 已经非常接近 STL 的实现了，唯一的差别是它缺乏“可适配能力”，关于 STL 中的适配器（adaptor），我现在也还没看完该书，也还不太了解，在后续文章中应该会介绍到。读者可以自行google。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 应用程序性能优化之 new/delete 操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator/"/>
    <updated>2014-05-11T20:33:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>

<p>C++ 程序的存储空间可以分为静态/全局存储区、栈区和堆区。下图展示了一个典型的Linux C/C++ 程序内存空间布局：</p>

<center><img src="/images/2014/IMAG2014051101.png"></center>


<p>其中，每一部分的具体涵义如下：<br/>
- <strong>代码段（.text）</strong>：这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是<strong>只读</strong>的，防止程序由于错误而修改自身的指令。<br/>
- <strong>初始化数据段（.data）</strong>：这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=100;</code> 。 需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用 exec 函数启动该程序时从源程序文件中读入。<br/>
- <strong>未初始化数据段（.bss）</strong>：位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：<code>int sum;</code><br/>
- <strong>堆（Heap）</strong>：这个段用于在程序中进行动态内存申请，例如经常用到的 malloc，new 系列函数就是从这个段中申请内存。<br/>
- <strong>栈（Stack）</strong>：函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。<br/>
静态/全局存储区和栈区一般在程序编译阶段决定；而堆区则随着程序的运行而动态变化，每一次程序运行都会有不同的行为，因此动态内存管理对于一个程序在运行过程中占用的内存大小及程序运行性能有非常重要的影响。 本文主要探讨在C++中如何管理动态内存，以及如何使用 C++ 的语言特性来提高动态内存的管理效率，减少错误的发生。</p>

<!-- more -->


<h2>2. new/delete 操作符</h2>

<h4>2.1 C++内置new/delete的原型</h4>

<p>一般来说 C++ 的运行库提供了默认的全局 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的实现，程序也可以用自定义的实现来取代运行库的实现。 下面是 C++ 标准中定义的 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的声明（位于 <code>include/c++/new</code> 文件中）：</p>

<p>```
namespace std {
  class bad_alloc : public exception {</p>

<pre><code>public:
  bad_alloc() throw() { }
  virtual ~bad_alloc() throw();
  virtual const char* what() const throw();
</code></pre>

<p>  };
  struct nothrow_t { };
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler) throw();
} // namespace std</p>

<p>void<em> operator new(std::size_t) throw (std::bad_alloc);  // (1)
void</em> operator new<a href="std::size_t"></a> throw (std::bad_alloc);
void operator delete(void<em>) throw();
void operator delete<a href="void*"></a> throw();
void</em> operator new(std::size_t, const std::nothrow_t&amp;) throw();  // (2)
void<em> operator new<a href="std::size_t,%20const%20std::nothrow_t&amp;"></a> throw();
void operator delete(void</em>, const std::nothrow_t&amp;) throw();
void operator delete<a href="void*,%20const%20std::nothrow_t&amp;"></a> throw();
// Default placement versions of operator new.
inline void<em> operator new(std::size_t, void</em> <strong>p) throw() { return </strong>p; }  // (3)
inline void<em> operator new<a href="std::size_t,%20void*%20__p"></a> throw() { return __p; }
// Default placement versions of operator delete.
inline void  operator delete  (void</em>, void*) throw() { }
inline void  operator delete<a href="void*,%20void*"></a> throw() { }
```</p>

<p>其中最后的 <code>inline</code> 函数是 <code>placement</code> 版本的 new/delete 操作，其特点在于分配的内存块的起始地址由用户给定（通过参数 <code>void* __p</code>）。 而前面两种 <code>new/delete</code> （(1)和(2)处）是系统决定待分配内存块的起始地址，区别在于：第一个在分配失败是会抛出 <code>bad_alloc</code> 异常（这是C++标准要求的）；而第二个则不抛出异常，返回0。 很多应用程序都没有处理内存分配的失败情况，但相对于一个需要长期稳定运行的系统来说，这种处理是必不可少的。 应用程序可以通过捕获 <code>bad_alloc</code> 异常或者检查返回值来检查内存分配是否成功，而更好的方法是使用C++中的 <code>new_handler()</code> 函数。 C++规定 <code>new_handler</code> 要执行如下操作中的一种：</p>

<ul>
<li>使 <code>new</code> 有更多的内存可用，然后返回</li>
<li>抛出一个 <code>bad_alloc</code> 或其派生类的异常</li>
<li>调用 <code>abort()</code> 或者 <code>exit()</code> 退出</li>
</ul>


<h4>2.2 使用 <code>new_handler</code> 自定义异常处理</h4>

<p>下面看一个例子，看看如何使用 <code>new_handler</code> 处理内存分配失败的情况：</p>

<p>```</p>

<h1>include<new></h1>

<h1>include<cstdio></h1>

<h1>include&lt;Windows.h></h1>

<p>using namespace std;
char *gPool = NULL;
void my_new_handler();</p>

<p>int main(){</p>

<pre><code>set_new_handler(my_new_handler);
gPool = new char[512*1024*1024];
if(gPool!=NULL){
    printf("Preserve 512MB memory at %x.\n",gPool);
}
char *p = NULL;
for(int i=0;i&lt;4;i++){
    p = new char[512*1024*1024];
    printf("%d * 512M, p = %x\n",i+1,p);
    Sleep(5000); // 休眠5s
}
printf("Done.\n");
return 0;
</code></pre>

<p>}</p>

<p>void my_new_handler(){</p>

<pre><code>if(gPool!=NULL){
    printf("try to get more memory...\n");
    delete[] gPool; // 释放512MB内存空间
    gPool = NULL;
    return;
}else{
    printf("I can not help...\n");
    throw bad_alloc();  // 分配失败，抛出异常
}
return;
</code></pre>

<p>}
```</p>

<p>在 Windows 上编译并运行（使用Code::Blocks 13.12 IDE），得到如下输出：</p>

<p>```
Preserve 512MB memory at 7e0020.
1 * 512M, p = 207f0020
2 * 512M, p = 40800020
try to get more memory...
3 * 512M, p = 7e0020
I can not help...
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc</p>

<p>This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
```</p>

<p>在 Windows 的 win32 程序中，一个进程可以访问的内存空间是 4GB，但可以用来动态分配的最大内存是 2GB，因而上面的程序执行到第3次（为神马不是第4次？）动态内存分配时由于内存不够，调用了 <code>my_new_handler</code> 获得了内存（可以看到第3次分配的内存的地址和Preserve的内存地址是一样的），而当执行第4次内存分配时，<code>gPool</code> 已被分配，于是 <code>my_new_handler</code> 中抛出了 <code>bad_alloc</code> 异常，导致程序退出。 另外，在程序实际运行过程当中，会发现任务管理器中内存占用不会往上飙，这可能是因为操作系统的动态内存管理策略在作怪，不会说你一申请就立马全部给你，只是建立了一个映射表，只有当你真正用的时候才会给你。</p>

<h4>2.3 使用 placement new</h4>

<p>在 C++ 内置 <code>new/delete</code> 中最后的一种是 placement 形式的 <code>new/delete</code> ，即分配的内存地址有用户给定。下面是一个最简单的实例：</p>

<p>```</p>

<h1>include <cstdio></h1>

<h1>include <new></h1>

<p>using namespace std;</p>

<p>int main()
{</p>

<pre><code>char buffer[100];
char *p = new(buffer) char[20]; // call placement new
printf("Address of buffer: %x, and p: %x.\n",buffer,p);
return 0;
</code></pre>

<p>}
// output: Address of buffer: 28feb8, and p: 28feb8.
```</p>

<p>可以看到 <code>buffer</code> 和 <code>p</code> 的地址是一样的。在大型应用程序中，我们可以充分利用 <code>placement new</code> 的特性，实现自己管理（分配、释放等）本应用的内存空间，基本思路就是： 首先申请一大片内存，然后对每个小的动态内存分配都使用 <code>placement new</code> 的方式进行申请。</p>

<h4>2.4 重载 placement new</h4>

<p>在 <code>new</code> 操作符中，除了可以使用自定义申请的内存的大小及位置，我们还可以通过重载系统的 <code>new/delete</code> 操作符来加入其它一些附加参数，但仍称之为 <code>placement new</code> 。例如：</p>

<p>```</p>

<h1>include<cstdio></h1>

<h1>include<new></h1>

<p>using namespace std;</p>

<h1>define DEBUG</h1>

<h1>ifdef DEBUG</h1>

<p>// 自定义 new 操作符
void *operator new<a href="unsigned%20int%20n,%20const%20char*%20file,%20int%20line"></a>{</p>

<pre><code>printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
return ::operator new(n);
</code></pre>

<p>}
// 自定义 delete 操作符
// void operator delete(void <em>p,const char </em>file, int line){
void operator delete<a href="void%20*p,const%20char%20*file,%20int%20line"></a>{</p>

<pre><code>printf("delete at file %s, in line %d\n",file,line);
::operator delete(p);
return;
</code></pre>

<p>}
// 宏定义，必须放在重载函数之后</p>

<h1>define new new(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>define delete delete(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>endif</h1>

<p>int main(){</p>

<pre><code>char *p = new char[10];
//delete p;  // delete 的重载还有问题 "error: type 'int' argument given to 'delete', expected pointer"
delete[] p;  // 直接报语法错误，"error: expected primary-expression before ']' token"
return 0;
</code></pre>

<p>}
// output: Alloc size: 10 at file D:\Programs\test\main.cpp, in line 22
```</p>

<p>这在 <code>DEBUG</code> 模式下非常好使。</p>

<p>更新：关于 <code>placement new</code> 的 demo 改为如下代码后就没问题了：</p>

<p>```</p>

<h1>include<cstdio></h1>

<h1>include<new></h1>

<p>using namespace std;</p>

<h1>define DEBUG</h1>

<h1>ifdef DEBUG</h1>

<p>// 自定义 new 操作符
void *operator new<a href="unsigned%20int%20n,%20const%20char*%20file,%20int%20line"></a>{</p>

<pre><code>printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
return ::operator new(n);
</code></pre>

<p>}
// 自定义 delete 操作符
void operator delete(void <em>p,char </em>file, int line){</p>

<pre><code>printf("Delete at file %s, in line %d\n",file,line);
::operator delete(p);
return;
</code></pre>

<p>}
// 宏定义，必须放在重载函数之后</p>

<h1>define new new(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>define delete(ptr) delete(ptr,<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>endif</h1>

<p>int main(){</p>

<pre><code>char *p = new char[10];
operator delete(p);
return 0;
</code></pre>

<p>}
```</p>

<p>但是还是不知道之前的代码为什么会出现这个错误，已在 <a href="http://stackoverflow.com/questions/23614215/destructor-error-in-c-type-int-argument-given-to-delete-expected-pointer">StackOverFlow上提问</a>，希望能得到满意的答案。</p>
]]></content>
  </entry>
  
</feed>