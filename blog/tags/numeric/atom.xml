<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: numeric | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/numeric/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-10-26T22:27:09+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(5.3) 算法之基本算法algobase]]></title>
    <link href="http://ibillxia.github.io/blog/2014/10/25/insight-into-stl-5-algorithm-3-base-algorithms-algobase/"/>
    <updated>2014-10-25T21:13:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/10/25/insight-into-stl-5-algorithm-3-base-algorithms-algobase</id>
    <content type="html"><![CDATA[<p>本文主要介绍STL中的数值算法，主要涉及到的源码文件有 <code>stl_algobase.h</code> 等。</p>

<p>在 <code>stl_algobase.h</code> 中定义的算法都比较简单基础，主要涉及区间相等判断、区间填充、求极值、交换、拷贝、字典序比较等算法，而其他诸如查找、计数、排序、旋转等算法则在文件 <code>stl_algo.h</code> 中实现。在algobase基本算法中，除了字典序比较、复制/拷贝算法外，其他都比较简单，这里先依次介绍这些简单的算法，然后再介绍字典序比较和拷贝算法。</p>

<h2>1. 交换、填充等简单算法</h2>

<p>由于这里很多算法比较简单（基本都在10行以内，甚至很多就一行代码），就不一一粘贴代码了。</p>

<p><strong>iter_swap</strong> ：将两个 ForwardIterators 所指的对象对调，通过申请一个临时变量、三次赋值，就完成了。</p>

<p><strong>min/max</strong> ：求两个数中的小、大者，还有一个版本可以指定的比较方法（仿函数）。</p>

<p><strong>fill</strong> ：将 <code>[first, last)</code> 内的所有元素改填为新值 value。</p>

<p><strong>fill_n</strong> ：将 <code>[first, last)</code> 内的前n个元素改填为新值 value，返回迭代器指向被填入的最后一个元素的下一位置。</p>

<p><strong>mismatch</strong> ：用来平行比较两个序列，指出两者之间的第一个不匹配点，返回一对迭代器（Iterators Pair），分别指向两序列中的不匹配点。</p>

<p><strong>equal</strong> ：判断两个序列在 <code>[first, last)</code> 区间内相等，如果第二个序列元素较多，将不予考虑，只有两个序列在各自区间内对应相等才返回true，否则返回false。</p>

<!-- more -->


<h2>2. 字典序比较</h2>

<p><code>lexicographical_compare</code> 以“字典序排列方式”对两个序列 <code>[first, last)</code> 和 <code>[first2, last2)</code> 进行比较。比较操作针对两个序列中的对应位置上的元素进行，直到某一对不相等或同时到达尾部或仁义序列到达尾部。该算法其实并不复杂，但有一点值得注意，那就当且仅当第一个序列字典序小于第二个序列时才返回true，以下是各种情况下的返回值：</p>

<ul>
<li>发现不相等，如果<strong>第一序列元素较小，返回true</strong>，否则返回false；</li>
<li>到达last1而尚未到达last2，返回true；</li>
<li>到达last2而尚未到达last1，返回false；</li>
<li>同时到达last1和last2，返回false。</li>
</ul>


<p>源码如下：
```
template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(<em>InputIter1 __first1, </em>InputIter1 <strong>last1, _InputIter2 </strong>first2, _InputIter2 <strong>last2) {
  for ( ; </strong>first1 != <strong>last1 &amp;&amp; </strong>first2 != <strong>last2; ++</strong>first1, ++__first2) {</p>

<pre><code>if (*__first1 &lt; *__first2)
  return true;
if (*__first2 &lt; *__first1)
  return false;
</code></pre>

<p>  }
  return <strong>first1 == </strong>last1 &amp;&amp; <strong>first2 != </strong>last2;
}
```</p>

<p>除了这个默认的版本外，还有一个版本提供比较方法（仿函数）的参数。另外，对于纯字符串的比较，SGI STL还做了进一步优化，使用原生指针和C标准函数 <code>memcmp()</code> 进行比较，如下：</p>

<p>```
inline bool
lexicographical_compare(const unsigned char<em> __first1, const unsigned char</em> __last1,</p>

<pre><code>                    const unsigned char* __first2,const unsigned char* __last2) {
</code></pre>

<p>  const size_t <strong>len1 = </strong>last1 - <strong>first1;
  const size_t </strong>len2 = <strong>last2 - </strong>first2;
  const int <strong>result = memcmp(</strong>first1, <strong>first2, min(</strong>len1, <strong>len2));
  return </strong>result != 0 ? <strong>result &lt; 0 : </strong>len1 &lt; __len2;
}
```</p>

<h2>3. 复制/拷贝算法</h2>

<p>在很多应用程序中，复制copy是一个很常见的操作，特别是在赋值的时候。对于稍微复杂的对象，在不同的语言中赋值时会有一些差别，有的编程语言赋值仅仅是对等号右边的对象的一个引用，而并没有正真的产生一个新的对象，更不用说对象中可能包含的对象成员，例如Python当中的赋值、浅拷贝copy和深拷贝deepcopy等。</p>

<p>而STL 中的copy，除了简单的单一对象的拷贝之外，还有序列区间的拷贝等，这里就涉及到空间分配和时间效率问题。在C++中，复制操作主要是运用assignment operator（复制运算符） 或 copy constructor（拷贝构造函数），在STL的copy算法中使用的是前者，而对于某些具有trivial assignment operator的数据，则可以使用内存直接复制行为（例如C标准库函数memmove、memcpy等），就能极大的节省时间。SGI STL用尽各种办法，包括函数重载、型别特性、偏特化（partial specialization）等技巧（关于偏特化请参见 <a href="http://www.jellythink.com/archives/410">C++模板特化与偏特化</a>），无所不用其极地加强效率。</p>

<p>除了上面提到的元素型别、偏特化等问题，还有元素复制顺序的问题。copy 算法是将原始区间 <code>[first, last)</code> 内的元素复制到目标区间 <code>[result, result+last-first)</code> 区间内，复制时既可以从 first 开始往 last 复制，但也可以从 last-1开始向 first 复制，后者在 STL 另取名为 copy_backward_。从后往前复制的好处在于，不用担心目标区间与原始区间有重叠，因为如果有重叠区域，那么简单的 copy 时，对于原始数据而言 <code>[result, last)</code> 区间的数据在被复制前被修改了，从而得不到预期的结果。当然，有一种情况使用 copy 不用担心这个问题，那就是对于迭代器为原生指针，使用 memmove （而不是 memcpy，关于二者的区别参见 <a href="http://stackoverflow.com/questions/4415910/memcpy-vs-memmove">memcpy() vs memmove()</a>）进行复制，此时 memmove 会先将整个区间复制下来，没有被覆盖的危险。</p>

<p>在介绍 copy 算法的源码具体实现前，根据源码及其注释再做一个简单的小结：copy 算法中的一些辅助函数有两个目的，其一是对于简单的数据类型尽量使用 memmove，其二是对于具有 RandomAccessIterators 的对象使用一个计数器来进行循环；除此之外，SGI STL针对编译器是否具有函数模板偏特化、类模板偏特化等进行了适配。下面是 copy 的源码，其中添加了比较详细具体的注释：</p>

<p>```
// 首先是几个与偏特化无关的公用的3个函数
template <class _InputIter, class _OutputIter, class _Distance>
inline <em>OutputIter
__copy(</em>InputIter <strong>first, _InputIter </strong>last,</p>

<pre><code>   _OutputIter __result,input_iterator_tag, _Distance*){
</code></pre>

<p>  for ( ; <strong>first != </strong>last; ++<strong>result, ++</strong>first) // 使用迭代器遍历和复制</p>

<pre><code>*__result = *__first;
</code></pre>

<p>  return <strong>result;
}
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
</strong>copy(<em>RandomAccessIter __first, </em>RandomAccessIter __last,</p>

<pre><code>   _OutputIter __result, random_access_iterator_tag, _Distance*){
</code></pre>

<p>  for (_Distance <strong>n = </strong>last - <strong>first; </strong>n > 0; --__n) { //对于随机访问迭代器，使用一个计数器n</p>

<pre><code>*__result = *__first;
++__first;
++__result;
</code></pre>

<p>  }
  return <strong>result;
}
template <class _Tp>
inline _Tp*
</strong>copy_trivial(const <em>Tp* __first, const </em>Tp<em> <em>_last, </em>Tp</em> <strong>result) {
  memmove(</strong>result, <strong>first, sizeof(_Tp) * (</strong>last - <strong>first)); // 直接使用 memmove
  return </strong>result + (<strong>last - </strong>first);
}
//============== __STL_FUNCTION_TMPL_PARTIAL_ORDER 对于具有函数模板偏特性的编译器</p>

<h1>if defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)</h1>

<p>template <class _InputIter, class _OutputIter>
inline <em>OutputIter
__copy_aux2(</em>InputIter <strong>first, _InputIter </strong>last, <em>OutputIter <strong>result, </strong>false_type) { // false_type 的重载版
  return <strong>copy(</strong>first, <strong>last, </strong>result, <strong>ITERATOR_CATEGORY(</strong>first), <strong>DISTANCE_TYPE(</strong>first));
}
template <class _InputIter, class _OutputIter>
inline </em>OutputIter
<strong>copy_aux2(_InputIter </strong>first, <em>InputIter __last, </em>OutputIter <strong>result, </strong>true_type) { // true_type 的重载版
  return <strong>copy(</strong>first, <strong>last, </strong>result, <strong>ITERATOR_CATEGORY(</strong>first), <strong>DISTANCE_TYPE(</strong>first));
}</p>

<h1>ifndef <strong>USLC</strong></h1>

<p>template <class _Tp>
inline <em>Tp*
__copy_aux2(</em>Tp<em> <em>_first, </em>Tp</em> <strong>last, _Tp* </strong>result, <strong>true_type) { // 原生指针的重载版
  return </strong>copy_trivial(<strong>first, </strong>last, __result);
}</p>

<h1>endif /<em> <strong>USLC</strong> </em>/</h1>

<p>template <class _Tp>
inline <em>Tp*
__copy_aux2(const </em>Tp<em> <em>_first, const </em>Tp</em> <strong>last, _Tp* </strong>result, <strong>true_type) { // 常量指针的重载版
  return </strong>copy_trivial(<strong>first, </strong>last, <strong>result);
}
template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter
</strong>copy_aux(<em>InputIter __first, </em>InputIter <strong>last, _OutputIter </strong>result, <em>Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator </em>Trivial;
  return <strong>copy_aux2(</strong>first, <strong>last, </strong>result, <em>Trivial());
}
template <class _InputIter, class _OutputIter>
inline </em>OutputIter
copy(<em>InputIter __first, </em>InputIter <strong>last, _OutputIter </strong>result) { //最终的对外接口
  return <strong>copy_aux(</strong>first, <strong>last, </strong>result, <strong>VALUE_TYPE(</strong>first));
}
//============== __STL_CLASS_PARTIAL_SPECIALIZATION 对于具有类模板偏特性的编译器</p>

<h1>elif defined(__STL_CLASS_PARTIAL_SPECIALIZATION)</h1>

<p>template <class _InputIter, class _OutputIter, class _BoolType>
struct <strong>copy_dispatch { // 类1，泛化版
  static <em>OutputIter copy(</em>InputIter </strong>first, <em>InputIter __last, </em>OutputIter __result) {</p>

<pre><code>typedef typename iterator_traits&lt;_InputIter&gt;::iterator_category _Category;
typedef typename iterator_traits&lt;_InputIter&gt;::difference_type _Distance;
return __copy(__first, __last, __result, _Category(), (_Distance*) 0);
</code></pre>

<p>  }
};
template <class _Tp>
struct <strong>copy_dispatch&lt;<em>Tp*, </em>Tp*, </strong>true_type>{ // 类2，特化版
  static <em>Tp* copy(const </em>Tp<em> <em>_first, const </em>Tp</em> <strong>last, _Tp* </strong>result) {</p>

<pre><code>return __copy_trivial(__first, __last, __result);
</code></pre>

<p>  }
};
template <class _Tp>
struct <strong>copy_dispatch<const _Tp*, _Tp*, __true_type>{ // 类3，特化版
  static <em>Tp* copy(const </em>Tp* </strong>first, const <em>Tp* __last, </em>Tp* __result) {</p>

<pre><code>return __copy_trivial(__first, __last, __result);
</code></pre>

<p>  }
};
template <class _InputIter, class _OutputIter>
inline <em>OutputIter
copy(</em>InputIter <strong>first, _InputIter </strong>last, <em>OutputIter __result) { // 对外接口
  typedef typename iterator_traits<_InputIter>::value_type </em>Tp;
  typedef typename <strong>type_traits<_Tp>::has_trivial_assignment_operator _Trivial;
  return </strong>copy_dispatch&lt;<em>InputIter, </em>OutputIter, _Trivial></p>

<pre><code>::copy(__first, __last, __result);
</code></pre>

<p>}
//============== 其他，完全不具有偏特化特性的情况</p>

<h1>else /<em> __STL_CLASS_PARTIAL_SPECIALIZATION </em>/</h1>

<p>template <class _InputIter, class _OutputIter>
inline <em>OutputIter
copy(</em>InputIter <strong>first, _InputIter </strong>last, _OutputIter <strong>result){ // 对外接口，泛化版
  return </strong>copy(<strong>first, </strong>last, <strong>result, </strong>ITERATOR_CATEGORY(<strong>first), </strong>DISTANCE_TYPE(__first));
}</p>

<h1>define <em>_SGI_STL_DECLARE_COPY_TRIVIAL(</em>Tp)                                \</h1>

<p>  inline <em>Tp* copy(const </em>Tp<em> <em>_first, const </em>Tp</em> <strong>last, _Tp* </strong>result) { \ // 对外接口，特化版</p>

<pre><code>memmove(__result, __first, sizeof(_Tp) * (__last - __first));          \
return __result + (__last - __first);                                  \
</code></pre>

<p>  }</p>

<p><strong>SGI_STL_DECLARE_COPY_TRIVIAL(char)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(signed char)
<strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned char)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(short)
<strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned short)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(int)
<strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned int)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(long)
__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long)</p>

<h1>ifdef __STL_HAS_WCHAR_T</h1>

<p>__SGI_STL_DECLARE_COPY_TRIVIAL(wchar_t)</p>

<h1>endif</h1>

<h1>ifdef _STL_LONG_LONG</h1>

<p><strong>SGI_STL_DECLARE_COPY_TRIVIAL(long long)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long long)</p>

<h1>endif</h1>

<p><strong>SGI_STL_DECLARE_COPY_TRIVIAL(float)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(double)
__SGI_STL_DECLARE_COPY_TRIVIAL(long double)</p>

<h1>undef __SGI_STL_DECLARE_COPY_TRIVIAL</h1>

<h1>endif /<em> __STL_CLASS_PARTIAL_SPECIALIZATION </em>/</h1>

<p>```</p>

<p>以上是 copy 的完整代码，关于复制还有两个接口，一个是 <code>copy_n</code>，另一个是 <code>copy_backward</code>，前者复制区间 <code>[first, last)</code> 中前 n 个元素，后者从last-1 往 first 复制，这里就不详细展开了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(5.2) 算法之数值算法]]></title>
    <link href="http://ibillxia.github.io/blog/2014/10/19/insight-into-stl-5-algorithm-2-numeric-algorithms/"/>
    <updated>2014-10-19T20:28:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/10/19/insight-into-stl-5-algorithm-2-numeric-algorithms</id>
    <content type="html"><![CDATA[<p>本文主要介绍STL中的数值算法，主要涉及到的源码文件有 <code>stl_numberic.h</code>、<code>numeric</code>、<code>stl_relops.h</code> 等。</p>

<p>STL 数值算法主要包含以下几个算法（来自<a href="http://www.cplusplus.com/reference/numeric/">C++文档</a>）：</p>

<ul>
<li>accumulate: Accumulate values in range</li>
<li>adjacent_difference: Compute adjacent difference of range</li>
<li>inner_product: Compute cumulative inner product of range</li>
<li>partial_sum: Compute partial sums of range</li>
<li>iota: Store increasing sequence</li>
<li>power: power(x,n) 1 multiply by x n times (not in C++ standard)</li>
</ul>


<p>下面一一介绍每个算法的实现。</p>

<h3>1. accumulate</h3>

<p>该算法计算 init 和区间 [first, last) 内所有元素的总和。注意，必须提供 init 的初始值，这样即使 first=last 区间为空，仍能得到一个明确定义的值。当 init=0 时，即为计算 [first, last) 区间内所有元素的总和。具体实现有两个版本，如下：</p>

<p>```
template <class _InputIterator, class _Tp>
<em>Tp accumulate(</em>InputIterator <strong>first, _InputIterator </strong>last, <em>Tp <strong>init){
  </strong>STL_REQUIRES(</em>InputIterator, _InputIterator); // concept check
  for ( ; <strong>first != </strong>last; ++__first)</p>

<pre><code>__init = __init + *__first; // 求和
</code></pre>

<p>  return <strong>init;
}
template <class _InputIterator, class _Tp, class _BinaryOperation>
<em>Tp accumulate(</em>InputIterator </strong>first, <em>InputIterator __last, </em>Tp <strong>init, _BinaryOperation </strong>binary_op){
  <strong>STL_REQUIRES(<em>InputIterator, </em>InputIterator); // concept check
  for ( ; </strong>first != <strong>last; ++</strong>first)</p>

<pre><code>__init = __binary_op(__init, *__first); // 指定二元操作
</code></pre>

<p>  return __init;
}
```</p>

<!-- more -->


<p>第二个版本通过仿函数参数 <em>binary_op 指定操作类型，可以实现其他方式的累计，例如累乘等（令init=1，</em>binary_op=multiply）。</p>

<h3>2. adjacent_difference</h3>

<p>该算法用来计算区间 [first, last) 中相邻元素的差（或其他指定运算，结果[i]=当前元素[i]的值-前驱元素[i-1]的值），该算法也有两个版本，一个是指定运算为差，另一个传入仿函数(参数 _binary_op)指定具体运算，这里贴出第二个版本：</p>

<p>```
template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOperation>
<em>OutputIterator
__adjacent_difference(</em>InputIterator <strong>first, _InputIterator </strong>last,</p>

<pre><code>                  _OutputIterator __result, _Tp*, _BinaryOperation __binary_op) {
</code></pre>

<p>  _Tp <strong>value = *</strong>first;
  while (++<strong>first != </strong>last) { // 先 ++ ，再比较</p>

<pre><code>_Tp __tmp = *__first; // 取第i+1个元素的值
*++__result = __binary_op(__tmp, __value);
__value = __tmp; // 保存第i个元素的值
</code></pre>

<p>  }
  return ++<strong>result;
}
template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
<em>OutputIterator adjacent_difference(</em>InputIterator </strong>first, _InputIterator __last,</p>

<pre><code>                _OutputIterator __result, _BinaryOperation __binary_op) {
</code></pre>

<p>  if (<strong>first == </strong>last) return <strong>result; // 区间为空，直接返回
  *</strong>result = *<strong>first; // 第一个元素没有前驱，直接将当前值赋给结果
  return </strong>adjacent_difference(<strong>first, </strong>last, __result,</p>

<pre><code>                           __VALUE_TYPE(__first), __binary_op);
</code></pre>

<p>}
```</p>

<h3>3. inner_product</h3>

<p>该算法实现区间 [first1, last1) 和区间 [first2, first2+(last1-first1) ) 的一般内积（generalized inner product），公式为$init = init+(<em>i) * (</em>(first2+(i-first1)))$同样需要提供 init 的值（理由同accumulate）。另外还有一个版本，提供两个仿函数，分别指定上面公式中的加法和乘法。第一个版本的代码如下：
```
template <class _InputIterator1, class _InputIterator2, class _Tp>
<em>Tp inner_product(</em>InputIterator1 <strong>first1, _InputIterator1 </strong>last1,</p>

<pre><code>              _InputIterator2 __first2, _Tp __init) {
</code></pre>

<p>  for ( ; <strong>first1 != </strong>last1; ++<strong>first1, ++</strong>first2)</p>

<pre><code>__init = __init + (*__first1 * *__first2);
</code></pre>

<p>  return __init;
}
```
可以看到，这里其实没有判断第二个区间是否越界，所以在调用时需要我们自己注意，但一般来说计算内积的两个区间都是相同长度的。</p>

<h3>4. partial_sum</h3>

<p>该算法用来计算局部总和，将 <code>*first</code> 赋值给 <code>*result</code>，将 <code>*frist+*(first+1)</code> 赋值给 <code>*(result+1)</code>，依次类推，即有 <code>result[i]=sum(*first..*(first+i))</code>，这是默认的操作为加法的版本，还有一个版本可以通过仿函数指定操作，以下是默认版本：
```
template <class _InputIterator, class _OutputIterator, class _Tp>
<em>OutputIterator __partial_sum(</em>InputIterator <strong>first, _InputIterator </strong>last,</p>

<pre><code>          _OutputIterator __result, _Tp*) {
</code></pre>

<p>  _Tp <strong>value = *</strong>first;
  while (++<strong>first != </strong>last) {</p>

<pre><code>__value = __value + *__first;
*++__result = __value; // result 先++，再提领、赋值
</code></pre>

<p>  }
  return ++<strong>result;
}
template <class _InputIterator, class _OutputIterator>
<em>OutputIterator partial_sum(</em>InputIterator </strong>first, _InputIterator __last,</p>

<pre><code>        _OutputIterator __result){
</code></pre>

<p>  if (<strong>first == </strong>last) return <strong>result;
  *</strong>result = *<strong>first; // 第一项直接赋值
  return </strong>partial_sum(<strong>first, </strong>last, <strong>result, </strong>VALUE_TYPE(__first));
}
```</p>

<h3>5. itoa</h3>

<p>该算法不是C++/STL标准，主要作用是将区间 [first, last) 的值赋值为 value,value+1,value+2,... 如下：
```
template <class _ForwardIter, class _Tp>
void iota(<em>ForwardIter __first, </em>ForwardIter <strong>last, _Tp </strong>value){
  while (<strong>first != </strong>last)</p>

<pre><code>*__first++ = __value++;
</code></pre>

<p>}
```</p>

<h3>6. power</h3>

<p>该算法也不是C++/STL标准，作用在于实现 x 的 n 次方的计算，通过将n分解为2的幂来计算。还有一个版本是用户可以指定运算，而不一定是乘法。默认版本如下：
```
template <class _Tp, class _Integer, class _MonoidOperation>
<em>Tp __power(</em>Tp <strong>x, _Integer </strong>n, _MonoidOperation <strong>opr){ // func1：幂方的具体实现
  if (</strong>n == 0)</p>

<pre><code>return identity_element(__opr);
</code></pre>

<p>  else {</p>

<pre><code>while ((__n &amp; 1) == 0) { // 二进制末尾为0
  __n &gt;&gt;= 1; // n/2
  __x = __opr(__x, __x); // 乘方
}
_Tp __result = __x;
__n &gt;&gt;= 1;
while (__n != 0) {
  __x = __opr(__x, __x); // 乘方
  if ((__n &amp; 1) != 0) // 二进制末尾为1
    __result = __opr(__result, __x); // 乘入结果
  __n &gt;&gt;= 1;
}
return __result;
</code></pre>

<p>  }
}
template <class _Tp, class _Integer>
inline <em>Tp __power(</em>Tp <strong>x, _Integer </strong>n){ // func2
  return <strong>power(</strong>x, <strong>n, multiplies<_Tp>()); // 调用func3
}
template <class _Tp, class _Integer, class _MonoidOperation>
inline <em>Tp power(</em>Tp </strong>x, <em>Integer __n, </em>MonoidOperation <strong>opr){ // func3
  return </strong>power(<strong>x, </strong>n, <strong>opr); // 调用func1
}
template <class _Tp, class _Integer>
inline <em>Tp power(</em>Tp </strong>x, _Integer <strong>n){
  return </strong>power(<strong>x, </strong>n); // 调用func2
}
```
饶了几道弯，主要看 func1实现即可。</p>
]]></content>
  </entry>
  
</feed>