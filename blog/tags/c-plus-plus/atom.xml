<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: C++ | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-10-26T22:31:03+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(5.3) 算法之基本算法algobase]]></title>
    <link href="http://ibillxia.github.io/blog/2014/10/25/insight-into-stl-5-algorithm-3-base-algorithms-algobase/"/>
    <updated>2014-10-25T21:13:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/10/25/insight-into-stl-5-algorithm-3-base-algorithms-algobase</id>
    <content type="html"><![CDATA[<p>本文主要介绍STL中的数值算法，主要涉及到的源码文件有 <code>stl_algobase.h</code> 等。</p>

<p>在 <code>stl_algobase.h</code> 中定义的算法都比较简单基础，主要涉及区间相等判断、区间填充、求极值、交换、拷贝、字典序比较等算法，而其他诸如查找、计数、排序、旋转等算法则在文件 <code>stl_algo.h</code> 中实现。在algobase基本算法中，除了字典序比较、复制/拷贝算法外，其他都比较简单，这里先依次介绍这些简单的算法，然后再介绍字典序比较和拷贝算法。</p>

<h2>1. 交换、填充等简单算法</h2>

<p>由于这里很多算法比较简单（基本都在10行以内，甚至很多就一行代码），就不一一粘贴代码了。</p>

<p><strong>iter_swap</strong> ：将两个 ForwardIterators 所指的对象对调，通过申请一个临时变量、三次赋值，就完成了。</p>

<p><strong>min/max</strong> ：求两个数中的小、大者，还有一个版本可以指定的比较方法（仿函数）。</p>

<p><strong>fill</strong> ：将 <code>[first, last)</code> 内的所有元素改填为新值 value。</p>

<p><strong>fill_n</strong> ：将 <code>[first, last)</code> 内的前n个元素改填为新值 value，返回迭代器指向被填入的最后一个元素的下一位置。</p>

<p><strong>mismatch</strong> ：用来平行比较两个序列，指出两者之间的第一个不匹配点，返回一对迭代器（Iterators Pair），分别指向两序列中的不匹配点。</p>

<p><strong>equal</strong> ：判断两个序列在 <code>[first, last)</code> 区间内相等，如果第二个序列元素较多，将不予考虑，只有两个序列在各自区间内对应相等才返回true，否则返回false。</p>

<!-- more -->


<h2>2. 字典序比较</h2>

<p><code>lexicographical_compare</code> 以“字典序排列方式”对两个序列 <code>[first, last)</code> 和 <code>[first2, last2)</code> 进行比较。比较操作针对两个序列中的对应位置上的元素进行，直到某一对不相等或同时到达尾部或仁义序列到达尾部。该算法其实并不复杂，但有一点值得注意，那就当且仅当第一个序列字典序小于第二个序列时才返回true，以下是各种情况下的返回值：</p>

<ul>
<li>发现不相等，如果<strong>第一序列元素较小，返回true</strong>，否则返回false；</li>
<li>到达last1而尚未到达last2，返回true；</li>
<li>到达last2而尚未到达last1，返回false；</li>
<li>同时到达last1和last2，返回false。</li>
</ul>


<p>源码如下：
```
template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(<em>InputIter1 __first1, </em>InputIter1 <strong>last1, _InputIter2 </strong>first2, _InputIter2 <strong>last2) {
  for ( ; </strong>first1 != <strong>last1 &amp;&amp; </strong>first2 != <strong>last2; ++</strong>first1, ++__first2) {</p>

<pre><code>if (*__first1 &lt; *__first2)
  return true;
if (*__first2 &lt; *__first1)
  return false;
</code></pre>

<p>  }
  return <strong>first1 == </strong>last1 &amp;&amp; <strong>first2 != </strong>last2;
}
```</p>

<p>除了这个默认的版本外，还有一个版本提供比较方法（仿函数）的参数。另外，对于纯字符串的比较，SGI STL还做了进一步优化，使用原生指针和C标准函数 <code>memcmp()</code> 进行比较，如下：</p>

<p>```
inline bool
lexicographical_compare(const unsigned char<em> __first1, const unsigned char</em> __last1,</p>

<pre><code>                    const unsigned char* __first2,const unsigned char* __last2) {
</code></pre>

<p>  const size_t <strong>len1 = </strong>last1 - <strong>first1;
  const size_t </strong>len2 = <strong>last2 - </strong>first2;
  const int <strong>result = memcmp(</strong>first1, <strong>first2, min(</strong>len1, <strong>len2));
  return </strong>result != 0 ? <strong>result &lt; 0 : </strong>len1 &lt; __len2;
}
```</p>

<h2>3. 复制/拷贝算法</h2>

<p>在很多应用程序中，复制copy是一个很常见的操作，特别是在赋值的时候。对于稍微复杂的对象，在不同的语言中赋值时会有一些差别，有的编程语言赋值仅仅是对等号右边的对象的一个引用，而并没有正真的产生一个新的对象，更不用说对象中可能包含的对象成员，例如Python当中的赋值、浅拷贝copy和深拷贝deepcopy等。</p>

<p>而STL 中的copy，除了简单的单一对象的拷贝之外，还有序列区间的拷贝等，这里就涉及到空间分配和时间效率问题。在C++中，复制操作主要是运用assignment operator（复制运算符） 或 copy constructor（拷贝构造函数），在STL的copy算法中使用的是前者，而对于某些具有trivial assignment operator的数据，则可以使用内存直接复制行为（例如C标准库函数memmove、memcpy等），就能极大的节省时间。SGI STL用尽各种办法，包括函数重载、型别特性、偏特化（partial specialization）等技巧（关于偏特化请参见 <a href="http://www.jellythink.com/archives/410">C++模板特化与偏特化</a>），无所不用其极地加强效率。</p>

<p>除了上面提到的元素型别、偏特化等问题，还有元素复制顺序的问题。copy 算法是将原始区间 <code>[first, last)</code> 内的元素复制到目标区间 <code>[result, result+last-first)</code> 区间内，复制时既可以从 first 开始往 last 复制，但也可以从 last-1开始向 first 复制，后者在 STL 另取名为 copy_backward_。从后往前复制的好处在于，不用担心目标区间与原始区间有重叠，因为如果有重叠区域，那么简单的 copy 时，对于原始数据而言 <code>[result, last)</code> 区间的数据在被复制前被修改了，从而得不到预期的结果。当然，有一种情况使用 copy 不用担心这个问题，那就是对于迭代器为原生指针，使用 memmove （而不是 memcpy，关于二者的区别参见 <a href="http://stackoverflow.com/questions/4415910/memcpy-vs-memmove">memcpy() vs memmove()</a>）进行复制，此时 memmove 会先将整个区间复制下来，没有被覆盖的危险。</p>

<p>在介绍 copy 算法的源码具体实现前，根据源码及其注释再做一个简单的小结：copy 算法中的一些辅助函数有两个目的，其一是对于简单的数据类型尽量使用 memmove，其二是对于具有 RandomAccessIterators 的对象使用一个计数器来进行循环；除此之外，SGI STL针对编译器是否具有函数模板偏特化、类模板偏特化等进行了适配。下面是 copy 的源码，其中添加了比较详细具体的注释：</p>

<p>```
// 首先是几个与偏特化无关的公用的3个函数
template <class _InputIter, class _OutputIter, class _Distance>
inline <em>OutputIter
__copy(</em>InputIter <strong>first, _InputIter </strong>last,</p>

<pre><code>   _OutputIter __result,input_iterator_tag, _Distance*){
</code></pre>

<p>  for ( ; <strong>first != </strong>last; ++<strong>result, ++</strong>first) // 使用迭代器遍历和复制</p>

<pre><code>*__result = *__first;
</code></pre>

<p>  return <strong>result;
}
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
</strong>copy(<em>RandomAccessIter __first, </em>RandomAccessIter __last,</p>

<pre><code>   _OutputIter __result, random_access_iterator_tag, _Distance*){
</code></pre>

<p>  for (_Distance <strong>n = </strong>last - <strong>first; </strong>n > 0; --__n) { //对于随机访问迭代器，使用一个计数器n</p>

<pre><code>*__result = *__first;
++__first;
++__result;
</code></pre>

<p>  }
  return <strong>result;
}
template <class _Tp>
inline _Tp*
</strong>copy_trivial(const <em>Tp* __first, const </em>Tp<em> <em>_last, </em>Tp</em> <strong>result) {
  memmove(</strong>result, <strong>first, sizeof(_Tp) * (</strong>last - <strong>first)); // 直接使用 memmove
  return </strong>result + (<strong>last - </strong>first);
}
//============== __STL_FUNCTION_TMPL_PARTIAL_ORDER 对于具有函数模板偏特性的编译器</p>

<h1>if defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)</h1>

<p>template <class _InputIter, class _OutputIter>
inline <em>OutputIter
__copy_aux2(</em>InputIter <strong>first, _InputIter </strong>last, <em>OutputIter <strong>result, </strong>false_type) { // false_type 的重载版
  return <strong>copy(</strong>first, <strong>last, </strong>result, <strong>ITERATOR_CATEGORY(</strong>first), <strong>DISTANCE_TYPE(</strong>first));
}
template <class _InputIter, class _OutputIter>
inline </em>OutputIter
<strong>copy_aux2(_InputIter </strong>first, <em>InputIter __last, </em>OutputIter <strong>result, </strong>true_type) { // true_type 的重载版
  return <strong>copy(</strong>first, <strong>last, </strong>result, <strong>ITERATOR_CATEGORY(</strong>first), <strong>DISTANCE_TYPE(</strong>first));
}</p>

<h1>ifndef <strong>USLC</strong></h1>

<p>template <class _Tp>
inline <em>Tp*
__copy_aux2(</em>Tp<em> <em>_first, </em>Tp</em> <strong>last, _Tp* </strong>result, <strong>true_type) { // 原生指针的重载版
  return </strong>copy_trivial(<strong>first, </strong>last, __result);
}</p>

<h1>endif /<em> <strong>USLC</strong> </em>/</h1>

<p>template <class _Tp>
inline <em>Tp*
__copy_aux2(const </em>Tp<em> <em>_first, const </em>Tp</em> <strong>last, _Tp* </strong>result, <strong>true_type) { // 常量指针的重载版
  return </strong>copy_trivial(<strong>first, </strong>last, <strong>result);
}
template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter
</strong>copy_aux(<em>InputIter __first, </em>InputIter <strong>last, _OutputIter </strong>result, <em>Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator </em>Trivial;
  return <strong>copy_aux2(</strong>first, <strong>last, </strong>result, <em>Trivial());
}
template <class _InputIter, class _OutputIter>
inline </em>OutputIter
copy(<em>InputIter __first, </em>InputIter <strong>last, _OutputIter </strong>result) { //最终的对外接口
  return <strong>copy_aux(</strong>first, <strong>last, </strong>result, <strong>VALUE_TYPE(</strong>first));
}
//============== __STL_CLASS_PARTIAL_SPECIALIZATION 对于具有类模板偏特性的编译器</p>

<h1>elif defined(__STL_CLASS_PARTIAL_SPECIALIZATION)</h1>

<p>template <class _InputIter, class _OutputIter, class _BoolType>
struct <strong>copy_dispatch { // 类1，泛化版
  static <em>OutputIter copy(</em>InputIter </strong>first, <em>InputIter __last, </em>OutputIter __result) {</p>

<pre><code>typedef typename iterator_traits&lt;_InputIter&gt;::iterator_category _Category;
typedef typename iterator_traits&lt;_InputIter&gt;::difference_type _Distance;
return __copy(__first, __last, __result, _Category(), (_Distance*) 0);
</code></pre>

<p>  }
};
template <class _Tp>
struct <strong>copy_dispatch&lt;<em>Tp*, </em>Tp*, </strong>true_type>{ // 类2，特化版
  static <em>Tp* copy(const </em>Tp<em> <em>_first, const </em>Tp</em> <strong>last, _Tp* </strong>result) {</p>

<pre><code>return __copy_trivial(__first, __last, __result);
</code></pre>

<p>  }
};
template <class _Tp>
struct <strong>copy_dispatch<const _Tp*, _Tp*, __true_type>{ // 类3，特化版
  static <em>Tp* copy(const </em>Tp* </strong>first, const <em>Tp* __last, </em>Tp* __result) {</p>

<pre><code>return __copy_trivial(__first, __last, __result);
</code></pre>

<p>  }
};
template <class _InputIter, class _OutputIter>
inline <em>OutputIter
copy(</em>InputIter <strong>first, _InputIter </strong>last, <em>OutputIter __result) { // 对外接口
  typedef typename iterator_traits<_InputIter>::value_type </em>Tp;
  typedef typename <strong>type_traits<_Tp>::has_trivial_assignment_operator _Trivial;
  return </strong>copy_dispatch&lt;<em>InputIter, </em>OutputIter, _Trivial></p>

<pre><code>::copy(__first, __last, __result);
</code></pre>

<p>}
//============== 其他，完全不具有偏特化特性的情况</p>

<h1>else /<em> __STL_CLASS_PARTIAL_SPECIALIZATION </em>/</h1>

<p>template <class _InputIter, class _OutputIter>
inline <em>OutputIter
copy(</em>InputIter <strong>first, _InputIter </strong>last, _OutputIter <strong>result){ // 对外接口，泛化版
  return </strong>copy(<strong>first, </strong>last, <strong>result, </strong>ITERATOR_CATEGORY(<strong>first), </strong>DISTANCE_TYPE(__first));
}</p>

<h1>define <em>_SGI_STL_DECLARE_COPY_TRIVIAL(</em>Tp)                                \</h1>

<p>  inline <em>Tp* copy(const </em>Tp<em> <em>_first, const </em>Tp</em> <strong>last, _Tp* </strong>result) { \ // 对外接口，特化版</p>

<pre><code>memmove(__result, __first, sizeof(_Tp) * (__last - __first));          \
return __result + (__last - __first);                                  \
</code></pre>

<p>  }</p>

<p><strong>SGI_STL_DECLARE_COPY_TRIVIAL(char)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(signed char)
<strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned char)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(short)
<strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned short)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(int)
<strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned int)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(long)
__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long)</p>

<h1>ifdef __STL_HAS_WCHAR_T</h1>

<p>__SGI_STL_DECLARE_COPY_TRIVIAL(wchar_t)</p>

<h1>endif</h1>

<h1>ifdef _STL_LONG_LONG</h1>

<p><strong>SGI_STL_DECLARE_COPY_TRIVIAL(long long)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long long)</p>

<h1>endif</h1>

<p><strong>SGI_STL_DECLARE_COPY_TRIVIAL(float)
</strong>SGI_STL_DECLARE_COPY_TRIVIAL(double)
__SGI_STL_DECLARE_COPY_TRIVIAL(long double)</p>

<h1>undef __SGI_STL_DECLARE_COPY_TRIVIAL</h1>

<h1>endif /<em> __STL_CLASS_PARTIAL_SPECIALIZATION </em>/</h1>

<p>```</p>

<p>以上是 copy 的完整代码，关于复制还有两个接口，一个是 <code>copy_n</code>，另一个是 <code>copy_backward</code>，前者复制区间 <code>[first, last)</code> 中前 n 个元素，后者从last-1 往 first 复制，这里就不详细展开了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(5.2) 算法之数值算法]]></title>
    <link href="http://ibillxia.github.io/blog/2014/10/19/insight-into-stl-5-algorithm-2-numeric-algorithms/"/>
    <updated>2014-10-19T20:28:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/10/19/insight-into-stl-5-algorithm-2-numeric-algorithms</id>
    <content type="html"><![CDATA[<p>本文主要介绍STL中的数值算法，主要涉及到的源码文件有 <code>stl_numberic.h</code>、<code>numeric</code>、<code>stl_relops.h</code> 等。</p>

<p>STL 数值算法主要包含以下几个算法（来自<a href="http://www.cplusplus.com/reference/numeric/">C++文档</a>）：</p>

<ul>
<li>accumulate: Accumulate values in range</li>
<li>adjacent_difference: Compute adjacent difference of range</li>
<li>inner_product: Compute cumulative inner product of range</li>
<li>partial_sum: Compute partial sums of range</li>
<li>iota: Store increasing sequence</li>
<li>power: power(x,n) 1 multiply by x n times (not in C++ standard)</li>
</ul>


<p>下面一一介绍每个算法的实现。</p>

<h3>1. accumulate</h3>

<p>该算法计算 init 和区间 [first, last) 内所有元素的总和。注意，必须提供 init 的初始值，这样即使 first=last 区间为空，仍能得到一个明确定义的值。当 init=0 时，即为计算 [first, last) 区间内所有元素的总和。具体实现有两个版本，如下：</p>

<p>```
template <class _InputIterator, class _Tp>
<em>Tp accumulate(</em>InputIterator <strong>first, _InputIterator </strong>last, <em>Tp <strong>init){
  </strong>STL_REQUIRES(</em>InputIterator, _InputIterator); // concept check
  for ( ; <strong>first != </strong>last; ++__first)</p>

<pre><code>__init = __init + *__first; // 求和
</code></pre>

<p>  return <strong>init;
}
template <class _InputIterator, class _Tp, class _BinaryOperation>
<em>Tp accumulate(</em>InputIterator </strong>first, <em>InputIterator __last, </em>Tp <strong>init, _BinaryOperation </strong>binary_op){
  <strong>STL_REQUIRES(<em>InputIterator, </em>InputIterator); // concept check
  for ( ; </strong>first != <strong>last; ++</strong>first)</p>

<pre><code>__init = __binary_op(__init, *__first); // 指定二元操作
</code></pre>

<p>  return __init;
}
```</p>

<!-- more -->


<p>第二个版本通过仿函数参数 <em>binary_op 指定操作类型，可以实现其他方式的累计，例如累乘等（令init=1，</em>binary_op=multiply）。</p>

<h3>2. adjacent_difference</h3>

<p>该算法用来计算区间 [first, last) 中相邻元素的差（或其他指定运算，结果[i]=当前元素[i]的值-前驱元素[i-1]的值），该算法也有两个版本，一个是指定运算为差，另一个传入仿函数(参数 _binary_op)指定具体运算，这里贴出第二个版本：</p>

<p>```
template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOperation>
<em>OutputIterator
__adjacent_difference(</em>InputIterator <strong>first, _InputIterator </strong>last,</p>

<pre><code>                  _OutputIterator __result, _Tp*, _BinaryOperation __binary_op) {
</code></pre>

<p>  _Tp <strong>value = *</strong>first;
  while (++<strong>first != </strong>last) { // 先 ++ ，再比较</p>

<pre><code>_Tp __tmp = *__first; // 取第i+1个元素的值
*++__result = __binary_op(__tmp, __value);
__value = __tmp; // 保存第i个元素的值
</code></pre>

<p>  }
  return ++<strong>result;
}
template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
<em>OutputIterator adjacent_difference(</em>InputIterator </strong>first, _InputIterator __last,</p>

<pre><code>                _OutputIterator __result, _BinaryOperation __binary_op) {
</code></pre>

<p>  if (<strong>first == </strong>last) return <strong>result; // 区间为空，直接返回
  *</strong>result = *<strong>first; // 第一个元素没有前驱，直接将当前值赋给结果
  return </strong>adjacent_difference(<strong>first, </strong>last, __result,</p>

<pre><code>                           __VALUE_TYPE(__first), __binary_op);
</code></pre>

<p>}
```</p>

<h3>3. inner_product</h3>

<p>该算法实现区间 [first1, last1) 和区间 [first2, first2+(last1-first1) ) 的一般内积（generalized inner product），公式为$init = init+(<em>i) * (</em>(first2+(i-first1)))$同样需要提供 init 的值（理由同accumulate）。另外还有一个版本，提供两个仿函数，分别指定上面公式中的加法和乘法。第一个版本的代码如下：
```
template <class _InputIterator1, class _InputIterator2, class _Tp>
<em>Tp inner_product(</em>InputIterator1 <strong>first1, _InputIterator1 </strong>last1,</p>

<pre><code>              _InputIterator2 __first2, _Tp __init) {
</code></pre>

<p>  for ( ; <strong>first1 != </strong>last1; ++<strong>first1, ++</strong>first2)</p>

<pre><code>__init = __init + (*__first1 * *__first2);
</code></pre>

<p>  return __init;
}
```
可以看到，这里其实没有判断第二个区间是否越界，所以在调用时需要我们自己注意，但一般来说计算内积的两个区间都是相同长度的。</p>

<h3>4. partial_sum</h3>

<p>该算法用来计算局部总和，将 <code>*first</code> 赋值给 <code>*result</code>，将 <code>*frist+*(first+1)</code> 赋值给 <code>*(result+1)</code>，依次类推，即有 <code>result[i]=sum(*first..*(first+i))</code>，这是默认的操作为加法的版本，还有一个版本可以通过仿函数指定操作，以下是默认版本：
```
template <class _InputIterator, class _OutputIterator, class _Tp>
<em>OutputIterator __partial_sum(</em>InputIterator <strong>first, _InputIterator </strong>last,</p>

<pre><code>          _OutputIterator __result, _Tp*) {
</code></pre>

<p>  _Tp <strong>value = *</strong>first;
  while (++<strong>first != </strong>last) {</p>

<pre><code>__value = __value + *__first;
*++__result = __value; // result 先++，再提领、赋值
</code></pre>

<p>  }
  return ++<strong>result;
}
template <class _InputIterator, class _OutputIterator>
<em>OutputIterator partial_sum(</em>InputIterator </strong>first, _InputIterator __last,</p>

<pre><code>        _OutputIterator __result){
</code></pre>

<p>  if (<strong>first == </strong>last) return <strong>result;
  *</strong>result = *<strong>first; // 第一项直接赋值
  return </strong>partial_sum(<strong>first, </strong>last, <strong>result, </strong>VALUE_TYPE(__first));
}
```</p>

<h3>5. itoa</h3>

<p>该算法不是C++/STL标准，主要作用是将区间 [first, last) 的值赋值为 value,value+1,value+2,... 如下：
```
template <class _ForwardIter, class _Tp>
void iota(<em>ForwardIter __first, </em>ForwardIter <strong>last, _Tp </strong>value){
  while (<strong>first != </strong>last)</p>

<pre><code>*__first++ = __value++;
</code></pre>

<p>}
```</p>

<h3>6. power</h3>

<p>该算法也不是C++/STL标准，作用在于实现 x 的 n 次方的计算，通过将n分解为2的幂来计算。还有一个版本是用户可以指定运算，而不一定是乘法。默认版本如下：
```
template <class _Tp, class _Integer, class _MonoidOperation>
<em>Tp __power(</em>Tp <strong>x, _Integer </strong>n, _MonoidOperation <strong>opr){ // func1：幂方的具体实现
  if (</strong>n == 0)</p>

<pre><code>return identity_element(__opr);
</code></pre>

<p>  else {</p>

<pre><code>while ((__n &amp; 1) == 0) { // 二进制末尾为0
  __n &gt;&gt;= 1; // n/2
  __x = __opr(__x, __x); // 乘方
}
_Tp __result = __x;
__n &gt;&gt;= 1;
while (__n != 0) {
  __x = __opr(__x, __x); // 乘方
  if ((__n &amp; 1) != 0) // 二进制末尾为1
    __result = __opr(__result, __x); // 乘入结果
  __n &gt;&gt;= 1;
}
return __result;
</code></pre>

<p>  }
}
template <class _Tp, class _Integer>
inline <em>Tp __power(</em>Tp <strong>x, _Integer </strong>n){ // func2
  return <strong>power(</strong>x, <strong>n, multiplies<_Tp>()); // 调用func3
}
template <class _Tp, class _Integer, class _MonoidOperation>
inline <em>Tp power(</em>Tp </strong>x, <em>Integer __n, </em>MonoidOperation <strong>opr){ // func3
  return </strong>power(<strong>x, </strong>n, <strong>opr); // 调用func1
}
template <class _Tp, class _Integer>
inline <em>Tp power(</em>Tp </strong>x, _Integer <strong>n){
  return </strong>power(<strong>x, </strong>n); // 调用func2
}
```
饶了几道弯，主要看 func1实现即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(5.1) 算法]]></title>
    <link href="http://ibillxia.github.io/blog/2014/10/12/insight-into-stl-5-algorithm-1-overview/"/>
    <updated>2014-10-12T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/10/12/insight-into-stl-5-algorithm-1-overview</id>
    <content type="html"><![CDATA[<h2>1. 算法概述</h2>

<p>算法（Algorithm）是一个计算的具体步骤，常用于计算、数据处理和自动推理。Donald Knuth 在他的著作 The Art of Computer Programming 里对算法的特征归纳（来自wiki）：</p>

<ul>
<li>输入：一个算法必须有零个或以上输入量。</li>
<li>输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。</li>
<li>明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地符合要求或期望，通常要求实际运行结果是确定的。</li>
<li>有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。</li>
<li>有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</li>
</ul>


<p>算法的核心是创建问题抽象的模型和明确求解目标，常见的算法有分治法、贪婪算法、动态规划、平摊分析等。再好的编程技巧，也无法让一个笨拙的算法起死回生，选择了错误的算法，便注定了失败的命运。</p>

<p>算法的<strong>时间复杂度</strong>是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模$n$的函数$f(n)$，算法的时间复杂度也因此记做：<br/>
$T(n) = O(f(n))$<br/>
算法执行时间的增长率与$f(n)$的增长率正相关，称作渐近时间复杂度（Asymptotic Time Complexity），简称时间复杂度。
常见的时间复杂度有：常数阶$O(1)$,对数阶$O(log<em>{2}n)$,线性阶$O(n)$, 线性对数阶$O(nlog</em>{2}n)$,平方阶$O(n<sup>{2})$，立方阶$O(n<sup>{3})$</sup></sup> ，...， k次方阶$O(n<sup>{k})$,指数阶$O(2<sup>{n})$。随着问题规模$n$的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</sup></sup></p>

<p>算法的<strong>空间复杂度</strong>是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</p>

<!-- more -->


<h2>2. STL 算法概览</h2>

<p>很多算法能用来解决特定问题（如排序、查找、复制、比较、组合等），并获得数学上的性能分析与证明，这样的算法非常具有复用性，STL 的算法组件就总结了70+ 个极具复用价值的算法，包括排序（sorting）、查找（searching）、排列组合（permutation）等，以及用于数据移动、复制、删除、比较、组合、运算等算法。</p>

<p>某些特定的算法与特定的数据结构相关，例如二叉查找树和红黑树便是为了解决查找问题而发展出来的特殊数据结构，hashtable 拥有快速查找能力，又例如 max-heap 可以协助完成 heap sort，几乎可以说，特定的数据结构是为了实现某种特定的算法。这类与特定数据结构相关的算法，在前几篇介绍容器的文章中都有提到，而接下来几篇文章所要介绍的算法则是无特殊条件限制的空间中的某一段元素区间的算法，即泛型算法。</p>

<h4>2.1 STL 算法的一般形式</h4>

<p>所有泛型算法的前两个参数都是一对迭代器（iterators），通常称为 first 和 last，用以标识算法的操作区间，STL 习惯采用前闭后开区间表示法，写成 <code>[first, last)</code> ，当 <code>frist==last</code> 时，表示的是空区间。这个 <code>[first, last)</code> 的必要条件是，必须能够进过 increment （累加）操作的反复运用，从 first 到 last，编译器本身无法强求这一点，如果这个条件不成立，会导致无法预料的结果。</p>

<p>前面讲<a href="http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits/">迭代器</a>时我们知道，STL有5类迭代器，他们是input、output、forward、bidirectional、random_access。_每个 STL 算法的声明，都表现出它所需要的最低程度的迭代器类型，例如 <code>find()</code> 需要一个 inputIterators 是最低要求，但也可以接受更高类型的，如 forwardIterators、bidirectionalIterators、randomAccessIterators，但如果传给它一个outputIterators，则会导致错误。将无效的迭代器传给某个算法，虽然是一种错误，却不能保证在编译时期就被捕捉出来，因为所谓的迭代器型别并不是真实的型别，他们只是 function template 的一种型别参数（type parameters）。</p>

<p>许多 STL 算法都有很多个版本，除了默认的只包含迭代器参数的实现之外，还有一个可以传入仿函数（functor）参数的版本，例如 <code>unique()</code> 缺省情况下使用 <code>equality</code> 操作符来比较两个相邻的元素，但如果这些元素的型别并未提供 <code>equality</code> 操作符，或如果用户希望定义自己的 <code>equality</code> 操作符，便可以传一个仿函数给另一个版本的 <code>unique()</code> ，有些算法干脆将这样的两个版本分为两个不同名的实体，如 <code>find_if()</code>、<code>replace_if()</code> 等。</p>

<h4>2.2 质变算法与非质变算法</h4>

<p>所谓<strong>质变算法</strong>（mutating algorithms），是指算法运算过程中，会更改区间<code>[first, last)</code>内（迭代器所指）的元素内容，诸如复制（copy）、互换（swap）、替换（replace）、填充（fill）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）等，都属于此类。通常质变算法提供两个版本，一个是就地（in-place）进行，另一个是copy（另地进行）版本，将操作对象复制一份副本，然后在副本上进行修改并返回该副本。copy版一般以 <code>_copy</code> 作为函数名后缀，例如 <code>replace_copy()</code> 等。但并不是所有的质变算法都提供copy版，例如 sort 就没有。如果我们一定要使用 copy 版，需要我们自己先 copy 一份副本，然后再将副本传给相应的算法。</p>

<p>所谓<strong>非质变算法</strong>（nonmutating algorithms），是指算法运算过程中不会更改区间<code>[first, last)</code>内的元素内容，诸如查找（find）、匹配（search）、计数（count）、巡访（for_each）_、比较（equal，mismatch）、寻找极值（max、min）等。</p>

<h4>2.3 STL 算法的分类</h4>

<p>STL 算法的实现主要在 <code>stl_algobase.h</code>、<code>stl_algo.h</code>、<code>stl_numeric.h</code> 这3个文件中，其中 <code>stl_numeric.h</code> 主要是数值（numeric）算法，包括 <code>adjecent_difference()</code>、<code>accumulate()</code>、<code>inner_product()</code>、<code>partial_sum()</code> 等，相关接口封装在 <code>&lt;numeric&gt;</code> 中。而其他算法如复制、填充、交换、求极值、排列、排序、分割等等算法则在剩下的那两个文件中，相关接口则封装在 <code>&lt;algorithm&gt;</code> 中。C++ 的 <a href="http://www.cplusplus.com/reference/algorithm/">官方文档</a> 将 STL 算法分为以下几类：</p>

<ul>
<li>Non-modifying sequence operations  非质变操作，查找、计数等</li>
<li>Modifying sequence operations  质变操作，复制、交换、替换、填充、删除、逆转、旋转等</li>
<li>Partitions 分割</li>
<li>Sorting 排序</li>
<li>Binary search (operating on partitioned/sorted ranges) 二分查找</li>
<li>Merge (operating on sorted ranges) 合并</li>
<li>Heap、Min/max、Other 堆算法、极值、其他等</li>
</ul>


<p>后续文章将分别介绍这些算法的具体实现。</p>

<h2>3. 算法的泛化</h2>

<p>上文提到过，很多算法是与底层的数据结构相关的，如何将算法独立于其所处理的数据结构之外，使它能够处理任何数据结构，或者在未知的数据结构（也许是 array，也许是vector，也许是list，也许是deque）上正确地实现操作，并不那么简单。其关键在于，需要把操作对象的型别加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化。如此，整个算法也就在一个抽象层面了，这个过程称为算法的泛型化（generalized），简称泛化。</p>

<p>下面以查找算法的泛化过程为例详细介绍算法泛化的奇妙。对于查找算法，我们首先想到的是在一个整型数组中查找指定元素，一个基本的实现如下：</p>

<p>```
int<em> find(int</em> arrayHead, int arraySize, int value){</p>

<pre><code>for(int i=0; i &lt; arraySize; i++){
    if(arrayHead[i] == value) break;
}
return &amp;(arrayHead[i]);
</code></pre>

<p>}
```</p>

<p>该函数在数组中查找指定值的元素，返回找到的第一个符合条件的元素的地址，如果没有找到就返回最后一个元素的下一个位置（称为end）。当没有找到时，这里为什么要返回地址值（end）而不返回null呢？这是为了方便调用后续的泛型算法，但实际上该算法本身还是与容器相关的，而且暴露了很多容器的实现细节（如arraySize等）。为了让该算法适用于所有类型的容器，其操作应该更抽象化，可以让 find 接受两个指针作为参数，标识出一个操作区间，如下：</p>

<p>```
int<em> find(int</em> begin, int* end, int value){</p>

<pre><code>while(begin != end &amp;&amp; *begin != value) ++begin;
return begin;
</code></pre>

<p>}
```</p>

<p>该函数在区间 <code>[begin, end)</code> 内查找 value，并返回一个指针。这样做之后，已经隐藏了容器内部特性了，但不足的是，要求元素的数据类型为整型，我们可以通过模板参数来解决这个问题：</p>

<p>```
template<typename T>
T<em> find(T</em> begin, T* end, const T&amp; value){</p>

<pre><code>// 用到了operator !=,*,++
while(begin != end &amp;&amp; *begin != value) ++begin;
return begin; // 会引发copy行为
</code></pre>

<p>}
```</p>

<p>除了参数模板化之外，值得注意的是其中待查找的对象是以常引用的方式传递，这样对于大对象非常有利。于是，现在的find函数几乎适用于任何容器——只要该容器允许指针，而指针又都支持inequality（判断不相等）操作符、dereference（取值）操作符、（prefix）increment（前置式递增）操作符、copy（复制）行为这四种操作。</p>

<p>但这个版本还不够泛化，因为参数被限制为指针，而那些支持以上四种操作、行为很像指针的某些对象就无法使用 find 了。在STL中有迭代器，它是一种行为类似指针的对象，是一种smart pointers，使用迭代器实现 find 如下：</p>

<p>```
template<class Iterator, class T>
Iterator find(Iterator begin, Iterator end, const T&amp; value){</p>

<pre><code>while(begin != end &amp;&amp; *begin != value) ++begin;
return begin;
</code></pre>

<p>}
```</p>

<p>这便是一个完全泛化的find 函数，它与STL中的find函数几乎一模一样（不同之处可自行查看STL源码）。了解和理解了STL算法的泛化过程，就很容易看懂STL中很多其他的算法了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.5) 关联式容器之hashset和hashmap]]></title>
    <link href="http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap/"/>
    <updated>2014-09-27T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/09/27/insight-into-stl-4-associative-containers-5-hashset-and-hashmap</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hash_set.h</code>、<code>stl_hash_map.h</code> 等文件。</p>

<h2>1. hashset 和 hash_multi_set</h2>

<p>需要说明的是，STL 标准只规范了复杂度与接口，并没有规范实现方法，但 STL 实现的版本中 set 大多以 RB-tree 为底层机制，SGI STL 在实现了以 RB-tree 为底层机制的 set 外，还实现了以 hashtable 为底层机制的 hashset。<br/>
和 set 一样，hashset 的键值（key）和实值（value）是同一个字段，不同的是 set 默认是自动排序的，而 hashset 则是无序的。除此之外，hashset 与 set 的对外接口完全相同。<br/>
这里还有一种称为 hash_multi_set 的集合，它同 multiset 类似，允许键值重复，而上面的 hashset 则不允许。下面是 hashset 的定义的主要代码：</p>

<!-- more -->


<p>```
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
class hash_set {
private:
  typedef hashtable&lt;<em>Value, </em>Value, <em>HashFcn, </em>Identity<_Value>, <em>EqualKey, </em>Alloc> <em>Ht;
  </em>Ht <em>M_ht; // 底层容器的定义
public:
  hash_set() : </em>M_ht(100, hasher(), key_equal(), allocator_type()) {} // 构造函数
  iterator find(const key_type&amp; <strong>key) const { return _M_ht.find(</strong>key); } // 查找
  size_type count(const key_type&amp; <strong>key) const { return _M_ht.count(</strong>key); } // 计数
  size_type size() const { return <em>M_ht.size(); } // 表格大小
  size_type max_size() const { return </em>M_ht.max_size(); }
  bool empty() const { return <em>M_ht.empty(); } // 是否为空
  void swap(hash_set&amp; __hs) { </em>M_ht.swap(<strong>hs.<em>M_ht); } // 交换
  iterator begin() const { return </em>M_ht.begin(); }
  iterator end() const { return _M_ht.end(); }
  pair&lt;iterator, bool> insert(const value_type&amp; </strong>obj){ // 插入</p>

<pre><code>  pair&lt;typename _Ht::iterator, bool&gt; __p = _M_ht.insert_unique(__obj);
  return pair&lt;iterator,bool&gt;(__p.first, __p.second);
</code></pre>

<p>  }
  size_type erase(const key_type&amp; <strong>key) {return _M_ht.erase(</strong>key); } // 擦除
  void erase(iterator <strong>it) { _M_ht.erase(</strong>it); }
  void erase(iterator <strong>f, iterator </strong>l) { <em>M_ht.erase(<strong>f, </strong>l); }
  void clear() { </em>M_ht.clear(); } // 清空
};
template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
inline bool operator==(const hash_set&lt;<em>Value,</em>HashFcn,<em>EqualKey,</em>Alloc>&amp; __hs1,</p>

<pre><code>       const hash_set&lt;_Value,_HashFcn,_EqualKey,_Alloc&gt;&amp; __hs2) {
</code></pre>

<p>  return <strong>hs1._M_ht == </strong>hs2._M_ht;
}
```</p>

<h2>2. hashmap 和 hash_multi_map</h2>

<p>hashmap 是以 hashtable 为底层容器的 map，而 map 是同时拥有实值（value）和键值（key），且不允许键值重复。<br/>
而 hash_multi_map 是以 hashtable 为底层容器的 map，且允许键值重复。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.4) 关联式容器之hashtable]]></title>
    <link href="http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable/"/>
    <updated>2014-09-13T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/09/13/insight-into-stl-4-associative-containers-4-hashtable</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要是 <code>stl_hashtable.h</code>、<code>stl_hash_fun.h</code> 等文件。</p>

<h2>1. hashtable 简介</h2>

<p>在数据结构中我们知道，有种数据结构的插入、删除、查找等操作的性能是常数时间，但需要比元素个数更多的空间，这种数据结构就是哈希表。哈希表的基本思想是，将数据存储在与其数值大小相关的地方，比如对该数取模，然后存储在以余数为下表的数组中。但这样会出现一个问题，就是可能会有多个数据被映射到同一个存储位置，即出现了所谓的“碰撞”。哈希表的主要内容就是解决“碰撞”问题，一般而言有以下几种方法：线性探测、二次探测、开链等。</p>

<h4>线性探测</h4>

<p>简单而言，就是在出现“碰撞”后，寻找当前位置以后的空档，然后存入。如果找到尾部都没有空档，则从头部重新开始找。只要空间大小比元素个数大，总能找到的。相应的，元素的查找和删除也与普通的数组不同，查找如果直接定位到相应位置并找到或是空档，就可以确定存在或不存在，而如果定位到当前位置非空且与待查找的元素不同，则要依序寻找后续位置的元素，直到找到或移到了空档。删除则是采用懒惰删除策略，即只标记删除记号，实际删除操作则待表格重新整理时再进行。</p>

<h4>二次探测</h4>

<p>与线性探测类似，但向后寻找的策略是探测距当前位置为平方数的位置，即 $index = H+i<em><sup>{2}$</sup> </em>。但这样会有一个问题，那就是能否保证每次探测的是不同的位置，即是否存在某次插入时，探测完一圈后回到自己而出现死循环。</p>

<h4>开链</h4>

<p>这种方法是将出现冲突的元素放在一个链表中，而哈希表中只存储这些链表的首地址。SGI STL中就是使用这种方法来解决“碰撞”的。</p>

<h2>2. hashtable 的数据结构</h2>

<p>由于使用开链的方法解决冲突，所以要维护两种数据结构，一个是 hash table，在 STL 中称为 buckets，用 vector 作为容器；另一个是链表，这里没有使用 list 或 slist 这些现成的数据结构，而是使用自定义 <code>__hashtable_node</code> ，相关定义具体如下：</p>

<!-- more -->


<p><code>
template &lt;class _Val&gt;
struct _Hashtable_node { // 链表节点的定义
  _Hashtable_node* _M_next; // 指向下一个节点
  _Val _M_val;
};
template &lt;class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc&gt;
class hashtable {
private:
  typedef _HashFcn hasher;
  hasher                _M_hash; // 哈希函数
  typedef _Hashtable_node&lt;_Val&gt; _Node; // 节点类型别名定义
  vector&lt;_Node*,_Alloc&gt; _M_buckets; // hash table，存储链表的索引
};
</code>
这里 hashtable 的模板参数很多，其含义如下：</p>

<blockquote><p><em>Val: 节点的实值类型
</em>Key: 节点的键值类型
<em>HashFcn: 哈希函数的类型
</em>ExtractKey: 从节点中取出键值的方法（函数或仿函数）
<em>EqualKey: 判断键值相同与否的方法（函数或仿函数）
</em>Alloc: 空间配置器，默认使用 std::alloc</p></blockquote>

<p>虽然开链法并不要求哈希表的大小为质数，但 SGI STL 仍然以质数来设计表的大小，并将28个质数（大约2倍依次递增）计算好，并提供函数来查询其中最接近某数并大于某数的质数，如下：<br/>
<code>
enum { __stl_num_primes = 28 };
static const unsigned long __stl_prime_list[__stl_num_primes] = {
  53ul,         97ul,         193ul,       389ul,       769ul,
  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
  1610612741ul, 3221225473ul, 4294967291ul
}; // 使用无符号长整型（32bit）
inline unsigned long __stl_next_prime(unsigned long __n) {
  const unsigned long* __first = __stl_prime_list;
  const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes;
  const unsigned long* pos = lower_bound(__first, __last, __n); // lower_bound 是泛型算法，后续会介绍
  return pos == __last ? *(__last - 1) : *pos;
}
</code></p>

<h2>3. hashtable 的空间配置</h2>

<h4>节点空间配置</h4>

<p>首先只考虑比较简单的情况，即哈希表的大小不需要调整，此时空间配置主要是链表节点的配置，而 hashtable 使用 vector 作为容器，链表节点的空间配置（分配和释放）如下：<br/>
```
typedef simple_alloc&lt;<em>Node, </em>Alloc> <em>M_node_allocator_type;
</em>Node<em> <em>M_get_node() { return </em>M_node_allocator_type::allocate(1); } // 分配一个节点的空间
void <em>M_put_node(</em>Node</em> <strong>p) { _M_node_allocator_type::deallocate(</strong>p, 1); } // 释放一个节点的空间
<em>Node* </em>M_new_node(const value_type&amp; __obj) {</p>

<pre><code>_Node* __n = _M_get_node();
__n-&gt;_M_next = 0;
__STL_TRY {
    construct(&amp;__n-&gt;_M_val, __obj);
    return __n;
}
__STL_UNWIND(_M_put_node(__n));
</code></pre>

<p>}
void <em>M_delete_node(</em>Node* __n) {</p>

<pre><code>destroy(&amp;__n-&gt;_M_val);
_M_put_node(__n);
</code></pre>

<p>}
```</p>

<h4>插入操作表格重新整理</h4>

<p>哈希表的插入操作有两个问题要考虑，一个是 是否允许插入相同键值的元素，另一个是 是否需要扩充表的大小。在 STL 中，首先是判断新插入一个元素后是否需要扩充，判断的条件是插入后元素的个数大于当前哈希表的大小；而是否允许元素重复则通过提供 <code>insert_unique</code> 和 <code>insert_equal</code> 来解决。相关代码如下：<br/>
```
pair&lt;iterator, bool> insert_unique(const value_type&amp; __obj) {</p>

<pre><code>resize(_M_num_elements + 1); // 先进行扩充（如有必要）
return insert_unique_noresize(__obj); // 然后插入
</code></pre>

<p>}
iterator insert_equal(const value_type&amp; __obj) {</p>

<pre><code>resize(_M_num_elements + 1);
return insert_equal_noresize(__obj);
</code></pre>

<p>}
void hashtable&lt;<em>Val,</em>Key,<em>HF,</em>Ex,<em>Eq,</em>All>::resize(size_type <strong>num_elements_hint) { // 扩充表格
  const size_type </strong>old_n = _M_buckets.size();
  if (<strong>num_elements_hint > </strong>old_n) { // 判断是否需要扩充</p>

<pre><code>const size_type __n = _M_next_size(__num_elements_hint); // 下一个质数
if (__n &gt; __old_n) {
  vector&lt;_Node*, _All&gt; __tmp(__n, (_Node*)(0), _M_buckets.get_allocator()); // 新的buckets
  __STL_TRY {
    for (size_type __bucket = 0; __bucket &lt; __old_n; ++__bucket) { // 遍历旧的buckets
      _Node* __first = _M_buckets[__bucket];
      while (__first) { // 处理每一个链表
        size_type __new_bucket = _M_bkt_num(__first-&gt;_M_val, __n); // 确定当前节点落在新buckets中的位置
        _M_buckets[__bucket] = __first-&gt;_M_next; // 指向下一个节点
        __first-&gt;_M_next = __tmp[__new_bucket]; // 在新buckets的新索引位置头部插入
        __tmp[__new_bucket] = __first;
        __first = _M_buckets[__bucket]; // 指向旧链表下一个节点
      }
    }
    _M_buckets.swap(__tmp); // 交换新旧buckets，退出后临时buckets __tmp 自动释放
  }
}
</code></pre>

<p>  }
}
template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool>
hashtable&lt;<em>Val,</em>Key,<em>HF,</em>Ex,<em>Eq,</em>All>::insert_unique_noresize(const value_type&amp; <strong>obj) { // 不允许键值重复
  const size_type </strong>n = <em>M_bkt_num(__obj);
  </em>Node<em> <strong>first = _M_buckets[</strong>n];
  for (_Node</em> <strong>cur = </strong>first; <strong>cur; </strong>cur = <em>_cur-></em>M_next)</p>

<pre><code>if (_M_equals(_M_get_key(__cur-&gt;_M_val), _M_get_key(__obj))) // 判断是否存在重复的key
  return pair&lt;iterator, bool&gt;(iterator(__cur, this), false); 
</code></pre>

<p>  <em>Node* __tmp = </em>M_new_node(<strong>obj);
  </strong>tmp-><em>M_next = __first;
  </em>M_buckets[<strong>n] = </strong>tmp;
  ++_M_num_elements;
  return pair&lt;iterator, bool>(iterator(__tmp, this), true);
}
```
允许键值重复的插入操作类似的，只是为了确保相同键值的挨在一起，先要找到相同键值的位置，然后插入。</p>

<h4>整体复制和清空</h4>

<p>复制和清空时分别涉及空间的分配和释放，所以在这里也介绍一下。首先是复制操作，需要先将目标 hashtable 清空，然后将源 hashtable 的 buckets 中的每个链表一一复制，如下：<br/>
```
template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable&lt;<em>Val,</em>Key,<em>HF,</em>Ex,<em>Eq,</em>All>::<em>M_copy_from(const hashtable&amp; __ht) {
  </em>M_buckets.clear(); // 先清空目标 hashtable
  <em>M_buckets.reserve(__ht.</em>M_buckets.size()); // 大小重置为源 hashtable 的大小
  <em>M_buckets.insert(</em>M_buckets.end(), <strong>ht.<em>M_buckets.size(), (</em>Node*) 0); // 将目标 hashtable 的 buckets 置空
  </strong>STL_TRY {</p>

<pre><code>for (size_type __i = 0; __i &lt; __ht._M_buckets.size(); ++__i) { // 遍历 buckets
  const _Node* __cur = __ht._M_buckets[__i];
  if (__cur) {
    _Node* __copy = _M_new_node(__cur-&gt;_M_val);
    _M_buckets[__i] = __copy;
    for (_Node* __next = __cur-&gt;_M_next; __next; __cur = __next,
            __next = __cur-&gt;_M_next) { // 复制每个节点
      __copy-&gt;_M_next = _M_new_node(__next-&gt;_M_val);
      __copy = __copy-&gt;_M_next;
    }
  }
}
_M_num_elements = __ht._M_num_elements;
</code></pre>

<p>  }
  __STL_UNWIND(clear());
}
```</p>

<h2>4. hashtable 的迭代器</h2>

<p>hashtable 的迭代器是前向的单向迭代器，遍历的方式是先遍历完一个 list 然后切换到下一个 bucket 指向的 list 进行遍历。以下是 hashtable 的迭代器的定义：<br/>
```
template <class _Val, class _Key, class _HashFcn, class _ExtractKey, class _EqualKey, class _Alloc>
struct <em>Hashtable_iterator {
  typedef hashtable&lt;</em>Val,<em>Key,</em>HashFcn,<em>ExtractKey,</em>EqualKey,<em>Alloc> </em>Hashtable;
  typedef <em>Hashtable_iterator&lt;</em>Val, <em>Key, </em>HashFcn, <em>ExtractKey, </em>EqualKey, <em>Alloc> iterator;
  typedef </em>Hashtable_const_iterator&lt;<em>Val, </em>Key, <em>HashFcn, </em>ExtractKey, <em>EqualKey, </em>Alloc> const_iterator;
  typedef <em>Hashtable_node<_Val> </em>Node;</p>

<p>  <em>Node* </em>M_cur; // 指向当前节点
  <em>Hashtable* </em>M_ht; // 指向当前节点所在 bucket</p>

<p>  <em>Hashtable_iterator(</em>Node<em> <em>_n, </em>Hashtable</em> <strong>tab) : _M_cur(</strong>n), <em>M_ht(__tab) {}
  </em>Hashtable_iterator() {}
  reference operator<em>() const { return <em>M_cur-></em>M_val; }
  iterator&amp; operator++();
  iterator operator++(int);
  bool operator==(const iterator&amp; <strong>it) const { return _M_cur == </strong>it.<em>M_cur; }
  bool operator!=(const iterator&amp; __it) const { return </em>M_cur != <em><em>it.</em>M_cur; }
};
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
</em>Hashtable_iterator&lt;<em>Val,</em>Key,<em>HF,</em>ExK,<em>EqK,</em>All>&amp;
<em>Hashtable_iterator&lt;</em>Val,<em>Key,</em>HF,<em>ExK,</em>EqK,<em>All>::operator++(){
  const </em>Node</em> <em><em>old = </em>M_cur;
  </em>M_cur = <em>M_cur-></em>M_next;
  if (!_M_cur) { // 到了当前 bucket 的尾部</p>

<pre><code>size_type __bucket = _M_ht-&gt;_M_bkt_num(__old-&gt;_M_val);
while (!_M_cur &amp;&amp; ++__bucket &lt; _M_ht-&gt;_M_buckets.size())
  _M_cur = _M_ht-&gt;_M_buckets[__bucket];
</code></pre>

<p>  }
  return *this;
}
```</p>

<h2>5. 哈希函数</h2>

<p>在第三节中介绍 hashtable 的数据结构时，提到了一个哈希函数类型的模板参数，从键值到索引位置的映射由这个哈希函数来完成，实际中是通过函数 <code>_M_bkt_num_key</code> 来完成这个映射的，如下：<br/>
```
size_type _M_bkt_num_key(const key_type&amp; __key) const {</p>

<pre><code>return _M_bkt_num_key(__key, _M_buckets.size());
</code></pre>

<p>}
size_type _M_bkt_num_key(const key_type&amp; <strong>key, size_t </strong>n) const {</p>

<pre><code>return _M_hash(__key) % __n; // 在这里调用函数 _M_hash，实现映射
</code></pre>

<p>}
<code>
这里的 `_M_hash` 是一个哈希函数类型的成员，可以看做是一个函数指针，真正的函数的定义在 `&lt;stl_hash_fun.h&gt;` 中，针对 char，int，long 等整数型别，这里大部分的 hash function 什么也没做，只是重视返回原始值，但对字符串（const char* ）设计了一个转换函数，如下：  
</code>
template <class _Key> struct hash { }; // 仿函数 hash
inline size_t <strong>stl_hash_string(const char* </strong>s) { // 将字符串映射为整型
  unsigned long <strong>h = 0;
  for ( ; *</strong>s; ++__s)</p>

<pre><code>__h = 5*__h + *__s;
</code></pre>

<p>  return size_t(<strong>h);
}
</strong>STL_TEMPLATE_NULL struct hash&lt;char<em>> {
  size_t operator()(const char</em> <strong>s) const { return </strong>stl_hash_string(<strong>s); } // 函数调用操作符 operator()
};
</strong>STL_TEMPLATE_NULL struct hash<const char*> {
  size_t operator()(const char* <strong>s) const { return </strong>stl_hash_string(<strong>s); }
};
</strong>STL_TEMPLATE_NULL struct hash<char> {
  size_t operator()(char <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<unsigned char> {
  size_t operator()(unsigned char </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<signed char> {
  size_t operator()(unsigned char <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<short> {
  size_t operator()(short </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned short> {
  size_t operator()(unsigned short <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<int> {
  size_t operator()(int </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned int> {
  size_t operator()(unsigned int <strong>x) const { return </strong>x; }
};
<strong>STL_TEMPLATE_NULL struct hash<long> {
  size_t operator()(long </strong>x) const { return <strong>x; }
};
</strong>STL_TEMPLATE_NULL struct hash<unsigned long> {
  size_t operator()(unsigned long <strong>x) const { return </strong>x; }
};
```
关于函数调用操作符的更多介绍，可以参见我的另一篇文章 【<a href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/">C语言函数指针与C++函数调用操作符</a>】。</p>
]]></content>
  </entry>
  
</feed>