<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 内存管理 | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/nei-cun-guan-li/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2015-01-26T00:09:36+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(1) 空间配置器(allocator)]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator/"/>
    <updated>2014-06-13T22:04:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator</id>
    <content type="html"><![CDATA[<p>在STL中，Memory Allocator 处于最底层的位置，为一切的 Container 提供存储服务，是一切其他组件的基石。对于一般使用 STL 的用户而言，Allocator 是不可见的，如果需要对 STL 进行扩展，如编写自定义的容器，就需要调用 Allocator 的内存分配函数进行空间配置。本文涉及到的 SGI STL 源代码文件有 <code>alloc.h</code>, <code>stl_config.h</code>, <code>stl_alloc.h</code>, <code>stl_threads.h</code> 这4个。</p>

<p>在C++中，一个对象的内存配置和释放一般都包含两个步骤，对于内存的配置，首先是调用operator new来配置内存，然后调用对象的类的构造函数进行初始化；而对于内存释放，首先是调用析构函数，然后调用 operator delete进行释放。 如以下代码：
<code>cpp
class Foo { ... };
Foo* pf = new Foo;
...
delete pf;
</code>
Allocator 的作用相当于operator new 和operator delete的功能，只是它考虑得更加细致周全。SGI STL 中考虑到了内存分配失败的异常处理，内置轻量级内存池（主要用于处理小块内存的分配，应对内存碎片问题）实现， 多线程中的内存分配处理（主要是针对内存池的互斥访问）等，本文就主要分析 SGI STL 中在这三个方面是如何处理的。在介绍着三个方面之前，我们先来看看 Allocator的标准接口。</p>

<!-- more -->


<h2>1. Allocator 的标准接口</h2>

<p>在 SGI STL 中，Allocator的实现主要在文件<code>alloc.h</code> 和 <code>stl_alloc.h</code> 文件中。根据 STL 规范，Allocator 需提供如下的一些接口（见 <code>stl_alloc.h</code> 文件的第588行开始的class template allocator）：<br/>
``` cpp
// 标识数据类型的成员变量，关于中间的6个变量的涵义见后续文章（关于Traits编程技巧）
typedef alloc <em>Alloc;
typedef size_t     size_type;
typedef ptrdiff_t  difference_type;
typedef </em>Tp<em>       pointer;
typedef const _Tp</em> const_pointer;
typedef <em>Tp&amp;       reference;
typedef const </em>Tp&amp; const_reference;
typedef _Tp        value_type;
template <class _Tp1> struct rebind {</p>

<pre><code>typedef allocator&lt;_Tp1&gt; other;
</code></pre>

<p>}; // 一个嵌套的class template，仅包含一个成员变量 other
// 成员函数
allocator() <strong>STL_NOTHROW {}  // 默认构造函数，其中</strong>STL_NOTHROW 在 stl_config.h中定义，要么为空，要么为 throw()
allocator(const allocator&amp;) <strong>STL_NOTHROW {}  // 拷贝构造函数
template <class _Tp1> allocator(const allocator<_Tp1>&amp;) </strong>STL_NOTHROW {} // 泛化的拷贝构造函数
~allocator() <strong>STL_NOTHROW {} // 析构函数
pointer address(reference </strong>x) const { return &amp;<strong>x; } // 返回对象的地址
const_pointer address(const_reference </strong>x) const { return &amp;<strong>x; }  // 返回const对象的地址
_Tp* allocate(size_type </strong>n, const void* = 0) {</p>

<pre><code>return __n != 0 ? static_cast&lt;_Tp*&gt;(_Alloc::allocate(__n * sizeof(_Tp))) : 0; 
// 配置空间，如果申请的空间块数不为0，那么调用 _Alloc 也即 alloc 的 allocate 函数来分配内存，
</code></pre>

<p>} //这里的 alloc 在 SGI STL 中默认使用的是<strong>default_alloc_template&lt;</strong>NODE_ALLOCATOR_THREADS, 0>这个实现（见第402行）
void deallocate(pointer <strong>p, size_type </strong>n) { <em>Alloc::deallocate(<strong>p, </strong>n * sizeof(</em>Tp)); } // 释放空间
size_type max_size() const __STL_NOTHROW  // max_size() 函数，返回可成功配置的最大值</p>

<pre><code>{ return size_t(-1) / sizeof(_Tp); }  //这里没看懂，这里的size_t(-1)是什么意思？
</code></pre>

<p>void construct(pointer <strong>p, const _Tp&amp; </strong>val) { new(<strong>p) _Tp(</strong>val); } // 调用 new 来给新变量分配空间并赋值
void destroy(pointer <strong>p) { </strong>p->~<em>Tp(); } // 调用 </em>Tp 的析构函数来释放空间
<code>
在SGI STL中设计了如下几个空间分配的 class template：  
</code> cpp
template <int __inst> class <strong>malloc_alloc_template // Malloc-based allocator.  Typically slower than default alloc
typedef </strong>malloc_alloc_template<0> malloc_alloc
template<class _Tp, class _Alloc> class simple_alloc
template <class _Alloc> class debug_alloc
template <bool threads, int inst> class <strong>default_alloc_template // Default node allocator.
typedef </strong>default_alloc_template&lt;<strong>NODE_ALLOCATOR_THREADS, 0> alloc
typedef </strong>default_alloc_template&lt;false, 0> single_client_alloc
template <class _Tp>class allocator
template&lt;>class allocator<void>
template <class _Tp, class _Alloc>struct <strong>allocator
template <class _Alloc>class </strong>allocator&lt;void, <em>Alloc>
<code>``
其中</code>simple_alloc<code>,</code>debug_alloc<code>,</code>allocator<code>和</code>__allocator<code> 的实现都比较简单，都是对其他适配器的一个简单封装（因为实际上还是调用其他配置器的方法，如</code></em>Alloc::allocate<code>）。而真正内容比较充实的是</code><strong>malloc_alloc_template<code>和</code></strong>default_alloc_template<code>这两个配置器，这两个配置器就是 SGI STL 配置器的精华所在。其中</code><strong>malloc_alloc_template<code>是SGI STL 的第一层配置器，只是对系统的</code>malloc<code>,</code>realloc<code>函数的一个简单封装，并考虑到了分配失败后的异常处理。而</code></strong>default_alloc_template` 是SGI STL 的第二层配置器，在第一层配置器的基础上还考虑了内存碎片的问题，通过内置一个轻量级的内存池。下文将先介绍第一级配置器的异常处理机制，然后介绍第二级配置器的内存池实现，及在多线程环境下内存池互斥访问的机制。</p>

<h2>2. SGI STL 内存分配失败的异常处理</h2>

<p>内存分配失败一般是由于out-of-memory(oom)，SGI STL 本身并不会去处理oom问题，而只是提供一个 private 的函数指针成员和一个 public 的设置该函数指针的方法，让用户来自定义异常处理逻辑：
``` cpp
private:</p>

<h1>ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG</h1>

<p>  static void (* __malloc_alloc_oom_handler)();  // 函数指针</p>

<h1>endif</h1>

<p>public:
  static void (<em> __set_malloc_handler(void (</em>__f)()))() // 设置函数指针的public方法
  {</p>

<pre><code>void (* __old)() = __malloc_alloc_oom_handler;
__malloc_alloc_oom_handler = __f;
return(__old);
</code></pre>

<p>  }
<code>
如果用户没有调用该方法来设置异常处理函数，那么就不做任何异常处理，仅仅是想标准错误流输出一句out of memory并退出程序（对于使用new和C++特性的情况而言，则是抛出一个`std::bad_alloc()`异常）， 因为该函数指针的缺省值为0，此时对应的异常处理是 `__THROW_BAD_ALLOC`：
</code> cpp
// line 152 ~ 155</p>

<h1>ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG</h1>

<p>template <int __inst>
void (* <strong>malloc_alloc_template<__inst>::</strong>malloc_alloc_oom_handler)() = 0;</p>

<h1>endif</h1>

<p>// in <em>S_oom_malloc and </em>S_oom_realloc
<strong>my_malloc_handler = </strong>malloc_alloc_oom_handler;
if (0 == <strong>my_malloc_handler) { </strong>THROW_BAD_ALLOC; }
// in preprocess, line 41 ~ 50</p>

<h1>ifndef __THROW_BAD_ALLOC</h1>

<h1>if defined(<strong>STL_NO_BAD_ALLOC) || !defined(</strong>STL_USE_EXCEPTIONS)</h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>define __THROW_BAD_ALLOC fprintf(stderr, "out of memory\n"); exit(1)</h1>

<h1>else /<em> Standard conforming out-of-memory handling </em>/</h1>

<h1>include <new></h1>

<h1>define __THROW_BAD_ALLOC throw std::bad_alloc()</h1>

<h1>endif</h1>

<h1>endif</h1>

<p>```
SGI STL 内存配置失败的异常处理机制就是这样子了，提供一个默认的处理方法，也留有一个用户自定义处理异常的接口。</p>

<h2>3. SGI STL 内置轻量级内存池的实现</h2>

<p>第一级配置器 <code>__malloc_alloc_template</code> 仅仅只是对 <code>malloc</code> 的一层封装，没有考虑可能出现的内存碎片化问题。内存碎片化问题在大量申请小块内存是可能非常严重，最终导致碎片化的空闲内存无法充分利用。SGI 于是在第二级配置器 <code>__default_alloc_template</code> 中 内置了一个轻量级的内存池。 对于小内存块的申请，从内置的内存池中分配。然后维护一些空闲内存块的链表（简记为空闲链表，free list），小块内存使用完后都回收到空闲链表中，这样如果新来一个小内存块申请，如果对应的空闲链表不为空，就可以从空闲链表中分配空间给用户。具体而言SGI默认最大的小块内存大小为128bytes，并设置了128/8=16 个free list，每个list 分别维护大小为 8, 16, 24, ..., 128bytes 的空间内存块（均为8的整数倍），如果用户申请的空间大小不足8的倍数，则向上取整。</p>

<p>SGI STL内置内存池的实现请看 <code>__default_alloc_template</code> 中被定义为 private 的这些成员变量和方法（去掉了部分预处理代码和互斥处理的代码）：
``` cpp
private:</p>

<h1>if ! (defined(<strong>SUNPRO_CC) || defined(</strong>GNUC__))</h1>

<pre><code>enum {_ALIGN = 8}; // 对齐大小
enum {_MAX_BYTES = 128}; // 最大有内置内存池来分配的内存大小
enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN  // 空闲链表个数
</code></pre>

<h1>endif</h1>

<p>  static size_t  _S_round_up(size_t __bytes) // 不是8的倍数，向上取整</p>

<pre><code>{ return (((__bytes) + (size_t) _ALIGN-1) &amp; ~((size_t) _ALIGN - 1)); }
</code></pre>

<p><em>_PRIVATE:
  union </em>Obj { // 空闲链表的每个node的定义</p>

<pre><code>    union _Obj* _M_free_list_link;
    char _M_client_data[1];   };
</code></pre>

<p>  static <em>Obj* __STL_VOLATILE </em>S_free_list[]; // 空闲链表数组
  static size_t _S_freelist_index(size_t <strong>bytes) { // </strong>bytes 对应的free list的index</p>

<pre><code>    return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);
</code></pre>

<p>  }
  static void<em> _S_refill(size_t __n); // 从内存池中申请空间并构建free list，然后从free list中分配空间给用户
  static char</em> <em>S_chunk_alloc(size_t <strong>size, int&amp; </strong>nobjs); // 从内存池中分配空间
  static char* </em>S_start_free;  // 内存池空闲部分的起始地址
  static char* <em>S_end_free; // 内存池结束地址
  static size_t </em>S_heap_size; // 内存池堆大小，主要用于配置内存池的大小
<code>``
其中</code><em>S_refill<code>和</code></em>S_chunk_alloc<code>这两个函数是该内存池机制的核心。</code><em>_default_alloc_template<code>对外提供的 public 的接口有</code>allocate<code>,</code>deallocate<code>和</code>reallocate<code>这三个，其中涉及内存分配的</code>allocate<code>和</code>reallocate<code>的逻辑思路是，首先看申请的size（已round up）对应的free list是否为空，如果为空，则调用</code></em>S_refill<code>来分配，否则直接从对应的free list中分配。而</code>deallocate` 的逻辑是直接将空间插入到相应free list的最前面。</p>

<p>函数 <code>_S_refill</code> 的逻辑是，先调用 <code>_S_chunk_alloc</code> 从内存池中分配20块小内存（而不是用户申请的1块），将这20块中的第一块返回给用户，而将剩下的19块依次链接，构建一个free list。这样下次再申请同样大小的内存就不用再从内存池中取了。有了 <code>_S_refill</code> ，用户申请空间时，就不是直接从内存池中取了，而是从 free list 中取。因此 <code>allocate</code> 和 <code>reallocate</code> 在相应的free list为空时都只需直接调用 <code>_S_refill</code> 就行了。</p>

<p>这里默认是依次申请20块，但如果内存池空间不足以分配20块时，会尽量分配足够多的块，这些处理都在 <code>_S_chunk_alloc</code> 函数中。该函数的处理逻辑如下（源代码这里就不贴了）：</p>

<blockquote><p>1) 能够分配20块</p>

<blockquote><p>从内存池分配20块出来，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>2) 不足以分配20块，但至少能分配一块</p>

<blockquote><p>分配经量多的块数，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>3) 一块也分配不了</p>

<blockquote><p>首先计算新内存池大小 <code>size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4)</code><br/>
将现在内存池中剩余空间插入到适当的free list中<br/>
调用 <code>malloc</code> 来获取一大片空间作为新的内存池：<br/>
-- 如果分配成功，则调整 <code>_S_end_free</code> 和 <code>_S_heap_size</code> 的值，并重新调用自身，从新的内存池中给用户分配空间；
-- 否则，分配失败，考虑从比当前申请的空间大的free list中分配空间，如果无法找不到这样的非空free list，则调用第一级配置器的allocate，看oom机制能否解决问题</p></blockquote></blockquote>

<p>SGI STL的轻量级内存池的实现就是酱紫了，其实并不复杂。</p>

<h2>4. SGI STL 内存池在多线程下的互斥访问</h2>

<p>最后，我们来看看SGI STL中如何处理多线程下对内存池互斥访问的（实际上是对相应的free list进行互斥访问，这里访问是只需要对free list进行修改的访问操作）。在SGI的第二级配置器中与内存池互斥访问相关的就是 <code>_Lock</code> 这个类了，它仅仅只包含一个构造函数和一个析构函数，但这两个函数足够了。在构造函数中对内存池加锁，在析构函数中对内存池解锁：
``` cpp
//// in __default_alloc_template</p>

<h1>ifdef __STL_THREADS</h1>

<pre><code>static _STL_mutex_lock _S_node_allocator_lock; // 互斥锁变量
</code></pre>

<h1>endif</h1>

<p>class _Lock {</p>

<pre><code>public:
    _Lock() { __NODE_ALLOCATOR_LOCK; }
    ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }
</code></pre>

<p>};
//// in preprocess</p>

<h1>ifdef __STL_THREADS</h1>

<h1>include &lt;stl_threads.h> // stl 的线程，只是对linux或windows线程的一个封装</h1>

<h1>define __NODE_ALLOCATOR_THREADS true</h1>

<h1>ifdef __STL_SGI_THREADS</h1>

<h1>define <strong>NODE_ALLOCATOR_LOCK if (threads &amp;&amp; </strong>us_rsthread_malloc) \</h1>

<pre><code>            { _S_node_allocator_lock._M_acquire_lock(); }  // 获取锁
</code></pre>

<h1>define <strong>NODE_ALLOCATOR_UNLOCK if (threads &amp;&amp; </strong>us_rsthread_malloc) \</h1>

<pre><code>            { _S_node_allocator_lock._M_release_lock(); }  // 释放锁
</code></pre>

<h1>else /<em> !__STL_SGI_THREADS </em>/</h1>

<h1>define __NODE_ALLOCATOR_LOCK \</h1>

<pre><code>    { if (threads) _S_node_allocator_lock._M_acquire_lock(); }
</code></pre>

<h1>define __NODE_ALLOCATOR_UNLOCK \</h1>

<pre><code>    { if (threads) _S_node_allocator_lock._M_release_lock(); }
</code></pre>

<h1>endif</h1>

<h1>else /<em> !__STL_THREADS </em>/</h1>

<h1>define __NODE_ALLOCATOR_LOCK</h1>

<h1>define __NODE_ALLOCATOR_UNLOCK</h1>

<h1>define __NODE_ALLOCATOR_THREADS false</h1>

<h1>endif</h1>

<p>```</p>

<p>由于在 <code>__default_alloc_template</code> 的对外接口中，只有 <code>allocate</code> 和 <code>deallocate</code> 中直接涉及到对free list进行修改的操作，所以在这两个函数中，在对free list进行修改之前，都要实例化一个 <code>_Lock</code> 的对象 <code>__lock_instance</code> ，此时调用构造函数进行加锁，当函数结束时，的对象 <code>__lock_instance</code> 自动析构，释放锁。这样，在多线程下，可以保证free list的一致性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 应用程序性能优化之 new/delete 操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator/"/>
    <updated>2014-05-11T20:33:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/11/cpp-program-optimization-new-delete-operator</id>
    <content type="html"><![CDATA[<h2>1.概述</h2>

<p>C++ 程序的存储空间可以分为静态/全局存储区、栈区和堆区。下图展示了一个典型的Linux C/C++ 程序内存空间布局：</p>

<center>{% img /images/2014/IMAG2014051101.png %}</center>


<p>其中，每一部分的具体涵义如下：<br/>
- <strong>代码段（.text）</strong>：这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是<strong>只读</strong>的，防止程序由于错误而修改自身的指令。<br/>
- <strong>初始化数据段（.data）</strong>：这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=100;</code> 。 需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用 exec 函数启动该程序时从源程序文件中读入。<br/>
- <strong>未初始化数据段（.bss）</strong>：位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：<code>int sum;</code><br/>
- <strong>堆（Heap）</strong>：这个段用于在程序中进行动态内存申请，例如经常用到的 malloc，new 系列函数就是从这个段中申请内存。<br/>
- <strong>栈（Stack）</strong>：函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。<br/>
静态/全局存储区和栈区一般在程序编译阶段决定；而堆区则随着程序的运行而动态变化，每一次程序运行都会有不同的行为，因此动态内存管理对于一个程序在运行过程中占用的内存大小及程序运行性能有非常重要的影响。 本文主要探讨在C++中如何管理动态内存，以及如何使用 C++ 的语言特性来提高动态内存的管理效率，减少错误的发生。</p>

<!-- more -->


<h2>2. new/delete 操作符</h2>

<h4>2.1 C++内置new/delete的原型</h4>

<p>一般来说 C++ 的运行库提供了默认的全局 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的实现，程序也可以用自定义的实现来取代运行库的实现。 下面是 C++ 标准中定义的 <code>new/new[]</code> 和 <code>delete/delete[]</code> 的声明（位于 <code>include/c++/new</code> 文件中）：</p>

<p>``` cpp
namespace std {
  class bad_alloc : public exception {</p>

<pre><code>public:
  bad_alloc() throw() { }
  virtual ~bad_alloc() throw();
  virtual const char* what() const throw();
</code></pre>

<p>  };
  struct nothrow_t { };
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler) throw();
} // namespace std</p>

<p>void<em> operator new(std::size_t) throw (std::bad_alloc);  // (1)
void</em> operator new<a href="std::size_t"></a> throw (std::bad_alloc);
void operator delete(void<em>) throw();
void operator delete<a href="void*"></a> throw();
void</em> operator new(std::size_t, const std::nothrow_t&amp;) throw();  // (2)
void<em> operator new<a href="std::size_t,%20const%20std::nothrow_t&amp;"></a> throw();
void operator delete(void</em>, const std::nothrow_t&amp;) throw();
void operator delete<a href="void*,%20const%20std::nothrow_t&amp;"></a> throw();
// Default placement versions of operator new.
inline void<em> operator new(std::size_t, void</em> <strong>p) throw() { return </strong>p; }  // (3)
inline void<em> operator new<a href="std::size_t,%20void*%20__p"></a> throw() { return __p; }
// Default placement versions of operator delete.
inline void  operator delete  (void</em>, void*) throw() { }
inline void  operator delete<a href="void*,%20void*"></a> throw() { }
```</p>

<p>其中最后的 <code>inline</code> 函数是 <code>placement</code> 版本的 new/delete 操作，其特点在于分配的内存块的起始地址由用户给定（通过参数 <code>void* __p</code>）。 而前面两种 <code>new/delete</code> （(1)和(2)处）是系统决定待分配内存块的起始地址，区别在于：第一个在分配失败是会抛出 <code>bad_alloc</code> 异常（这是C++标准要求的）；而第二个则不抛出异常，返回0。 很多应用程序都没有处理内存分配的失败情况，但相对于一个需要长期稳定运行的系统来说，这种处理是必不可少的。 应用程序可以通过捕获 <code>bad_alloc</code> 异常或者检查返回值来检查内存分配是否成功，而更好的方法是使用C++中的 <code>new_handler()</code> 函数。 C++规定 <code>new_handler</code> 要执行如下操作中的一种：</p>

<ul>
<li>使 <code>new</code> 有更多的内存可用，然后返回</li>
<li>抛出一个 <code>bad_alloc</code> 或其派生类的异常</li>
<li>调用 <code>abort()</code> 或者 <code>exit()</code> 退出</li>
</ul>


<h4>2.2 使用 <code>new_handler</code> 自定义异常处理</h4>

<p>下面看一个例子，看看如何使用 <code>new_handler</code> 处理内存分配失败的情况：</p>

<p>``` cpp</p>

<h1>include<new></h1>

<h1>include<cstdio></h1>

<h1>include&lt;Windows.h></h1>

<p>using namespace std;
char *gPool = NULL;
void my_new_handler();</p>

<p>int main(){</p>

<pre><code>set_new_handler(my_new_handler);
gPool = new char[512*1024*1024];
if(gPool!=NULL){
    printf("Preserve 512MB memory at %x.\n",gPool);
}
char *p = NULL;
for(int i=0;i&lt;4;i++){
    p = new char[512*1024*1024];
    printf("%d * 512M, p = %x\n",i+1,p);
    Sleep(5000); // 休眠5s
}
printf("Done.\n");
return 0;
</code></pre>

<p>}</p>

<p>void my_new_handler(){</p>

<pre><code>if(gPool!=NULL){
    printf("try to get more memory...\n");
    delete[] gPool; // 释放512MB内存空间
    gPool = NULL;
    return;
}else{
    printf("I can not help...\n");
    throw bad_alloc();  // 分配失败，抛出异常
}
return;
</code></pre>

<p>}
```</p>

<p>在 Windows 上编译并运行（使用Code::Blocks 13.12 IDE），得到如下输出：</p>

<p>```
Preserve 512MB memory at 7e0020.
1 * 512M, p = 207f0020
2 * 512M, p = 40800020
try to get more memory...
3 * 512M, p = 7e0020
I can not help...
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc</p>

<p>This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
```</p>

<p>在 Windows 的 win32 程序中，一个进程可以访问的内存空间是 4GB，但可以用来动态分配的最大内存是 2GB，因而上面的程序执行到第3次（为神马不是第4次？）动态内存分配时由于内存不够，调用了 <code>my_new_handler</code> 获得了内存（可以看到第3次分配的内存的地址和Preserve的内存地址是一样的），而当执行第4次内存分配时，<code>gPool</code> 已被分配，于是 <code>my_new_handler</code> 中抛出了 <code>bad_alloc</code> 异常，导致程序退出。 另外，在程序实际运行过程当中，会发现任务管理器中内存占用不会往上飙，这可能是因为操作系统的动态内存管理策略在作怪，不会说你一申请就立马全部给你，只是建立了一个映射表，只有当你真正用的时候才会给你。</p>

<h4>2.3 使用 placement new</h4>

<p>在 C++ 内置 <code>new/delete</code> 中最后的一种是 placement 形式的 <code>new/delete</code> ，即分配的内存地址有用户给定。下面是一个最简单的实例：</p>

<p>``` cpp</p>

<h1>include <cstdio></h1>

<h1>include <new></h1>

<p>using namespace std;</p>

<p>int main()
{</p>

<pre><code>char buffer[100];
char *p = new(buffer) char[20]; // call placement new
printf("Address of buffer: %x, and p: %x.\n",buffer,p);
return 0;
</code></pre>

<p>}
// output: Address of buffer: 28feb8, and p: 28feb8.
```</p>

<p>可以看到 <code>buffer</code> 和 <code>p</code> 的地址是一样的。在大型应用程序中，我们可以充分利用 <code>placement new</code> 的特性，实现自己管理（分配、释放等）本应用的内存空间，基本思路就是： 首先申请一大片内存，然后对每个小的动态内存分配都使用 <code>placement new</code> 的方式进行申请。</p>

<h4>2.4 重载 placement new</h4>

<p>在 <code>new</code> 操作符中，除了可以使用自定义申请的内存的大小及位置，我们还可以通过重载系统的 <code>new/delete</code> 操作符来加入其它一些附加参数，但仍称之为 <code>placement new</code> 。例如：</p>

<p>``` cpp</p>

<h1>include<cstdio></h1>

<h1>include<new></h1>

<p>using namespace std;</p>

<h1>define DEBUG</h1>

<h1>ifdef DEBUG</h1>

<p>// 自定义 new 操作符
void *operator new<a href="unsigned%20int%20n,%20const%20char*%20file,%20int%20line"></a>{</p>

<pre><code>printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
return ::operator new(n);
</code></pre>

<p>}
// 自定义 delete 操作符
// void operator delete(void <em>p,const char </em>file, int line){
void operator delete<a href="void%20*p,const%20char%20*file,%20int%20line"></a>{</p>

<pre><code>printf("delete at file %s, in line %d\n",file,line);
::operator delete(p);
return;
</code></pre>

<p>}
// 宏定义，必须放在重载函数之后</p>

<h1>define new new(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>define delete delete(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>endif</h1>

<p>int main(){</p>

<pre><code>char *p = new char[10];
//delete p;  // delete 的重载还有问题 "error: type 'int' argument given to 'delete', expected pointer"
delete[] p;  // 直接报语法错误，"error: expected primary-expression before ']' token"
return 0;
</code></pre>

<p>}
// output: Alloc size: 10 at file D:\Programs\test\main.cpp, in line 22
```</p>

<p>这在 <code>DEBUG</code> 模式下非常好使。</p>

<p>更新：关于 <code>placement new</code> 的 demo 改为如下代码后就没问题了：</p>

<p>``` cpp</p>

<h1>include<cstdio></h1>

<h1>include<new></h1>

<p>using namespace std;</p>

<h1>define DEBUG</h1>

<h1>ifdef DEBUG</h1>

<p>// 自定义 new 操作符
void *operator new<a href="unsigned%20int%20n,%20const%20char*%20file,%20int%20line"></a>{</p>

<pre><code>printf("Alloc size: %d at file %s, in line %d\n",n,file,line);
return ::operator new(n);
</code></pre>

<p>}
// 自定义 delete 操作符
void operator delete(void <em>p,char </em>file, int line){</p>

<pre><code>printf("Delete at file %s, in line %d\n",file,line);
::operator delete(p);
return;
</code></pre>

<p>}
// 宏定义，必须放在重载函数之后</p>

<h1>define new new(<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>define delete(ptr) delete(ptr,<strong>FILE</strong>, <strong>LINE</strong>)</h1>

<h1>endif</h1>

<p>int main(){</p>

<pre><code>char *p = new char[10];
operator delete(p);
return 0;
</code></pre>

<p>}
```</p>

<p>但是还是不知道之前的代码为什么会出现这个错误，已在 <a href="http://stackoverflow.com/questions/23614215/destructor-error-in-c-type-int-argument-given-to-delete-expected-pointer">StackOverFlow上提问</a>，希望能得到满意的答案。</p>
]]></content>
  </entry>
  
</feed>