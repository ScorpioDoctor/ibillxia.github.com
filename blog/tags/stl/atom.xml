<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: STL | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/stl/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-07-09T15:25:03+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(2) 迭代器(Iterators)和Traits]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits/"/>
    <updated>2014-06-21T21:46:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/21/stl-source-insight-2-iterators-and-traits</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件有 <code>iterator.h</code>, <code>stl_iterator_base.h</code>, <code>concept_checks.h</code>, <code>stl_iterator.h</code>, <code>type_traits.h</code>, <code>stl_construct.h</code>, <code>stl_raw_storage_iter.h</code> 等7个文件。</p>

<h2>1. 迭代器的设计思维</h2>

<p>迭代器（iterators）是一种抽象的设计概念，显示程序中并没有直接对应于这个概念的实体。在 <em>Design Patterns</em> 一书中，对 iterators 模式的定义如下：提供一种方法，使之能够依序遍历某个聚合物（容器）所包含的各个元素，而又无需暴露该聚合物内部的表述方式。</p>

<p>在STL中迭代器扮演着重要的角色。STL的中心思想在于：将数据容器（container）和算法（algorithm）分开，彼此独立设计，最后再通过某种方式将他们衔接在一起。容器和算法的泛型化，从技术的角度来看并不困难，C++ 的 class template 和 function template 可以分别达到目标，难点在于如何设计二者之间的衔接器。</p>

<p>在STL中，起者这种衔接作用的是迭代器，它是一种行为类似指针的对象。指针的各种行为中最常见也最重要的便是内容获取（dereference）和成员访问（member access），因此迭代器最重要的工作就是对 <code>operator*</code> 和 <code>operator-&gt;</code> 进行重载。然而要对这两个操作符进行重载，就需要对容器内部的对象的数据类型和存储结构有所了解，于是在 STL 中迭代器的最终实现都是由容器本身来实现的，每种容器都有自己的迭代器实现，例如我们使用vector容器的迭代器的时候是这样用的 <code>vector&lt;int&gt;::iterator it;</code> 。而本文所讨论的迭代器是不依存于特定容器的迭代器，它在STL中主要有以下两个方面的作用（我自己的理解和总结）：</p>

<blockquote><ul>
<li>规定容器中需要实现的迭代器的类型及每种迭代器的标准接口</li>
<li>通过Traits编程技巧实现迭代器相应型别的获取，弥补 C++ 模板参数推导的不足，为配置器提供可以获取容器中对象型别的接口</li>
</ul>
</blockquote>

<p>其中前一个没啥好解释的。关于第二个，后面第3节会详细介绍，那就是Traits编程技巧。</p>

<!-- more -->


<h2>2. STL 迭代器的分类与标准接口</h2>

<h3>2.1 STL 迭代器的分类</h3>

<p>在SGI STL中迭代器按照移动特性与读写方式分为 <code>input_iterator</code>, <code>output_iterator</code>, <code>forward_iterator</code>, <code>bidirectional_iterator</code>, <code>random_access_iterator</code> 这5种，他们的定义都在 <code>stl_iterators_base.h</code> 文件中。这5种迭代器的特性如下：</p>

<blockquote><p>input_iterator:  这种迭代器所指对象只允许读取，而不允许改变，是只读的（read only）。
output_iterator:  与上面的相反，只能写（write only）。
forward_iterator: 同时允许读和写，适用于 <code>replace()</code> 等算法。
bidirectional_iterator: 可双向移动，即既可以按顺序访问，也可以按逆序访问。
random_access_iterator: 前4种只提供一部分指针运算功能，如前3种只支持 <code>operator++</code>, 而第4种还支持 <code>operator--</code>, 但这种随机访问迭代器还支持 <code>p+n</code>, <code>p-n</code>, <code>p[n]</code>, <code>p1-p2</code>, <code>p1+p2</code> 等。</p></blockquote>

<p>从以上的特性可以看出，<code>input_iterator</code> 和 <code>output_iterator</code> 都是特殊的 <code>forward_iterator</code>, 而 <code>forward_iterator</code> 是特殊的 <code>bidirectional_iterator</code>, <code>bidirectional_iterator</code> 是特殊的 <code>random_access_iterator</code> 。在 <code>stl_iterator_base.h</code> 文件中，他们的定义中我们并不能看到这种特性的表达，而只是规定了这几种迭代器类型及应该包含的成员属性，真正表达这些迭代器不同特性的代码在 <code>stl_iterator.h</code> 文件中。在 <code>stl_iterator_base.h</code> 文件中，除了对这几种迭代器类型进行规定之外，还提供了获取迭代器类型的接口、获取迭代器中的 <code>value_type</code> 类型、获取迭代器中的 <code>distance_type</code> 、获取两个迭代器的距离（<code>distance</code> 函数）、将迭代器向前推进距离 n （<code>advance</code> 函数）等标准接口。</p>

<h3>2.2 STL迭代器的标准接口</h3>

<p>在 <code>stl_iterator.h</code> 文件中，设计了 <code>back_insert_iterator</code>, <code>front_insert_iterator</code>, <code>insert_iterator</code>, <code>reverse_bidirectional_iterator</code>, <code>reverse_iterator</code>, <code>istream_iterator</code>, <code>ostream_iterator</code>,  等标准的迭代器，其中前3中都使用 <code>output_iterator</code> 的只写特性（只进行插入操作，只是插入的位置不同而已），而第4种使用的是 <code>bidirectional_iterator</code> 的双向访问特性，第5种使用的是 <code>random_access_iterator</code> 的随机访问特性。而最后两种标准迭代器分别是使用 <code>input_iterator</code> 和 <code>output_iterator</code> 特性的迭代器。从这几个标准的迭代器的定义中可以看出，主要是实现了 <code>operator=</code>, <code>operator*</code>, <code>operator-&gt;</code>, <code>operator==</code>, <code>operator++</code>, <code>operator--</code>, <code>operator+</code>, <code>operator-</code>, <code>operator+=</code>, <code>operator-=</code> 等指针操作的标准接口。根据定义的操作符的不同，就是不同类型的迭代器了。</p>

<p>例如，下面是 <code>back_insert_iterator</code> 的标准定义：
```
template <class _Container>
class back_insert_iterator {
protected:
  <em>Container* container;
public:
  // member variables
  typedef </em>Container          container_type;
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;
  // member functions, mainly about operator overloading
  explicit back_insert_iterator(<em>Container&amp; <strong>x) : container(&amp;</strong>x) {}
  back_insert_iterator<_Container>&amp;
  operator=(const typename </em>Container::value_type&amp; __value) {</p>

<pre><code>container-&gt;push_back(__value);
return *this;
</code></pre>

<p>  }
  back_insert_iterator<_Container>&amp; operator<em>() { return </em>this; }
  back_insert_iterator<_Container>&amp; operator++() { return <em>this; }
  back_insert_iterator<_Container>&amp; operator++(int) { return </em>this; }
};
```</p>

<h2>3. 迭代器相应型别与Traits编程技巧</h2>

<h3>3.1 迭代器相应型别</h3>

<p>在算法中运用迭代器是，很可能需要获取器相应型别，即迭代器所指对象的类型。此时需要使用到 function template 的参数推导（argument deducation）机制，在传入迭代器模板类型的同时，传入迭代器所指对象的模板类型，例如：<br/>
```
template<class I, class T>
void func_impl(I iter, T t){</p>

<pre><code>// TODO: Add your code here
</code></pre>

<p>}
<code>``
这里不仅要传入类型</code>class I<code>, 还要传入类型</code>class T`。然而，迭代器的相应型别并不仅仅只有 “迭代器所指对象的类型” 这一种，例如在STL中就有如下5种：</p>

<blockquote><p>value_type: 迭代器所指对象的类型。<br/>
difference_type: 表示两个迭代器之间的距离，因此也可以用来表示一个容器的最大容量。例如一个提供计数功能的泛型算法 <code>count()</code> ，其返回值的类型就是迭代器的 <code>difference_type</code> .<br/>
reference_type: 从迭代器所指内容是否允许修改来看，迭代器分为 constant iterator 和 mutable iterator，如果传回一个可以修改的对象，一般是以 reference 的方式，因此需要传回引用时，使用此类型。<br/>
pointer_type: 在需要传回迭代器所指对象的地址时，使用这种类型。
iterator_category: 即前面提到5种的迭代器的类型。</p></blockquote>

<p>而且实际当中，并不是所有情况都可以通过以上的 template 的参数推导机制来实现（例如算法返回值的类型是迭代器所指对象的类型，template参数推导机制无法推导返回值类型），因此需要更一般化的解决方案，在STL中，这就是Traits编程技巧。</p>

<h3>3.2 Traits 编程技巧</h3>

<p>在STL的每个标准迭代器中，都定义了5个迭代器相应型别的成员变量，在STL定义了一个统一的接口：<br/>
```
// In file stl_iterator_base.h
template &lt;class <em>Category, class </em>Tp, class _Distance = ptrdiff_t,</p>

<pre><code>      class _Pointer = _Tp*, class _Reference = _Tp&amp;&gt;
</code></pre>

<p>struct iterator {
  typedef <em>Category  iterator_category;
  typedef </em>Tp        value_type;
  typedef <em>Distance  difference_type;
  typedef </em>Pointer   pointer;
  typedef _Reference reference;
};
```
其他的迭代器都可以继承这个标注类，由于后面3个模板参数都有默认值，因此新的迭代器只需提供前两个参数即可（但在SGI STL中并没有使用继承机制）。这样在使用该迭代器的泛型算法中，可以返回这5种类型中的任意一种，而不需要依赖于 template 参数推导的机制。</p>

<p>在SGI STL中，如果启用 <code>__STL_CLASS_PARTIAL_SPECIALIZATION</code> 这个宏定义，还有这样一个标准的 <code>iterator_traits</code> ：<br/>
<code>
// In file stl_iterator_base.h
template &lt;class _Iterator&gt;
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type        value_type;
  typedef typename _Iterator::difference_type   difference_type;
  typedef typename _Iterator::pointer           pointer;
  typedef typename _Iterator::reference         reference;
};
</code>
值得一提的是，这些类型不仅可以是泛型算法的返回值类型，还可以是传入参数的类型。例如 <code>iterator_category</code> 可以作为迭代器的接口 <code>advance()</code> 和 <code>distance()</code>  的传入参数之一。 不同类型的迭代器实现同一算法的方式可能不同，可以通过这个参数类型来区分不同的重载函数。</p>

<h2>4. SGI 中的 __type_traits</h2>

<p>traits 编程技巧非常赞，适度弥补了 C++ template 本身的不足。 STL 只对迭代器加以规范，设计了 <code>iterator_traits</code> 这样的东西，SGI进一步将这种技法扩展到了迭代器之外，于是有了所谓的 <code>__type_traits</code>。</p>

<p>在SGI中， <code>__type_traits</code> 可以获取一些类型的特殊属性，如该类型是否具备 trivial default ctor？是否具备 trivial copy ctor？是否具备 trivial assignment operator？是否具备 tivial dtor？是否是 plain old data（POD）？ 如果答案是肯定的，那么我们对这些类型进行构造、析构、拷贝、赋值等操作时，就可以采用比较有效的方法，如不调用该类型的默认构造、析构函数，而是直接调用 <code>malloc()</code>, <code>free()</code>, <code>memcpy()</code> 等等，这对于大量而频繁的操作容器，效率有显著的提升。</p>

<p>SGI中 <code>__type_traits</code> 的特性的实现都在 <code>type_traits.h</code> 文件中。其中将 <code>bool</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code> 等基本的数据类型及其相应的指针类型的这些特性都定义为 <code>__true_type</code>，这以为着，这些对基本类型进行构造、析构、拷贝、赋值等操作时，都是使用系统函数进行的。而除了这些类型之外的其他类型，除非用户指定了它的这些特性为 <code>__true_type</code>，默认都是 <code>__false_type</code> 的，不能直接调用系统函数来进行内存配置或赋值等，而需要调用该类型的构造函数、拷贝构造函数等。</p>

<p>另外，用户在自定义类型时，究竟一个 class 什么时候应该是 <code>__false_type</code> 的呢？一个简单的判断标准是：如果 class 内部有指针成员并需要对其进行动态配置内存是，这个 class 就需要定义为 <code>__false_type</code>的，需要给该类型定义构造函数、拷贝构造函数、析构函数等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(1) 空间配置器(allocator)]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator/"/>
    <updated>2014-06-13T22:04:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator</id>
    <content type="html"><![CDATA[<p>在STL中，Memory Allocator 处于最底层的位置，为一切的 Container 提供存储服务，是一切其他组件的基石。对于一般使用 STL 的用户而言，Allocator 是不可见的，如果需要对 STL 进行扩展，如编写自定义的容器，就需要调用 Allocator 的内存分配函数进行空间配置。本文涉及到的 SGI STL 源代码文件有 <code>alloc.h</code>, <code>stl_config.h</code>, <code>stl_alloc.h</code>, <code>stl_threads.h</code> 这4个。</p>

<p>在C++中，一个对象的内存配置和释放一般都包含两个步骤，对于内存的配置，首先是调用operator new来配置内存，然后调用对象的类的构造函数进行初始化；而对于内存释放，首先是调用析构函数，然后调用 operator delete进行释放。 如以下代码：
<code>
class Foo { ... };
Foo* pf = new Foo;
...
delete pf;
</code>
Allocator 的作用相当于operator new 和operator delete的功能，只是它考虑得更加细致周全。SGI STL 中考虑到了内存分配失败的异常处理，内置轻量级内存池（主要用于处理小块内存的分配，应对内存碎片问题）实现， 多线程中的内存分配处理（主要是针对内存池的互斥访问）等，本文就主要分析 SGI STL 中在这三个方面是如何处理的。在介绍着三个方面之前，我们先来看看 Allocator的标准接口。</p>

<!-- more -->


<h2>1. Allocator 的标准接口</h2>

<p>在 SGI STL 中，Allocator的实现主要在文件<code>alloc.h</code> 和 <code>stl_alloc.h</code> 文件中。根据 STL 规范，Allocator 需提供如下的一些接口（见 <code>stl_alloc.h</code> 文件的第588行开始的class template allocator）：<br/>
```
// 标识数据类型的成员变量，关于中间的6个变量的涵义见后续文章（关于Traits编程技巧）
typedef alloc <em>Alloc;
typedef size_t     size_type;
typedef ptrdiff_t  difference_type;
typedef </em>Tp<em>       pointer;
typedef const _Tp</em> const_pointer;
typedef <em>Tp&amp;       reference;
typedef const </em>Tp&amp; const_reference;
typedef _Tp        value_type;
template <class _Tp1> struct rebind {</p>

<pre><code>typedef allocator&lt;_Tp1&gt; other;
</code></pre>

<p>}; // 一个嵌套的class template，仅包含一个成员变量 other
// 成员函数
allocator() <strong>STL_NOTHROW {}  // 默认构造函数，其中</strong>STL_NOTHROW 在 stl_config.h中定义，要么为空，要么为 throw()
allocator(const allocator&amp;) <strong>STL_NOTHROW {}  // 拷贝构造函数
template <class _Tp1> allocator(const allocator<_Tp1>&amp;) </strong>STL_NOTHROW {} // 泛化的拷贝构造函数
~allocator() <strong>STL_NOTHROW {} // 析构函数
pointer address(reference </strong>x) const { return &amp;<strong>x; } // 返回对象的地址
const_pointer address(const_reference </strong>x) const { return &amp;<strong>x; }  // 返回const对象的地址
_Tp* allocate(size_type </strong>n, const void* = 0) {</p>

<pre><code>return __n != 0 ? static_cast&lt;_Tp*&gt;(_Alloc::allocate(__n * sizeof(_Tp))) : 0; 
// 配置空间，如果申请的空间块数不为0，那么调用 _Alloc 也即 alloc 的 allocate 函数来分配内存，
</code></pre>

<p>} //这里的 alloc 在 SGI STL 中默认使用的是<strong>default_alloc_template&lt;</strong>NODE_ALLOCATOR_THREADS, 0>这个实现（见第402行）
void deallocate(pointer <strong>p, size_type </strong>n) { <em>Alloc::deallocate(<strong>p, </strong>n * sizeof(</em>Tp)); } // 释放空间
size_type max_size() const __STL_NOTHROW  // max_size() 函数，返回可成功配置的最大值</p>

<pre><code>{ return size_t(-1) / sizeof(_Tp); }  //这里没看懂，这里的size_t(-1)是什么意思？
</code></pre>

<p>void construct(pointer <strong>p, const _Tp&amp; </strong>val) { new(<strong>p) _Tp(</strong>val); } // 调用 new 来给新变量分配空间并赋值
void destroy(pointer <strong>p) { </strong>p->~<em>Tp(); } // 调用 </em>Tp 的析构函数来释放空间
<code>
在SGI STL中设计了如下几个空间分配的 class template：  
</code>
template <int __inst> class <strong>malloc_alloc_template // Malloc-based allocator.  Typically slower than default alloc
typedef </strong>malloc_alloc_template<0> malloc_alloc
template<class _Tp, class _Alloc> class simple_alloc
template <class _Alloc> class debug_alloc
template <bool threads, int inst> class <strong>default_alloc_template // Default node allocator.
typedef </strong>default_alloc_template&lt;<strong>NODE_ALLOCATOR_THREADS, 0> alloc
typedef </strong>default_alloc_template&lt;false, 0> single_client_alloc
template <class _Tp>class allocator
template&lt;>class allocator<void>
template <class _Tp, class _Alloc>struct <strong>allocator
template <class _Alloc>class </strong>allocator&lt;void, <em>Alloc>
<code>``
其中</code>simple_alloc<code>,</code>debug_alloc<code>,</code>allocator<code>和</code>__allocator<code> 的实现都比较简单，都是对其他适配器的一个简单封装（因为实际上还是调用其他配置器的方法，如</code></em>Alloc::allocate<code>）。而真正内容比较充实的是</code><strong>malloc_alloc_template<code>和</code></strong>default_alloc_template<code>这两个配置器，这两个配置器就是 SGI STL 配置器的精华所在。其中</code><strong>malloc_alloc_template<code>是SGI STL 的第一层配置器，只是对系统的</code>malloc<code>,</code>realloc<code>函数的一个简单封装，并考虑到了分配失败后的异常处理。而</code></strong>default_alloc_template` 是SGI STL 的第二层配置器，在第一层配置器的基础上还考虑了内存碎片的问题，通过内置一个轻量级的内存池。下文将先介绍第一级配置器的异常处理机制，然后介绍第二级配置器的内存池实现，及在多线程环境下内存池互斥访问的机制。</p>

<h2>2. SGI STL 内存分配失败的异常处理</h2>

<p>内存分配失败一般是由于out-of-memory(oom)，SGI STL 本身并不会去处理oom问题，而只是提供一个 private 的函数指针成员和一个 public 的设置该函数指针的方法，让用户来自定义异常处理逻辑：
```
private:</p>

<h1>ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG</h1>

<p>  static void (* __malloc_alloc_oom_handler)();  // 函数指针</p>

<h1>endif</h1>

<p>public:
  static void (<em> __set_malloc_handler(void (</em>__f)()))() // 设置函数指针的public方法
  {</p>

<pre><code>void (* __old)() = __malloc_alloc_oom_handler;
__malloc_alloc_oom_handler = __f;
return(__old);
</code></pre>

<p>  }
<code>
如果用户没有调用该方法来设置异常处理函数，那么就不做任何异常处理，仅仅是想标准错误流输出一句out of memory并退出程序（对于使用new和C++特性的情况而言，则是抛出一个`std::bad_alloc()`异常）， 因为该函数指针的缺省值为0，此时对应的异常处理是 `__THROW_BAD_ALLOC`：
</code>
// line 152 ~ 155</p>

<h1>ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG</h1>

<p>template <int __inst>
void (* <strong>malloc_alloc_template<__inst>::</strong>malloc_alloc_oom_handler)() = 0;</p>

<h1>endif</h1>

<p>// in <em>S_oom_malloc and </em>S_oom_realloc
<strong>my_malloc_handler = </strong>malloc_alloc_oom_handler;
if (0 == <strong>my_malloc_handler) { </strong>THROW_BAD_ALLOC; }
// in preprocess, line 41 ~ 50</p>

<h1>ifndef __THROW_BAD_ALLOC</h1>

<h1>if defined(<strong>STL_NO_BAD_ALLOC) || !defined(</strong>STL_USE_EXCEPTIONS)</h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>define __THROW_BAD_ALLOC fprintf(stderr, "out of memory\n"); exit(1)</h1>

<h1>else /<em> Standard conforming out-of-memory handling </em>/</h1>

<h1>include <new></h1>

<h1>define __THROW_BAD_ALLOC throw std::bad_alloc()</h1>

<h1>endif</h1>

<h1>endif</h1>

<p>```
SGI STL 内存配置失败的异常处理机制就是这样子了，提供一个默认的处理方法，也留有一个用户自定义处理异常的接口。</p>

<h2>3. SGI STL 内置轻量级内存池的实现</h2>

<p>第一级配置器 <code>__malloc_alloc_template</code> 仅仅只是对 <code>malloc</code> 的一层封装，没有考虑可能出现的内存碎片化问题。内存碎片化问题在大量申请小块内存是可能非常严重，最终导致碎片化的空闲内存无法充分利用。SGI 于是在第二级配置器 <code>__default_alloc_template</code> 中 内置了一个轻量级的内存池。 对于小内存块的申请，从内置的内存池中分配。然后维护一些空闲内存块的链表（简记为空闲链表，free list），小块内存使用完后都回收到空闲链表中，这样如果新来一个小内存块申请，如果对应的空闲链表不为空，就可以从空闲链表中分配空间给用户。具体而言SGI默认最大的小块内存大小为128bytes，并设置了128/8=16 个free list，每个list 分别维护大小为 8, 16, 24, ..., 128bytes 的空间内存块（均为8的整数倍），如果用户申请的空间大小不足8的倍数，则向上取整。</p>

<p>SGI STL内置内存池的实现请看 <code>__default_alloc_template</code> 中被定义为 private 的这些成员变量和方法（去掉了部分预处理代码和互斥处理的代码）：
```
private:</p>

<h1>if ! (defined(<strong>SUNPRO_CC) || defined(</strong>GNUC__))</h1>

<pre><code>enum {_ALIGN = 8}; // 对齐大小
enum {_MAX_BYTES = 128}; // 最大有内置内存池来分配的内存大小
enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN  // 空闲链表个数
</code></pre>

<h1>endif</h1>

<p>  static size_t  _S_round_up(size_t __bytes) // 不是8的倍数，向上取整</p>

<pre><code>{ return (((__bytes) + (size_t) _ALIGN-1) &amp; ~((size_t) _ALIGN - 1)); }
</code></pre>

<p><em>_PRIVATE:
  union </em>Obj { // 空闲链表的每个node的定义</p>

<pre><code>    union _Obj* _M_free_list_link;
    char _M_client_data[1];   };
</code></pre>

<p>  static <em>Obj* __STL_VOLATILE </em>S_free_list[]; // 空闲链表数组
  static size_t _S_freelist_index(size_t <strong>bytes) { // </strong>bytes 对应的free list的index</p>

<pre><code>    return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);
</code></pre>

<p>  }
  static void<em> _S_refill(size_t __n); // 从内存池中申请空间并构建free list，然后从free list中分配空间给用户
  static char</em> <em>S_chunk_alloc(size_t <strong>size, int&amp; </strong>nobjs); // 从内存池中分配空间
  static char* </em>S_start_free;  // 内存池空闲部分的起始地址
  static char* <em>S_end_free; // 内存池结束地址
  static size_t </em>S_heap_size; // 内存池堆大小，主要用于配置内存池的大小
<code>``
其中</code><em>S_refill<code>和</code></em>S_chunk_alloc<code>这两个函数是该内存池机制的核心。</code><em>_default_alloc_template<code>对外提供的 public 的接口有</code>allocate<code>,</code>deallocate<code>和</code>reallocate<code>这三个，其中涉及内存分配的</code>allocate<code>和</code>reallocate<code>的逻辑思路是，首先看申请的size（已round up）对应的free list是否为空，如果为空，则调用</code></em>S_refill<code>来分配，否则直接从对应的free list中分配。而</code>deallocate` 的逻辑是直接将空间插入到相应free list的最前面。</p>

<p>函数 <code>_S_refill</code> 的逻辑是，先调用 <code>_S_chunk_alloc</code> 从内存池中分配20块小内存（而不是用户申请的1块），将这20块中的第一块返回给用户，而将剩下的19块依次链接，构建一个free list。这样下次再申请同样大小的内存就不用再从内存池中取了。有了 <code>_S_refill</code> ，用户申请空间时，就不是直接从内存池中取了，而是从 free list 中取。因此 <code>allocate</code> 和 <code>reallocate</code> 在相应的free list为空时都只需直接调用 <code>_S_refill</code> 就行了。</p>

<p>这里默认是依次申请20块，但如果内存池空间不足以分配20块时，会尽量分配足够多的块，这些处理都在 <code>_S_chunk_alloc</code> 函数中。该函数的处理逻辑如下（源代码这里就不贴了）：</p>

<blockquote><p>1) 能够分配20块</p>

<blockquote><p>从内存池分配20块出来，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>2) 不足以分配20块，但至少能分配一块</p>

<blockquote><p>分配经量多的块数，改变 <code>_S_start_free</code> 的值，返回分配出来的内存的起始地址</p></blockquote>

<p>3) 一块也分配不了</p>

<blockquote><p>首先计算新内存池大小 <code>size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4)</code><br/>
将现在内存池中剩余空间插入到适当的free list中<br/>
调用 <code>malloc</code> 来获取一大片空间作为新的内存池：<br/>
-- 如果分配成功，则调整 <code>_S_end_free</code> 和 <code>_S_heap_size</code> 的值，并重新调用自身，从新的内存池中给用户分配空间；
-- 否则，分配失败，考虑从比当前申请的空间大的free list中分配空间，如果无法找不到这样的非空free list，则调用第一级配置器的allocate，看oom机制能否解决问题</p></blockquote></blockquote>

<p>SGI STL的轻量级内存池的实现就是酱紫了，其实并不复杂。</p>

<h2>4. SGI STL 内存池在多线程下的互斥访问</h2>

<p>最后，我们来看看SGI STL中如何处理多线程下对内存池互斥访问的（实际上是对相应的free list进行互斥访问，这里访问是只需要对free list进行修改的访问操作）。在SGI的第二级配置器中与内存池互斥访问相关的就是 <code>_Lock</code> 这个类了，它仅仅只包含一个构造函数和一个析构函数，但这两个函数足够了。在构造函数中对内存池加锁，在析构函数中对内存池解锁：
```
//// in __default_alloc_template</p>

<h1>ifdef __STL_THREADS</h1>

<pre><code>static _STL_mutex_lock _S_node_allocator_lock; // 互斥锁变量
</code></pre>

<h1>endif</h1>

<p>class _Lock {</p>

<pre><code>public:
    _Lock() { __NODE_ALLOCATOR_LOCK; }
    ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }
</code></pre>

<p>};
//// in preprocess</p>

<h1>ifdef __STL_THREADS</h1>

<h1>include &lt;stl_threads.h> // stl 的线程，只是对linux或windows线程的一个封装</h1>

<h1>define __NODE_ALLOCATOR_THREADS true</h1>

<h1>ifdef __STL_SGI_THREADS</h1>

<h1>define <strong>NODE_ALLOCATOR_LOCK if (threads &amp;&amp; </strong>us_rsthread_malloc) \</h1>

<pre><code>            { _S_node_allocator_lock._M_acquire_lock(); }  // 获取锁
</code></pre>

<h1>define <strong>NODE_ALLOCATOR_UNLOCK if (threads &amp;&amp; </strong>us_rsthread_malloc) \</h1>

<pre><code>            { _S_node_allocator_lock._M_release_lock(); }  // 释放锁
</code></pre>

<h1>else /<em> !__STL_SGI_THREADS </em>/</h1>

<h1>define __NODE_ALLOCATOR_LOCK \</h1>

<pre><code>    { if (threads) _S_node_allocator_lock._M_acquire_lock(); }
</code></pre>

<h1>define __NODE_ALLOCATOR_UNLOCK \</h1>

<pre><code>    { if (threads) _S_node_allocator_lock._M_release_lock(); }
</code></pre>

<h1>endif</h1>

<h1>else /<em> !__STL_THREADS </em>/</h1>

<h1>define __NODE_ALLOCATOR_LOCK</h1>

<h1>define __NODE_ALLOCATOR_UNLOCK</h1>

<h1>define __NODE_ALLOCATOR_THREADS false</h1>

<h1>endif</h1>

<p>```</p>

<p>由于在 <code>__default_alloc_template</code> 的对外接口中，只有 <code>allocate</code> 和 <code>deallocate</code> 中直接涉及到对free list进行修改的操作，所以在这两个函数中，在对free list进行修改之前，都要实例化一个 <code>_Lock</code> 的对象 <code>__lock_instance</code> ，此时调用构造函数进行加锁，当函数结束时，的对象 <code>__lock_instance</code> 自动析构，释放锁。这样，在多线程下，可以保证free list的一致性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(0) STL简介]]></title>
    <link href="http://ibillxia.github.io/blog/2014/06/08/stl-source-insight-0-stl-overview/"/>
    <updated>2014-06-08T21:39:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/06/08/stl-source-insight-0-stl-overview</id>
    <content type="html"><![CDATA[<h2>0. 两个问题</h2>

<p>在介绍 STL 之前，先讨论两个问题：为什么要剖析 STL 源代码？如何剖析 STL 源代码？</p>

<p>首先是为什么要剖析 STL 源代码呢？ 有人会说，会使用 STL 不就性了，为什么一定要知道其内部的机制呢？ 对于大多数程序猿来说，确实没有必要去阅读或分析 STL 的源代码，但如果要想提升自己的编程修养，要相让自己编码的思想境界提升一个档次，还是很有必要读读 STL 这样的大师制作。阅读和分析之后，你会明白STL是如何分配和管理内存的（特别是对vector、string、deque等动态数据结构），是如何实现各种数据结构（特别是红黑树等比较复杂的数据结构）和相关算法的，又是如何将这些组件融合起来实现高内聚低耦合的。或许用《洋葱》的几句歌词获取最能表达你的明白这些问题之后的心情：</p>

<blockquote><p>如果你愿意一层一层<br/>
一层的剥开我的心<br/>
你会发现<br/>
你会讶异<br/>
你是我<br/>
最压抑<br/>
最深处的秘密</p>

<p>如果你愿意一层一层<br/>
一层的剥开我的心<br/>
你会鼻酸<br/>
你会流泪<br/>
只要你能<br/>
听到我<br/>
看到我的全心全意</p></blockquote>

<p>那么，如何剖析源代码呢？其实歌词中已经蕴含这答案了，那就是“一层一层一层的剥开”。当然，我这里说的一层一层不是说要一个函数step in 到底，而是说要按层次解读：首先从最外层结构框架着手，从整体上把握；然后从细处着笔，一个组件一个组件的来分析；在分析每个组件时，也是先把握改组件的全貌及其与其他组件的关联关系，然后在深入组件内部，了解其实现。在阅读和分析源码的过程中，首先要理解其功能，然后在看它是如何实现的。切忌纠缠于代码的细节或陷入源码而不能自拔，即坠入“不识庐山真面目，只缘身在此山中”的深渊！</p>

<p>因此，本文的目的在于，站在STL这座大山的山顶，一窥其全貌。随后的文章则深入每个组件，细细观赏每一处的风景。</p>

<!-- more -->


<h2>1. STL 简史</h2>

<p>声明：这里的内容主要来自<a href="http://zh.wikipedia.org/">Wiki中文网</a>，这里尽量简化其描述，虽然是尽量剪裁，但可能还是有些罗嗦，而且大段copy，掩面 ~(@&and;-&and;@)~</p>

<p>STL 是 Standard Template Library（标准模板库）的缩写。Standard 是指STL是C++标准程序库的一部分，Template是指STL是一套模板，这也是STL最本质的特征。标准模板库使得C++编程语言在有了同Java一样强大的类库的同时，保有了更大的可扩展性。</p>

<p>标准模板库系由 <a href="http://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a> 创造于1979年前后，这也正是 <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a> 创造C++的年代（非常巧的是，这两为大师都出生于1950年）。</p>

<p>Stepanov早期从事教育工作，在20世纪70年代就开始研究泛型程序设计了。1983年，Stepanov先生转至Polytechnic大学教书，继续研究泛型程序设计，同时写了许多Scheme的程序，应用在graph与network的算法上。1985年又转至GE公司专门教授高级程序设计，并将graph与network的Scheme程序，改用Ada写，用了Ada以后，他发现到一个动态（dynamically）类型的程序（如Scheme）与强制（strongly）类型的程序（如Ada）有多么的不同。在动态类型的程序中，所有类型都可以自由的转换成别的类型，而强制类型的程序却不能。但是，强制类型在出错时较容易发现程序错误。</p>

<p>1988年Stepanov先生转至HP公司运行开发泛型程序库的工作。此时，他已经认识C语言中指针(pointer)的威力，他表示一个程序员只要有些许硬件知识，就很容易接受C语言中指针的观念，同时也了解到C语言的所有数据结构均可以指针间接表示，这点是C与Ada、Scheme的最大不同。Stepanov认为，虽然C++中的继承功能可以表示泛型设计，但终究有个限制。虽然可以在基础类型（superclass）定义算法和接口，但不可能要求所有对象皆是继承这些，而且庞大的继承体系将降低虚拟（virtual）函数的运行效率，这便违反了所谓的“效率”原则。</p>

<p>在C++标准及C++模板概念的标准化过程中，Stepanov参加了许多有关的研讨会，并与C++之父Bjarne讨论模板的设计细节。Stepanov认为C++的函数模板（function template）应该像Ada一样，在声明其函数原型后，应该显式的声明一个函数模板之实例（instance）；Bjarne则不然，他认为可以通过C++的重载（overloading）功能来表达。几经争辩，Stepanov发现Bjarne是对的。</p>

<p>事实上，C++的模板，本身即是一套复杂的宏语言（macro language），宏语言最大的特色为：所有工作在编译时期就已完成。显式的声明函数模板之实例，与直接通过C++的重载功能隐式声明，结果一样，并无很大区别，只是前者加重程序员的负担，使得程序变得累赘。</p>

<p>1992年Meng Lee加入Alex的项目，成为另一位主要贡献者。1992年，HP泛型程序库计划退出，小组解散，只剩下Stepanov先生与Meng Lee小姐（她是东方人，标准模板库的英文名称其实是取STepanov与Lee而来），Lee先前研究的是编译器的制作，对C++的模板很熟，第一版的标准模板库中许多程序都是Lee的杰作。</p>

<p>1993年，Andy Koenig到斯坦福演讲，Stepanov便向他介绍标准模板库，Koenig听后，随即邀请Stepanov参加1993年11月的ANSI/ISO C++标准化会议，并发表演讲。Bell实验室的Andrew Koenig于1993年知道标准模板库研究计划后，邀请Alex于是年11月的ANSI/ISO C++标准委员会会议上展示其观念。并获得与会者热烈的回应。</p>

<p>1994年1月6日，Koenig寄封电子邮件给Stepanov，表示如果Stepanov愿意将标准模板库的说明文件撰写齐全，在1月25日前提出，便可能成为标准C++的一部份。</p>

<p>Alex于是在次年夏天在Waterloo举行的会议前完成其正式的提案，并以百分之八十压倒性多数，一举让这个巨大的计划成为C++ Standard的一部份。</p>

<p>标准模板库于1994年2月年正式成为ANSI/ISO C++的一部份，它的出现，促使C++程序员的思维方式更朝向泛型编程（generic program）发展。</p>

<p>目前，常见的STL实现版本有HP(Hewlett-Packard Company) STL，P.J Plauger版，Rouge Wave版，STLport版，SGI(Silicon Graphics Computer System .Inc) STL版等。</p>

<h2>2. STL 六大组件</h2>

<p>STL的官方文档将STL划分成了五个主要部分，分别是Containers（容器）、Iterators（迭代器）、Algorithms（算法）、函数对象（Function Objects）、空间分配（Memory Allocation）。而在侯姐的《STL源码剖析》中，还有一个组成部分是Adaptors（适配器）。本文也按照侯姐的规范将STL分为六个部分，而且介绍的顺序也按照他的书中的顺序来介绍。（PS：这里只是简要介绍六大组件的主要功能，真的很简要哦）</p>

<h4>2.1 Memory Allocation</h4>

<p>负责空间配置与管理，本质是实现动态空间配置、空间管理、空间释放的一系列class template。它是容器的底层接口，实际使用STL的用户是看不到Allocation的。</p>

<h4>2.2 Iterators</h4>

<p>迭代器扮演容器与算法之间的胶合剂，可以形象的理解为“泛型指针”。从实现的角度看，迭代器是一种将operator*、operator->、operator++、operator--等指针相关操作进行重载的class template。所有的STL容器都有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素，原生指针（Native pointer）也是一迭代器。</p>

<h4>2.3 Containers</h4>

<p>容器可以理解为各种数据结构，如vector、list、deque、set、map等用来存放特定结构的数据的容器，也是一系列的class template。对于普通用户而言，容器是最熟悉不过了，我们最经常使用的容器主要有 vector, queue, stack, deque, map。相信很多人对 STL 的接触是从使用容器开始的，也有很多人对 STL 印象最深刻的就是容器了。</p>

<h4>2.4 Algorithm</h4>

<p>主要是各种常用的算法，如sort、search、copy、erase、unique等。从实现的角度看，STL算法是一种function template。其中 sort 相信很多人并不陌生，在很多算法中我们都需要对数据进行排序。</p>

<h4>2.5 Function Objects</h4>

<p>函数对象的行为类似函数，但可作为算法的某种策略（policy）。从实现的角度看，函数对象是一种重载了operator()（函数调用操作符）的class或class template。</p>

<h4>2.6 Adaptors</h4>

<p>适配器是一种用来修饰容器或函数对象或迭代器的东西。例如，STL 提供queue和stack，虽然他们看似容器，但其实只能算是一种容器适配器，因为他们的底层实现完全借助于deque，所有的操作都由底层deque提供。改变functor/container/iterator的接口者称为functor/container/iterator adaptor。</p>

<h2>3. STL 各组件间的关系</h2>

<p>STL 六大组件间的关系如下图（来自侯姐《STL源码剖析》一书 p6）：<br/>
{% img /images/2014/IMAG2014060801.jpg %}
其中 Container 通过 Allocator 取得数据存储空间，Alogrithm 通过 Iterator 存取 Container 内容，Functor 可以协助 Algorithm 完成不同的策略变化，Adapter 可以修饰或套接 Functor。这里的描述有些抽象，等详细了解了每个组件的功能职责后，就比较好懂了。</p>

<h2>4. SGI STL源码结构</h2>

<p>最后，这里简单介绍一下SGI STL 源码的结构。我下载的是<a href="https://www.sgi.com/tech/stl/download.html">SGI-STL-v3.3</a>， 它是基于1994年HP版STL改造而成的，最新版本v3.3的更新时间是2000年6月8日，共91个文件（SGI-STL官网文档中只列出了90个文件，少列了<code>vector.h</code>这个文件），1.1M大小（其实总代码量并不是很大，非常轻量级 (*&and;-&and;*) ，比较适合拿来彻底分析一遍 ）。</p>

<p>在这91个文件中，有<strong>37个</strong>以 <code>stl_</code> 开头的文件，这些都是STL内部实现文件。有<strong>23个</strong>无扩展名的文件，这些都是STL对外提供的标准接口。 有<strong>11个</strong>与无扩展名文件同名的.h文件，这是对应的old-style形式的头文件（至于为什么不是每个无扩展名（new-style）头文件都有对应的 <code>.h</code> 文件，我也不太清楚）。 还有<strong>20个</strong>文件，主要是为 <code>stl_</code> 开头的文件提供比较 common 的功能，如 <code>algobase.h</code>、<code>hashtable.h</code> 等，或者是对 <code>stl_</code> 开头的文件进行一次内部封装，还有其他一些杂项功能等。</p>

<h2>5. 参考及推荐</h2>

<h3>推荐阅读</h3>

<p>介绍STL模板的书，有两本比较经典：<br/>
一本是《Generic Programming and the STL》，中文翻译为《泛型编程与STL模板》，这本书由STL开发者 Matthew H.Austern编著，由STL之父Alexander Stepanov等大师审核的，介绍STL思想及其使用技巧，适合初学者使用。<br/>
另一本书是《STL源码剖析》，是《深入浅出MFC》的作者侯捷编写的，介绍STL源代码的实现，适合深入学习STL，不适合初学者。</p>

<h3>源码阅读与分析工具</h3>

<p>能在Linux下用熟练使用vim最好了，实在不行用 Code::Blocks 也挺不错的，可以查找函数原型、定义、调用等。在Windows下用Source Insight最好了，可惜不是免费的，但同样也可以用Code::Blocks 或 Visual C++ Express 等 IDE。<br/>
原本想用一个UML建模工具来分析一下STL中的类之间的关系的，但是看了看源代码，基本没有太多的继承之类的关系，而且很多UML工具对C++源码自动生成类图的功能支持得并不好，就放弃了。</p>

<h3>参考</h3>

<p>[1] <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">Wiki: Standard Template Library</a> <br/>
[2] <a href="http://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93">Wiki: 标准模板库</a> <br/>
[3] <a href="https://www.sgi.com/tech/stl/">Standard Template Library Programmer's Guide</a> <br/>
[4] <a href="http://www.cnblogs.com/todototry/archive/2009/06/21/1507760.html">如何看懂源代码--(分析源代码方法)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言函数指针与C++函数调用操作符]]></title>
    <link href="http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp/"/>
    <updated>2014-05-24T21:27:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/05/24/function-pointer-in-c-and-function-call-operator-in-cpp</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在编程过程中，一些特殊的时候，我们需要向一个函数传递另一个函数的地址（比如在快速排序中，我们需要传入两个元素大小比较的函数的地址），此时在C语言中一般是通过传递一个函数指针来实现。最近在看《STL源码剖析》一书，上面提到，在C++中其实可以通过另一种方式实现，那就是函数调用操作符<code>()</code> 。本文首先介绍一下C语言中函数指针的用法，然后再介绍C++中函数调用操作符的用法。</p>

<h2>C语言中的函数指针</h2>

<p>我们先直接看一个例子吧。这个例子比较全面而且简单，其中的函数指针是带参数且有返回值的函数指针，而且还有把函数指针作为参数来传递的代码。这个例子来自 <a href="http://blog.jobbole.com/44639/">jobbole伯乐在线</a>，代码如下：</p>

<!-- more -->


<p>```</p>

<h1>include &lt;stdio.h></h1>

<p>// 函数原型
int add(int x, int y);
int subtract(int x, int y);
int domath(int (*mathop)(int, int), int x, int y);</p>

<p>// 加法 x+ y
int add(int x, init y) {</p>

<pre><code>return x + y;
</code></pre>

<p>}</p>

<p>// 减法 x - y
int subtract(int x, int y) {</p>

<pre><code>return x - y;
</code></pre>

<p>}</p>

<p>// 根据输入执行函数指针
int domath(int (*mathop)(int, int), int x, int y) {</p>

<pre><code>return (*mathop)(x, y);
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>// 用加法调用domath
int a = domath(add, 10, 2);
printf("Add gives: %d\n", a);

// 用减法调用domath
int b = domath(subtract, 10, 2);
printf("Subtract gives: %d\n", b);
</code></pre>

<p>}
```</p>

<p>在函数 <code>domath</code> 中，我们可以根据传入的 <code>mathop</code> 函数指针来做不同的计算操作。另外，在该文中，最后提到函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名，解引用符 <code>*</code> 和取地址符 <code>&amp;</code> 用在函数名之前基本上都是多余的。这个之前还真不知道，新技能get，哈哈</p>

<h4>使用typedef</h4>

<p>在C语言中，对于函数指针，我们可以使用 <code>typedef</code> 将其定义为一种数据类型，这样我们就可以定义这种类型的变量了，就像使用普通的变量类型一样。下面是一个具体的定义（来自<a href="http://stackoverflow.com/questions/4295432/typedef-function-pointer">stackoverflow</a>）：</p>

<blockquote><p>typedef   void      (*FunctionFunc)  ( );
//         ^                ^         ^
//     return type      type name  arguments</p></blockquote>

<p>这里 <code>typedef</code> 的使用方法与一般的 <code>typedef A B</code> 的使用方式不不大一样的，如果没有接触过这种用法，可能开起来很别扭（在很多开源库中可能经常会碰到）。下面是其具体使用的实例（不完整代码）：</p>

<p><code>
FunctionFunc x;
void doSomething() { printf("Hello there\n"); }
x = &amp;doSomething;
x(); //prints "Hello there"
</code></p>

<p>根据上面提到的隐式转换，这里的取址符其实是没有必要的。关于C语言的函数指针就介绍到这儿了，接下来介绍一下C++的函数调用操作符。</p>

<h2>C++中的函数调用操作符</h2>

<p>在C++中，函数调用操作符是指左右小括弧 <code>()</code> ，该操作符是可以重载的。许多 STL 算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时按照使用者自定义的大小关系进行排序）。 上面讲了，在C语言中使用者是通过传递函数指针的方式来实现的。然而，函数指针有一些缺点，最重要的是它无法持有自己的状态（这里指局部状态，local states，具体可以通过后面的例子来理解），也无法达到组件技术中的可适配性 —— 也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>

<p>在C++中，对应于C中函数指针的东西是仿函数（functor），使用起来就像函数一样。其实现方法是对某个 class 进行 <code>operator()</code> 重载，他就成为一个仿函数。而要成为一个可适配（adaptable）的仿函数，还需要其他的一些努力（在《STL源码剖析》一书的第8章，关于适配器（adaptor）的内容）。这里，我们只拿书中的那个例子来简单的看一下仿函数的定义和使用方法吧。代码如下：</p>

<p>```</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>// 对plus进行operator() 重载，使得 plus 变成了一个仿函数
template<class T>
struct plus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x+y;}
</code></pre>

<p>};</p>

<p>// 对 minus 进行operator() 重载，使得 minus 变成了一个仿函数
template<class T>
struct minus{</p>

<pre><code>T operator() (const T &amp;x, const T &amp;y) const {return x-y;}
</code></pre>

<p>};</p>

<p>int main(){</p>

<pre><code>// 以下产生仿函数对象
plus&lt;int&gt; plusObj;
minus&lt;int&gt; minusObj;
// 以下使用仿函数，就像使用一般函数一样
cout&lt;&lt;plusObj(3,5)&lt;&lt;endl;
cout&lt;&lt;minusObj(3,5)&lt;&lt;endl;
// 也可以这样使用，通过临时对象（匿名对象）
cout&lt;&lt;plus&lt;int&gt;()(3,5)&lt;&lt;endl;
cout&lt;&lt;minus&lt;int&gt;()(3,5)&lt;&lt;endl;
return 0;
</code></pre>

<p>}
```</p>

<p>这里的 <code>plus&lt;T&gt;</code> 和 <code>minus&lt;T&gt;</code> 已经非常接近 STL 的实现了，唯一的差别是它缺乏“可适配能力”，关于 STL 中的适配器（adaptor），我现在也还没看完该书，也还不太了解，在后续文章中应该会介绍到。读者可以自行google。</p>

<h2>在快排中使用函数调用操作符</h2>

<p>为了加深对函数调用操作符的理解，并将其真正用到实际中，这里拿快排这个非常典型的例子，并充分利用C++及STL的特性。下面是核心代码：</p>

<p>```
template<typename InIt,typename FuncType>
void myqsort(InIt begin, InIt end, FuncType cmp){</p>

<pre><code>if(begin==end||begin==end-1)return;
InIt it = mysplit(begin,end,cmp);
if(it!=end){
    myqsort(begin,it,cmp);
    myqsort(it+1,end,cmp);
}
</code></pre>

<p>}</p>

<p>template<typename InIt,typename FuncType>
InIt mysplit(InIt begin, InIt end, FuncType cmp){</p>

<pre><code>InIt itl,itr;
itl=begin;
itr=end-1;
while(itl != itr){
    while(itl != itr &amp;&amp; cmp(*itr,*begin)&gt;0)itr--;
    if(itl==itr)break;
    while(itl != itr &amp;&amp; cmp(*begin,*itl)&gt;0)itl++;
    if(itl==itr)break;
    swap(*itl,*itr);
    itr--;
}
return itl;
</code></pre>

<p>}</p>

<p>class Test{
public:</p>

<pre><code>double m_lf;
string m_str;
</code></pre>

<p>public:</p>

<pre><code>void set(){
    cin&gt;&gt;m_lf;
    cin&gt;&gt;m_str;
}

void print(){
    cout&lt;&lt;m_lf&lt;&lt;" ";
    cout&lt;&lt;m_str&lt;&lt;endl;
}
</code></pre>

<p>};</p>

<p>struct cmpd{</p>

<pre><code>int operator()(Test a,Test b){
    if(abs(a.m_lf - b.m_lf)&lt;INF)return 0;
    if(a.m_lf &gt; b.m_lf)return 1;
    return -1;
}
</code></pre>

<p>};</p>

<p>struct cmps{</p>

<pre><code>int operator()(Test a,Test b){
    return a.m_str.compare(b.m_str);
}
</code></pre>

<p>};
```</p>

<p>完整的代码及测试输入可以通过以下链接打包下载：<a href="https://ibillxia.github.io/upload/code/20140525.tar.gz">code-2014-05-25</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全排列及某排列的后继的求解及其STL实现的分析]]></title>
    <link href="http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation/"/>
    <updated>2014-04-24T23:24:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/04/24/next-permutation-and-analysis-of-its-stl-implementation</id>
    <content type="html"><![CDATA[<p>在Leetcode上有好几道全排列相关的题，一直以来只是会写基于递归的全排列生成算法，遇到这几道题后，搜了下一些非递归的实现方法，发现其实全排列的生成还是很有规律的有木有！这里就总结一下递归和非递归的全排列生成方法，并分析一下 STL 的实现。</p>

<p>递归和非递归实现全排列生成的方法也分别有多种，递归法有基于交换的，有基于链接的，还有回溯，非递归法有排序、回溯、求模等，关于所有这些方法的具体实现参见 <a href="http://mengliao.blog.51cto.com/876134/824079">全排列的六种算法</a>. 本文只实现一种递归和一种非递归算法，并在最后对 STL 的非递归算法进行分析。</p>

<p>本文的全部代码下载：<a href="http://ibillxia.github.io/upload/code/20140424.cpp">code</a>.</p>

<h2>递归法求全排列</h2>

<p>递归法的基本思路是这样的：</p>

<blockquote><p>首先选一个元素排在第一个（有 n 中选法）；
然后递归的对剩下的所有元素进行全排列；
直到一个元素的全排列是其本身。</p></blockquote>

<p>假设给定的元素序列为 &lt;e1, e2, ..., en>，其全排列表示为 P(e1, e2, ..., en)，则对递归的第一步展开有：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e2, P(e1, e3, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<!-- more -->


<p> 一个简单的实现如下：</p>

<p>```
void recursive_permute(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>这个实现非常精简易懂，但却存在一个问题，那就是当数组 A 中存在重复元素时，得到的排列是有重复的，这是因为在第8行的循环中，可能会选取重复的 A[j] 值。 为了去掉重复排列，我们可以在选取第 i 个数 A[j] 之前（即交换 A[i] 和 A[j] 之前），判断值为 A[j] 的元素是否选取过，即要判断在 A[i] 到 A[j-1] 中是否存在与 A[j] 相等的元素，如果出现过，说明 A[i] 选 A[j] 这个排列已经生成过了，可以直接跳过当前的 A[j] 看看是否可以选取 A[j+1] 作为 A[i] 了。比如上面的 e1 = e2，那么无重复的全排列应该是：</p>

<blockquote><p>P(e1, e2, ..., en) = {
&lt;e1, P(e2, e3, ..., en)>,
&lt;e3, P(e1, e2, e4, ..., en)>,
... ...
&lt;en, P(e1, e2, ..., e(n-1))> }</p></blockquote>

<p>添加这个限制的递归实现代码如下：</p>

<p>```
void recursive_permute2(int A[],int i,int n){</p>

<pre><code>if(i==n-1){
    for(int j=0;j&lt;n;j++)
        cout&lt;&lt;A[j]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return;
}
for(int j=i;j&lt;n;j++){
    int k;
    for(k=i;k&lt;j;k++)if(A[k]==A[j])break; // A[j] already used
    if(k&lt;j)continue;
    swap(A[i],A[j]);  // choose A[j] as the ith element
    recursive_permute2(A,i+1,n);
    swap(A[i],A[j]);  // reset to enter next for
}
</code></pre>

<p>}
```</p>

<p>至此，递归法实现全排列的求解就总结到这儿了，下面来看看非递归怎么实现。</p>

<h2>非递归法求全排列</h2>

<p>非递归法求全排列的一种最常用算法是基于字典序的全排列生成算法，其基本思路为，先解决生成一个序列在字典序下的下一个排列这个问题，然后利用这个来一次求解每一个排列。其中求解给定序列在字典序下的下一个排列序列的基本思想如下：</p>

<blockquote><ol>
<li>对于给定序列 &lt;e1, e2, ..., en> 从右往左找到第一个非递增点，设下标为 i；</li>
<li>从右往左查找第一个比 e[i] 大的数，设其下标为 j;</li>
<li>交换 e[i] 和 e[j] 的值；</li>
<li>将序列 e[i+1..n] 逆置。</li>
</ol>
</blockquote>

<p>举个例子，如下图（修改自 <a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html">Next Permutation 解题报告</a> ）所示：</p>

<center>{% img /images/2014/IMAG2014042401.png %}</center>


<p>上面的说明已经很接近伪代码了，具体实现如下：</p>

<p>```
bool next_permute(int A[],int n){</p>

<pre><code>int i,j;
// step .1
if(n&lt;2)return false;
for(i=n-2;i&gt;=0;i--){
    if(A[i]&lt;A[i+1])break;
}
if(i&lt;0)return false; // A[0] is maximum, no next permute for it
// step .2
for(j=n-1;j&gt;i;j--){
    if(A[j]&gt;A[i])break;
}
// step .3
swap(A[i],A[j]);
// step .4
while(++i &lt; --n){
    swap(A[i],A[n]);
}
return true;
</code></pre>

<p>}
```</p>

<p>这里将其返回值定义为 bool 类型，可以方便后面求解全排列时调用：</p>

<p>```
void non_recursive_permute(int A[],int n){</p>

<pre><code>sort(A,A+n);
int i;
do{
    for(i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
}while(next_permute(A,n));
</code></pre>

<p>}
```</p>

<p>上面这个函数即实现了按字典序生成全排列的功能，而且对于输入含有重复值的情况，不会生成重复的排列。对于非递归实现，很容易分析其时间复杂度，next_permute 的时间复杂度为 O(n)，而 non_recursive_permute 的时间复杂度为 O(n*n!)。</p>

<h2>STL 中 next permute 的实现</h2>

<p>下面来分析一下 STL 中是如何实现 next permute 的，在 stl_algo.h 中我们可以找到 next_permutation 的实现，基本思路也是按照上面的四步走来实现的，具体见如下代码及注释：</p>

<p>```
/<em>*
 *  @brief  Permute range into the next @a dictionary ordering.
 *  @ingroup sorting_algorithms
 *  @param  first  Start of range.
 *  @param  last   End of range.
 *  @return  False if wrapped to first permutation, true otherwise.
 *
 *  Treats all permutations of the range as a set of @a dictionary sorted
 *  sequences.  Permutes the current sequence into the next one of this set.
 *  Returns true if there are more sequences to generate.  If the sequence
 *  is the largest of the set, the smallest is generated and false returned.
</em>/
template<typename _BidirectionalIterator>
bool
next_permutation(_BidirectionalIterator __first,</p>

<pre><code>             _BidirectionalIterator __last)
</code></pre>

<p>{</p>

<pre><code>// concept requirements
__glibcxx_function_requires(_BidirectionalIteratorConcept&lt;
                            _BidirectionalIterator&gt;)
__glibcxx_function_requires(_LessThanComparableConcept&lt;
                            typename iterator_traits&lt;_BidirectionalIterator&gt;::value_type&gt;)
__glibcxx_requires_valid_range(__first, __last);

if (__first == __last)  // 容器中没有元素，没有 next permute
    return false;
_BidirectionalIterator __i = __first;
++__i;
if (__i == __last)  // 容器中只有一个元素，同没有
    return false;
__i = __last;
--__i;  // 将 __i 指向最后一个元素

for(;;) {
    _BidirectionalIterator __ii = __i;  
    --__i;
    if (*__i &lt; *__ii) {  // step .1, 这里的 __i 就相当于上面step 1中的i
        _BidirectionalIterator __j = __last;
        while (!(*__i &lt; *--__j)) {  // step .2, 这里的 __j 就相当上面 step 2中的j
        }
        std::iter_swap(__i, __j);  // step .3 交换
        std::reverse(__ii, __last);  // step .4 逆置
        return true;
    }
    if (__i == __first) {  // 直到 __i = __first 还是没有 *__i &lt; *__ii ，说明序列是递减排列的
        std::reverse(__first, __last); // 本应该没有下一个排列，但这里将字典序中第一个排列作为最后一个排列的 next permute
        return false; // 这里返回 false 而不是 true
    }
}
</code></pre>

<p>}
```</p>

<p>这里是用双向迭代器对容器中的元素进行操作的，一个调用的实例如下：</p>

<p>```
vector&lt;vector<int> > permute(vector<int> &amp;num) {</p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; ans;
sort(num.begin(),num.end());
do{
    ans.push_back(num);
}while(next_permutation(num.begin(),num.end()));
return ans;
</code></pre>

<p>}
```</p>

<p>可以看到，其实 STL 的 next permute 的实现跟我们的非递归算法是一致的。但这里有两个问题：一是，这里看似有二重循环（在 for 中套 while ），但实际上复杂度是 n+n =》 O(n) 的（可以为什么要写成这种二重循环的形式捏？不解）；二是，我们可以看到在 for 循环中，对 __ii 这个变量进行了多次声明，为什么不将其声明放在 for 外面捏？（虽然待排列的元素数 n 不会很大，但这样多次声明一个迭代器变量，虽不会占用过多内存，但在声明时调用构造函数和析构函数也是有一定的时间开销的吧，虽然相对于求全排列的复杂度 O(n*n!) 几乎可以忽略不计）</p>
]]></content>
  </entry>
  
</feed>