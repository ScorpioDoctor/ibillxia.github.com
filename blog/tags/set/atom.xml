<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: set | Bill's Blog]]></title>
  <link href="http://ibillxia.github.io/blog/tags/set/atom.xml" rel="self"/>
  <link href="http://ibillxia.github.io/"/>
  <updated>2014-10-26T22:27:09+08:00</updated>
  <id>http://ibillxia.github.io/</id>
  <author>
    <name><![CDATA[Bill Xia]]></name>
    <email><![CDATA[ibillxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解STL源码(4.2) 关联式容器之set和multiset]]></title>
    <link href="http://ibillxia.github.io/blog/2014/08/17/insight-into-stl-4-associative-containers-2-set-and-multiset/"/>
    <updated>2014-08-17T21:30:00+08:00</updated>
    <id>http://ibillxia.github.io/blog/2014/08/17/insight-into-stl-4-associative-containers-2-set-and-multiset</id>
    <content type="html"><![CDATA[<p>本文涉及到 SGI STL 源码的文件主要有 <code>stl_set.h</code>、 <code>stl_multiset.h</code>、 <code>set.h</code>、 <code>multiset.h</code>、 <code>set</code> 等文件。</p>

<h2>1. set 简介</h2>

<p>set 即集合，相比于其他容器有些特别。首先是它的每个元素是唯一的，即不允许有相同的值出现。其次，作为一种关联容器，set 的元素不像 map 那样可以同时拥有实值（value）和键值（key），set 元素的键值就是实值，实值就是键值。<br/>
由于 set 的实质和键值相同，共用同一个内存空间，而 set 的底层容器为红黑树（中序遍历有序），因此不能对其键值进行修改，否则会破坏其有序特性。为避免非法修改操作，在SGI STL的实现中，<code>set&lt;T&gt;::iterator</code> 被定义为 RB-tree 底层的 const_iterator，_杜绝写入操作。set 与 list 有一个相似的地方是，元素插入、删除后，之前的迭代器依然有效（被删除的那个元素的迭代器除外）。<br/>
我们知道集合有一些特殊的操作，诸如并、交、差等，在STL的 set 中，默认也提供了这些操作，如交集 <code>set_intersection</code> 、联集 <code>set_union</code> 、差集 <code>set_difference</code> 和对称差集 <code>set_symmetric_difference</code> 等。与之前那些线性容器不同的是，这些 set 的操作并不是在 set 内部实现的，而是放在了算法模块（algorithm）中，其具体实现在后面的算法章节中会具体介绍。</p>

<h2>2. set 的实现</h2>

<p>前面多次提到 set 的底层采用 RB-tree 容器，这是因为 RB-tree 是一种比较高效的平衡二叉搜索树，能够很好的满足元素值唯一的条件，而且查找效率高。由于 RB-tree 已实现了很多操作，因此 set 基本上只是对 RB-tree 进行了一层简单的封装。下面是其实现的主要代码：</p>

<!-- more -->


<p>```
template <class _Key, class _Compare, class _Alloc>
class set {
public:
  typedef <em>Key     key_type;
  typedef </em>Key     value_type; // 实值与键值同类型
private:
  typedef <em>Rb_tree&lt;key_type, value_type, </em>Identity<value_type>, key_compare, <em>Alloc> </em>Rep_type;
  <em>Rep_type </em>M_t;  // 底层使用红黑树作为容器
  set() : <em>M_t(</em>Compare(), allocator_type()) {} // 默认构造函数
  set(const set&lt;<em>Key,</em>Compare,<em>Alloc>&amp; __x) : </em>M_t(<strong>x._M_t) {}  // 拷贝构造函数
  pair&lt;iterator,bool> insert(const value_type&amp; </strong>x) { // 插入操作</p>

<pre><code>pair&lt;typename _Rep_type::iterator, bool&gt; __p = _M_t.insert_unique(__x); 
return pair&lt;iterator, bool&gt;(__p.first, __p.second);
</code></pre>

<p>  }
  void erase(iterator __position) { // 删除操作</p>

<pre><code>typedef typename _Rep_type::iterator _Rep_iterator;
_M_t.erase((_Rep_iterator&amp;)__position); 
</code></pre>

<p>  }
  void clear() { <em>M_t.clear(); } // 清空操作
  iterator find(const key_type&amp; __x) const { return </em>M_t.find(<strong>x); } // 查找
  size_type count(const key_type&amp; </strong>x) const { // 计数</p>

<pre><code>return _M_t.find(__x) == _M_t.end() ? 0 : 1;
</code></pre>

<p>  }
};
template <class _Key, class _Compare, class _Alloc>
inline bool operator==(const set&lt;<em>Key,</em>Compare,_Alloc>&amp; __x,</p>

<pre><code>                   const set&lt;_Key,_Compare,_Alloc&gt;&amp; __y) { // 比较相等操作符
</code></pre>

<p>  return <strong>x._M_t == </strong>y.<em>M_t;
}
template <class _Key, class _Compare, class _Alloc>
inline bool operator&lt;(const set&lt;</em>Key,<em>Compare,</em>Alloc>&amp; __x,</p>

<pre><code>                  const set&lt;_Key,_Compare,_Alloc&gt;&amp; __y) { // 比较大小操作符
</code></pre>

<p>  return <strong>x._M_t &lt; </strong>y.<em>M_t;
}
<code>``
可以看到基本都是调用</code></em>M_t<code>的方法来实现的，而这里的</code>_M_t` 是一个红黑树对象。</p>

<h2>3. multiset</h2>

<p>multiset 的特性和用法与 set 基本相同，唯一差别在于它允许有重复的键值，因此它的插入操作使用的底层机制是 RB-tree 的 <code>insert_equal()</code> 而不是 <code>insert_unique()</code> ，下面是 multiset 的主要代码，主要列出了与 set 不同的部分。<br/>
```
template <class _Key, class _Compare, class _Alloc>
class multiset {
public:
  multiset(const value_type<em> __first, const value_type</em> __last)</p>

<pre><code>: _M_t(_Compare(), allocator_type())
{ _M_t.insert_equal(__first, __last); } // 构造函数
</code></pre>

<p>  iterator insert(const value_type&amp; __x) { // 插入操作</p>

<pre><code>return _M_t.insert_equal(__x);
</code></pre>

<p>  }
  iterator insert(iterator <strong>position, const value_type&amp; </strong>x) {</p>

<pre><code>typedef typename _Rep_type::iterator _Rep_iterator;
return _M_t.insert_equal((_Rep_iterator&amp;)__position, __x);
</code></pre>

<p>  }
  void insert(const value_type<em> __first, const value_type</em> __last) {</p>

<pre><code>_M_t.insert_equal(__first, __last);
</code></pre>

<p>  }
  void insert(const_iterator <strong>first, const_iterator </strong>last) {</p>

<pre><code>_M_t.insert_equal(__first, __last);
</code></pre>

<p>  }
};
```
其他部分基本与 set 一样。</p>
]]></content>
  </entry>
  
</feed>